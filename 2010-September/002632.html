<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. ae7d152c49ab14f24cf213af74ebf015f3f5b427
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20ae7d152c49ab14f24cf213af74ebf015f3f5b427&In-Reply-To=%3C20100906105201.8B368481052%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002631.html">
   <LINK REL="Next"  HREF="002633.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. ae7d152c49ab14f24cf213af74ebf015f3f5b427</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20ae7d152c49ab14f24cf213af74ebf015f3f5b427&In-Reply-To=%3C20100906105201.8B368481052%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. ae7d152c49ab14f24cf213af74ebf015f3f5b427">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Mon Sep  6 12:52:00 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002631.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. b6b85432e32779a7ef445aac22c4c498f878de25
</A></li>
        <LI>Next message: <A HREF="002633.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 98f2b06176944a2ff4bfc2960d18727eef8abd73
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2632">[ date ]</a>
              <a href="thread.html#2632">[ thread ]</a>
              <a href="subject.html#2632">[ subject ]</a>
              <a href="author.html#2632">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  ae7d152c49ab14f24cf213af74ebf015f3f5b427 (commit)
       via  fb96ad0e52e6ae7780c3e57a019664a2136c45ee (commit)
      from  b6b85432e32779a7ef445aac22c4c498f878de25 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ae7d152c49ab14f24cf213af74ebf015f3f5b427
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Mon Sep 6 12:50:10 2010 +0200

    - DB: added missing dashes, resp. replaced with correct option dashes
    - DB: added set monospace.properties attribute for fo creation
    - DB: added common table id's

commit fb96ad0e52e6ae7780c3e57a019664a2136c45ee
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Fri Sep 3 13:50:37 2010 +0200

    - allow boot disk creation to work from real devices too
      * setupBootDisk(),setupInstallCD and setupInstallStick()
        can operate on real disk devices too
      * changed setupBootStick to call setupBootDisk with the
        selected stick device as parameter
      * added a destructor function in KIWIBoot to cleanup all
        created tmp directories after the object is no longer in
        use. Prevent all clean* function to remove and tmp dir
      * cleanup KIWIBoot: removed cleanTmp function
      * cleanup KIWIBoot: moved kpartx calls into function
      * cleanup KIWIBoot: moved stick search into function
      * cleanup KIWIBoot: added checkLVMbind function

-----------------------------------------------------------------------

Summary of changes:
diff --git a/doc/docbook/kiwi-doc-description.xml b/doc/docbook/kiwi-doc-description.xml
index 3b126b2..281c92a 100644
--- a/doc/docbook/kiwi-doc-description.xml
+++ b/doc/docbook/kiwi-doc-description.xml
@@ -101,7 +101,7 @@
       &lt;listitem&gt;
         &lt;para&gt; Configuration file which has been created by AutoYaST. To
           be able to create such an AutoYaST profile, run: &lt;/para&gt;
-        &lt;screen&gt;yast2 autoyast&lt;/screen&gt;
+        &lt;screen&gt;&lt;command&gt;yast2&lt;/command&gt; autoyast&lt;/screen&gt;
         &lt;para&gt;Once you have saved the information from the AutoYaST UI
           as &lt;filename&gt;config-yast-autoyast.xml&lt;/filename&gt; file in your
           image description directory KIWI will process on the file and
@@ -238,7 +238,7 @@
 
     &lt;sect2 id=&quot;sec.description.description&quot;&gt;
       &lt;title&gt;&lt;sgmltag&gt;description&lt;/sgmltag&gt; Element&lt;/title&gt;
-      &lt;screen&gt; &lt;description type=&quot;system&quot;&gt;
+      &lt;screen&gt;&lt;description type=&quot;system&quot;&gt;
   &lt;author&gt;an author&lt;/author&gt;
   &lt;contact&gt;mail&lt;/contact&gt;
   &lt;specification&gt;short info&lt;/specification&gt;
@@ -254,7 +254,7 @@
 
     &lt;sect2 id=&quot;sec.description.profiles&quot;&gt;
       &lt;title&gt;&lt;sgmltag&gt;profiles&lt;/sgmltag&gt; Element&lt;/title&gt;
-      &lt;screen&gt; &lt;profiles&gt;
+      &lt;screen&gt;&lt;profiles&gt;
    &lt;profile name=&quot;name&quot; description=&quot;text&quot;/&gt;
    &lt;sgmltag class=&quot;sgmlcomment&quot;&gt; ... &lt;/sgmltag&gt;
 &lt;/profiles&gt;&lt;/screen&gt;
@@ -993,7 +993,7 @@
                   use the following command to obtain a list of
                   supported values: &lt;/para&gt;
 
-                &lt;screen&gt;&lt;command&gt;sfdisk&lt;/command&gt; &#226;&#128;&#147;list-type &lt;/screen&gt;
+                &lt;screen&gt;&lt;command&gt;sfdisk&lt;/command&gt; --list-type &lt;/screen&gt;
 
                 &lt;para&gt;The required &lt;sgmltag class=&quot;attribute&quot;
                     &gt;number&lt;/sgmltag&gt; attribute provides the the number
diff --git a/doc/docbook/kiwi-doc-ec2.xml b/doc/docbook/kiwi-doc-ec2.xml
index 1f7b71e..f40c837 100644
--- a/doc/docbook/kiwi-doc-ec2.xml
+++ b/doc/docbook/kiwi-doc-ec2.xml
@@ -46,7 +46,7 @@
     creating an EC2 with KIWI after you can make sure your system is
     prepared for EC2 which means if you call the command
       &lt;command&gt;ec2-describe-images&lt;/command&gt;
-    &lt;option&gt;&#226;&#128;&#147;a&lt;/option&gt; you will get a valid output. &lt;/para&gt;
+    &lt;option&gt;-a&lt;/option&gt; you will get a valid output. &lt;/para&gt;
   
   &lt;sect1 id=&quot;sec.ec2.building&quot;&gt;
     &lt;title&gt;Building the suse-xen-guest Example for EC2&lt;/title&gt;
@@ -67,8 +67,8 @@
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples 
 &lt;command&gt;cd&lt;/command&gt; suse-11.3
-&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-xen-guest &#226;&#128;&#147;-add-profile \
-  ec2Flavour -&#226;&#128;&#147;root /tmp/myec2&lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-xen-guest --add-profile \
+  ec2Flavour --root /tmp/myec2&lt;/screen&gt;
 
     &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myec2 --add-profile \ 
  ec2Flavour --type vmx -d /tmp/myec2-result&lt;/screen&gt;
diff --git a/doc/docbook/kiwi-doc-iso.xml b/doc/docbook/kiwi-doc-iso.xml
index 3af1478..5f11a11 100644
--- a/doc/docbook/kiwi-doc-iso.xml
+++ b/doc/docbook/kiwi-doc-iso.xml
@@ -20,9 +20,9 @@
       11.2 and includes the base and KDE patterns. &lt;/para&gt;
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples cd suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-live-iso -&#226;&#128;&#147;root /tmp/myiso &lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-live-iso --root /tmp/myiso &lt;/screen&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/myiso &#226;&#128;&#147;-type iso -d /tmp/myiso-result&lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myiso --type iso -d /tmp/myiso-result&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.iso.using&quot;&gt;
diff --git a/doc/docbook/kiwi-doc-migrate.xml b/doc/docbook/kiwi-doc-migrate.xml
index 7ceb85d..80405c3 100644
--- a/doc/docbook/kiwi-doc-migrate.xml
+++ b/doc/docbook/kiwi-doc-migrate.xml
@@ -38,7 +38,7 @@
       know about all the repositories from which packages has been
       installed to the system. In a first step call: &lt;/para&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;migrate mySystem &lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --migrate mySystem &lt;/screen&gt;
 
     &lt;para&gt;This will create an HTML report where you can check which
       packages and patterns could be assigned to the given base
@@ -55,8 +55,8 @@
       that this package can&#226;&#128;&#153;t be provided or is not worth to become part
       of the migration. &lt;/para&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;migrate mySystem &#226;&#128;&#147;nofiles&lt;!-- 
-    --&gt;[ &#226;&#128;&#147;skip package ... ]&lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --migrate mySystem --nofiles&lt;!-- 
+    --&gt; [--skip package ... ]&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.migrate.watch-overlay&quot;&gt;
@@ -143,8 +143,8 @@
       version of the OEM image. If you burn the ISO on a DVD you can use
       that DVD to install your cloned image on another computer. &lt;/para&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; -p /tmp/migrated &#226;&#128;&#147;root /tmp/mySys
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;create /tmp/mySys -d /tmp/myResult &lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; -p /tmp/migrated --root /tmp/mySys
+&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/mySys -d /tmp/myResult &lt;/screen&gt;
 
     &lt;para&gt;If everything worked well you can test the created OEM image
       in any full virtual operating system environment like Qemu or
diff --git a/doc/docbook/kiwi-doc-oem.xml b/doc/docbook/kiwi-doc-oem.xml
index 051d5da..6c73af5 100644
--- a/doc/docbook/kiwi-doc-oem.xml
+++ b/doc/docbook/kiwi-doc-oem.xml
@@ -38,8 +38,8 @@
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples
 &lt;command&gt;cd&lt;/command&gt; suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-prepare ./suse-oem-preload &#226;&#128;&#147;-root /tmp/myoem &lt;/screen&gt;
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; -&#226;&#128;&#147;create /tmp/myoem &#226;&#128;&#147;-type split -d /tmp/myoem-result&lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-oem-preload --root /tmp/myoem &lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myoem --type split -d /tmp/myoem-result&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.oem.using&quot;&gt;
@@ -149,8 +149,8 @@
           &gt;true&lt;/sgmltag&gt;&quot; to of the &lt;sgmltag&gt;type&lt;/sgmltag&gt; element in
         your &lt;filename&gt;config.xml&lt;/filename&gt; file. &lt;/para&gt;
 
-      &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/myoem &#226;&#128;&#147;-type oem&lt;!-- 
-      --&gt; -d /tmp/myoem-result &#226;&#128;&#147;-lvm&lt;/screen&gt;
+      &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myoem --type oem&lt;!-- 
+      --&gt; -d /tmp/myoem-result --lvm&lt;/screen&gt;
 
       &lt;para&gt;With the optional &lt;sgmltag&gt;lvmvolumes&lt;/sgmltag&gt; section you
         can specify to have one or more top level directories in a
diff --git a/doc/docbook/kiwi-doc-pxe.xml b/doc/docbook/kiwi-doc-pxe.xml
index d0b5a7f..c2c0a8d 100644
--- a/doc/docbook/kiwi-doc-pxe.xml
+++ b/doc/docbook/kiwi-doc-pxe.xml
@@ -32,7 +32,7 @@
             the following variables: &lt;/para&gt;
           &lt;itemizedlist&gt;
             &lt;listitem&gt;
-              &lt;screen&gt;ATFTPD_OPTIONS=&quot;&#226;&#128;&#147;&#226;&#128;&#147;daemon &#226;&#128;&#147;&#226;&#128;&#147;no-multicast&quot;&lt;/screen&gt;
+              &lt;screen&gt;ATFTPD_OPTIONS=&quot;--daemon --no-multicast&quot;&lt;/screen&gt;
             &lt;/listitem&gt;
             &lt;listitem&gt;
               &lt;screen&gt;ATFTPD_DIRECTORY=&quot;/srv/tftpboot&quot;&lt;/screen&gt;
@@ -105,8 +105,8 @@ subnet 192.168.100.0 netmask 255.255.255.0 {
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples
 &lt;command&gt;cd&lt;/command&gt; suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-prepare ./suse-pxe-client -&#226;&#128;&#147;root /tmp/mypxe&lt;/screen&gt;
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; -&#226;&#128;&#147;create /tmp/mypxe &#226;&#128;&#147;-type pxe -d /tmp/mypxe-result&lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-pxe-client --root /tmp/mypxe&lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/mypxe --type pxe -d /tmp/mypxe-result&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.pxe.using&quot;&gt;
diff --git a/doc/docbook/kiwi-doc-usb.xml b/doc/docbook/kiwi-doc-usb.xml
index 19d9250..ff77c1a 100644
--- a/doc/docbook/kiwi-doc-usb.xml
+++ b/doc/docbook/kiwi-doc-usb.xml
@@ -19,7 +19,7 @@
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples
 &lt;command&gt;cd&lt;/command&gt; suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-prepare ./suse-live-stick &#226;&#128;&#147;-root /tmp/mystick &lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-live-stick --root /tmp/mystick &lt;/screen&gt;
 
     &lt;para&gt;There are two possible image types which allows you to drive
       the stick. Both are added into the &lt;filename&gt;config.xml&lt;/filename&gt;
@@ -32,7 +32,7 @@
         &lt;para&gt;The first image type named usb creates all required images
           for booting the OS but requires you to plug in the stick and
           let KIWI deploy the data onto this stick. &lt;/para&gt;
-        &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; -&#226;&#128;&#147;create /tmp/mystick &#226;&#128;&#147;-type usb d /tmp/mystick-result &lt;/screen&gt;
+        &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/mystick --type usb d /tmp/mystick-result &lt;/screen&gt;
       &lt;/listitem&gt;
       &lt;listitem&gt;
         &lt;para&gt;The second image type named oem allows you to create a
@@ -40,7 +40,7 @@
           including all partitions and boot information in one file. You
           simply can &lt;command&gt;dd&lt;/command&gt; this file on the stick. &lt;/para&gt;
 
-        &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/mystick &#226;&#128;&#147;-type oem -d /tmp/mystick-result &lt;/screen&gt;
+        &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/mystick --type oem -d /tmp/mystick-result &lt;/screen&gt;
       &lt;/listitem&gt;
     &lt;/itemizedlist&gt;
   &lt;/sect1&gt;
@@ -55,10 +55,10 @@
       partition table on the stick and imports the created images as
       follows: &lt;/para&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-bootstick \
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --bootstick \
     /tmp/mystick-result/ \
     initrd-usbboot-suse-11.2.i686-2.1.1.splash.gz \
-    &#226;&#128;&#147;-bootstick-system \
+    --bootstick-system \
     /tmp/mystick-result/ \
     suse-11.2-live-stick.i686-1.1.2&lt;/screen&gt;
 
diff --git a/doc/docbook/kiwi-doc-vmx.xml b/doc/docbook/kiwi-doc-vmx.xml
index 60832f2..4e529bc 100644
--- a/doc/docbook/kiwi-doc-vmx.xml
+++ b/doc/docbook/kiwi-doc-vmx.xml
@@ -21,9 +21,9 @@
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples 
 &lt;command&gt;cd&lt;/command&gt; suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;prepare ./suse-vm-guest -&#226;&#128;&#147;root /tmp/myvm &lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-vm-guest --root /tmp/myvm &lt;/screen&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/myvm &#226;&#128;&#147;-type vmx -d /tmp/myvm-result&lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myvm --type vmx -d /tmp/myvm-result&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.vmx.using&quot;&gt;
@@ -55,44 +55,33 @@
     &lt;para&gt;The following table lists the supported virtual disk
       formats:&lt;/para&gt;
 
-    &lt;informaltable&gt;
-      &lt;tr&gt;
-        &lt;td&gt;
-          &lt;para&gt;
-            &lt;emphasis role=&quot;bold&quot;&gt;Name&lt;/emphasis&gt;
-          &lt;/para&gt;
-        &lt;/td&gt;
-        &lt;td&gt;
-          &lt;para&gt;
-            &lt;emphasis role=&quot;bold&quot;&gt;Description&lt;/emphasis&gt;
-          &lt;/para&gt;
-        &lt;/td&gt;
-      &lt;/tr&gt;
-      &lt;tr&gt;
-        &lt;td&gt;
-          &lt;para&gt;vmdk &lt;/para&gt;
-        &lt;/td&gt;
-        &lt;td&gt;
-          &lt;para&gt;Disk format for VMware &lt;/para&gt;
-        &lt;/td&gt;
-      &lt;/tr&gt;
-      &lt;tr&gt;
-        &lt;td&gt;
-          &lt;para&gt;ovf &lt;/para&gt;
-        &lt;/td&gt;
-        &lt;td&gt;
-          &lt;para&gt; Open Virtual Format requires VMwares ovftool &lt;/para&gt;
-        &lt;/td&gt;
-      &lt;/tr&gt;
-      &lt;tr&gt;
-        &lt;td&gt;
-          &lt;para&gt;qcow2 &lt;/para&gt;
-        &lt;/td&gt;
-        &lt;td&gt;
-          &lt;para&gt; QEMU virtual disk format &lt;/para&gt;
-        &lt;/td&gt;
-      &lt;/tr&gt;
-    &lt;/informaltable&gt;
+    &lt;table id=&quot;tab.vmx.supported-disk-formats&quot;&gt;
+      &lt;title&gt;Supported Virtual Disk Formats&lt;/title&gt;
+      &lt;tgroup cols=&quot;2&quot;&gt;
+        &lt;colspec colwidth=&quot;1*&quot;/&gt;
+        &lt;colspec colwidth=&quot;3*&quot;/&gt;
+        &lt;thead&gt;
+          &lt;row&gt;
+            &lt;entry&gt;Name&lt;/entry&gt;
+            &lt;entry&gt;Description&lt;/entry&gt;
+          &lt;/row&gt;
+        &lt;/thead&gt;
+        &lt;tbody&gt;
+          &lt;row&gt;
+            &lt;entry&gt;vmdk&lt;/entry&gt;
+            &lt;entry&gt;Disk format for VMware&lt;/entry&gt;
+          &lt;/row&gt;
+          &lt;row&gt;
+            &lt;entry&gt;ovf&lt;/entry&gt;
+            &lt;entry&gt;Open Virtual Format requires VMwares ovftool&lt;/entry&gt;
+          &lt;/row&gt;
+          &lt;row&gt;
+            &lt;entry&gt;qcow2&lt;/entry&gt;
+            &lt;entry&gt;QEMU virtual disk format&lt;/entry&gt;
+          &lt;/row&gt;
+        &lt;/tbody&gt;
+      &lt;/tgroup&gt;      
+    &lt;/table&gt;
 
     &lt;sect2 id=&quot;sec.vmx.vmware-support&quot;&gt;
       &lt;title&gt;VMware support&lt;/title&gt;
@@ -167,8 +156,8 @@
         or add the attribute lvm=&quot;true&quot; as part of the type section in
         your &lt;filename&gt;config.xml&lt;/filename&gt; file. &lt;/para&gt;
 
-      &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/myvm &#226;&#128;&#147;-type vmx&lt;!--
-       --&gt; -d /tmp/myvm-result &#226;&#128;&#147;-lvm &lt;/screen&gt;
+      &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myvm --type vmx&lt;!--
+       --&gt; -d /tmp/myvm-result --lvm &lt;/screen&gt;
 
       &lt;para&gt;With the optional lvmvolumes section you can set one or more
         top level directories into a separate volume. See &lt;xref
diff --git a/doc/docbook/kiwi-doc-xen.xml b/doc/docbook/kiwi-doc-xen.xml
index 192e561..30042ed 100644
--- a/doc/docbook/kiwi-doc-xen.xml
+++ b/doc/docbook/kiwi-doc-xen.xml
@@ -30,9 +30,9 @@
       11.3 and includes the base pattern. &lt;/para&gt;
 
     &lt;screen&gt;&lt;command&gt;cd&lt;/command&gt; /usr/share/doc/packages/kiwi/examples cd suse-11.2
-&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-prepare ./suse-xen-guest &#226;&#128;&#147;-root /tmp/myxen&lt;/screen&gt;
+&lt;command&gt;kiwi&lt;/command&gt; --prepare ./suse-xen-guest --root /tmp/myxen&lt;/screen&gt;
 
-    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; &#226;&#128;&#147;-create /tmp/myxen &#226;&#128;&#147;-type vmx -d /tmp/myxen-result&lt;/screen&gt;
+    &lt;screen&gt;&lt;command&gt;kiwi&lt;/command&gt; --create /tmp/myxen --type vmx -d /tmp/myxen-result&lt;/screen&gt;
   &lt;/sect1&gt;
 
   &lt;sect1 id=&quot;sec.xen.using&quot;&gt;
diff --git a/doc/docbook/xslt/fo/docbook.xsl b/doc/docbook/xslt/fo/docbook.xsl
index 8106f7d..33190b6 100644
--- a/doc/docbook/xslt/fo/docbook.xsl
+++ b/doc/docbook/xslt/fo/docbook.xsl
@@ -24,6 +24,24 @@
     &lt;xsl:attribute name=&quot;background-color&quot;&gt;#E0E0E0&lt;/xsl:attribute&gt;
   &lt;/xsl:attribute-set&gt;
 
+  &lt;xsl:attribute-set name=&quot;monospace.properties&quot;&gt;
+    &lt;xsl:attribute name=&quot;font-size&quot;&gt;
+      &lt;xsl:choose&gt;
+        &lt;xsl:when test=&quot;ancestor::title&quot;&gt;inherit&lt;/xsl:when&gt;
+        &lt;xsl:otherwise&gt;
+          &lt;xsl:value-of select=&quot;$body.font.master * 0.9&quot;/&gt;
+          &lt;xsl:text&gt;pt&lt;/xsl:text&gt;
+        &lt;/xsl:otherwise&gt;
+      &lt;/xsl:choose&gt;
+    &lt;/xsl:attribute&gt;
+  &lt;/xsl:attribute-set&gt;
+  &lt;xsl:attribute-set name=&quot;monospace.verbatim.properties&quot;&gt;
+    &lt;xsl:attribute name=&quot;font-size&quot;&gt;
+      &lt;xsl:value-of select=&quot;$body.font.master * 0.8&quot;/&gt;
+      &lt;xsl:text&gt;pt&lt;/xsl:text&gt;
+    &lt;/xsl:attribute&gt;
+  &lt;/xsl:attribute-set&gt;
+  
   &lt;!--
     &lt;xsl:param name=&quot;toc.section.depth&quot; select=&quot;3&quot;/&gt;
     &lt;xsl:param name=&quot;toc.max.depth&quot; select=&quot;4&quot;/&gt;
@@ -126,33 +144,25 @@
         &lt;/xsl:call-template&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test=&quot;$class='starttag'&quot;&gt;
-        &lt;fo:inline color=&quot;{$sgmltag.starttag.color}&quot;&gt;
-          &lt;xsl:call-template name=&quot;inline.monoseq&quot;&gt;
-            &lt;xsl:with-param name=&quot;content&quot;&gt;
-              &lt;xsl:text&gt;&lt;&lt;/xsl:text&gt;
-              &lt;xsl:apply-templates/&gt;
-              &lt;xsl:text&gt;&gt;&lt;/xsl:text&gt;
-            &lt;/xsl:with-param&gt;
-          &lt;/xsl:call-template&gt;
+        &lt;fo:inline color=&quot;{$sgmltag.starttag.color}&quot; font-family=&quot;{$monospace.font.family}&quot;&gt;
+            &lt;xsl:text&gt;&lt;&lt;/xsl:text&gt;
+            &lt;xsl:apply-templates/&gt;
+            &lt;xsl:text&gt;&gt;&lt;/xsl:text&gt;
         &lt;/fo:inline&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test=&quot;$class='emptytag'&quot;&gt;
-        &lt;xsl:call-template name=&quot;inline.monoseq&quot;&gt;
-          &lt;xsl:with-param name=&quot;content&quot;&gt;
+          &lt;fo:inline font-family=&quot;{$monospace.font.family}&quot;&gt;
             &lt;xsl:text&gt;&lt;&lt;/xsl:text&gt;
             &lt;xsl:apply-templates/&gt;
             &lt;xsl:text&gt;/&gt;&lt;/xsl:text&gt;
-          &lt;/xsl:with-param&gt;
-        &lt;/xsl:call-template&gt;
+          &lt;/fo:inline&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test=&quot;$class='sgmlcomment' or $class='comment'&quot;&gt;
-        &lt;xsl:call-template name=&quot;inline.monoseq&quot;&gt;
-          &lt;xsl:with-param name=&quot;content&quot;&gt;
-            &lt;xsl:text&gt;&lt;!--&lt;/xsl:text&gt;
-            &lt;xsl:apply-templates/&gt;
-            &lt;xsl:text&gt;--&gt;&lt;/xsl:text&gt;
-          &lt;/xsl:with-param&gt;
-        &lt;/xsl:call-template&gt;
+        &lt;fo:inline&gt;
+          &lt;xsl:text&gt;&lt;!--&lt;/xsl:text&gt;
+          &lt;xsl:apply-templates/&gt;
+          &lt;xsl:text&gt;--&gt;&lt;/xsl:text&gt;
+        &lt;/fo:inline&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
         &lt;xsl:call-template name=&quot;inline.charseq&quot;/&gt;
diff --git a/kiwi.pl b/kiwi.pl
index ced39bc..32418e0 100755
--- a/kiwi.pl
+++ b/kiwi.pl
@@ -1175,7 +1175,6 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		$boot -&gt; setupSplash();
-		$boot -&gt; cleanTmp();
 		my $code = kiwiExit (0); return $code;
 	}
 
@@ -1192,10 +1191,8 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		if (! $boot -&gt; setupBootStick()) {
-			$boot -&gt; cleanTmp();
 			my $code = kiwiExit (1); return $code;
 		}
-		$boot -&gt; cleanTmp();
 		my $code = kiwiExit (0); return $code;
 	}
 
@@ -1245,10 +1242,8 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		if (! $boot -&gt; setupInstallCD()) {
-			$boot -&gt; cleanTmp();
 			my $code = kiwiExit (1); return $code;
 		}
-		$boot -&gt; cleanTmp();
 		my $code = kiwiExit (0); return $code;
 	}
 
@@ -1268,10 +1263,8 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		if (! $boot -&gt; setupInstallStick()) {
-			$boot -&gt; cleanTmp();
 			my $code = kiwiExit (1); return $code;
 		}
-		$boot -&gt; cleanTmp();
 		my $code = kiwiExit (0); return $code;
 	}
 
@@ -1303,10 +1296,8 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		if (! $boot -&gt; setupBootDisk()) {
-			$boot -&gt; cleanTmp();
 			my $code = kiwiExit (1); return $code;
 		}
-		$boot -&gt; cleanTmp();
 		$code = kiwiExit (0); return $code;
 	}
 	
diff --git a/modules/KIWIBoot.pm b/modules/KIWIBoot.pm
index 7131bec..dbade5b 100644
--- a/modules/KIWIBoot.pm
+++ b/modules/KIWIBoot.pm
@@ -173,6 +173,7 @@ sub new {
 	$this-&gt;{tmpdir}   = $tmpdir;
 	$this-&gt;{loopdir}  = $loopdir;
 	$this-&gt;{lvmgroup} = $vgroup;
+	$this-&gt;{tmpdirs}  = [ $tmpdir, $loopdir ];
 
 	#==========================================
 	# setup pointer to XML configuration
@@ -188,22 +189,17 @@ sub new {
 				#==========================================
 				# bind $system to loop device
 				#------------------------------------------
-				$kiwi -&gt; info (&quot;Binding virtual disk to loop device&quot;);
-				if (! $this -&gt; bindLoopDevice($system)) {
+				$kiwi -&gt; info (&quot;Binding disk to loop device&quot;);
+				if (! $this -&gt; bindDiskDevice($system)) {
 					$kiwi -&gt; failed ();
-					$this -&gt; cleanTmp ();
 					return undef;
 				}
 				$kiwi -&gt; done();
 				#==========================================
 				# setup device mapper
 				#------------------------------------------
-				$kiwi -&gt; info (&quot;Setup device mapper on image file&quot;);
-				$status = qxx ( &quot;/sbin/kpartx -a $this-&gt;{loop} 2&gt;&amp;1&quot; );
-				$result = $? &gt;&gt; 8;
-				if ($result != 0) {
-					$kiwi -&gt; failed ();
-					$kiwi -&gt; error  (&quot;Failed mapping vpartitions: $status&quot;);
+				$kiwi -&gt; info (&quot;Setup device mapper for partition access&quot;);
+				if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
 					$kiwi -&gt; failed ();
 					$this -&gt; cleanLoop ();
 					return undef;
@@ -212,22 +208,14 @@ sub new {
 				#==========================================
 				# find partition and mount it
 				#------------------------------------------
-				my $dmap = $this-&gt;{loop}; $dmap =~ s/dev\///;
-				my $sdev = &quot;/dev/mapper&quot;.$dmap.&quot;p1&quot;;
-				for (my $try=0;$try&lt;=3;$try++) {
-					if (defined (my $lvroot = glob (&quot;/dev/mapper/*-LVRoot&quot;))) {
-						$this-&gt;{lvm} = 1;
-						$sdev = $lvroot;
-						if (defined ($lvroot = glob (&quot;/dev/mapper/*-LVComp&quot;))) {
-							$sdev = $lvroot;
-						}
-						if ($lvroot =~ /mapper\/(.*)-.*/) {
-							$this-&gt;{lvmgroup} = $1;
-						}
-						last;
-					}
-					sleep 1;
-				}
+				my $sdev = $this-&gt;{bindloop}.&quot;1&quot;;
+				#==========================================
+				# check for activated volume group
+				#------------------------------------------
+				$sdev = $this -&gt; checkLVMbind ($sdev);
+				#==========================================
+				# perform mount call
+				#------------------------------------------
 				if (! main::mount($sdev, $tmpdir)) {
 					$kiwi -&gt; error (&quot;System image mount failed: $status&quot;);
 					$kiwi -&gt; failed ();
@@ -243,13 +231,12 @@ sub new {
 				#==========================================
 				# clean up
 				#------------------------------------------
-				$this -&gt; cleanLoop (&quot;keep-mountpoints&quot;);
+				$this -&gt; cleanLoop ();
 			} else {
 				#==========================================
 				# loop mount system image
 				#------------------------------------------
 				if (! main::mount ($system,$tmpdir)) {
-					$this -&gt; cleanTmp ();
 					return undef;
 				}
 				#==========================================
@@ -265,7 +252,6 @@ sub new {
 			}
 		}
 		if (! defined $xml) {
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 	}
@@ -472,7 +458,6 @@ sub createBootStructure {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Failed importing initrd: $!&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	$status = qxx ( &quot;cp $kernel $tmpdir/boot/$lname 2&gt;&amp;1&quot; );
@@ -481,7 +466,6 @@ sub createBootStructure {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Failed importing kernel: $!&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	if (($isxen) &amp;&amp; ($xendomain eq &quot;dom0&quot;)) {
@@ -491,7 +475,6 @@ sub createBootStructure {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Failed importing Xen dom0 kernel: $!&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 	}
@@ -551,911 +534,18 @@ sub getRemovableUSBStorageDevices {
 # setupBootStick
 #------------------------------------------
 sub setupBootStick {
-	my $this      = shift;
-	my $kiwi      = $this-&gt;{kiwi};
-	my $arch      = $this-&gt;{arch};
-	my $tmpdir    = $this-&gt;{tmpdir};
-	my $initrd    = $this-&gt;{initrd};
-	my $system    = $this-&gt;{system};
-	my $syszip    = $this-&gt;{syszip};
-	my $device    = $this-&gt;{device};
-	my $loopdir   = $this-&gt;{loopdir};
-	my $zipped    = $this-&gt;{zipped};
-	my $isxen     = $this-&gt;{isxen};
-	my $lvm       = $this-&gt;{lvm};
-	my $profile   = $this-&gt;{profile};
-	my %deviceMap = ();
-	my @commands  = ();
-	my $imgtype   = &quot;usb&quot;;
-	my $haveSplit = 0;
-	my $haveTree  = 0;
-	my $lvmbootMB = 0;
-	my $luksbootMB= 0;
-	my $syslbootMB= 0;
-	my $dmbootMB  = 0;
-	my $dmapper   = 0;
-	my $haveluks  = 0;
-	my $needBootP = 0;
-	my $bootloader= &quot;grub&quot;;
-	my $lvmsize;
-	my $syslsize;
-	my $dmsize;
-	my $lukssize;
-	my $FSTypeRW;
-	my $FSTypeRO;
-	my $status;
-	my $result;
-	my $hald;
-	my $xml;
-	my %lvmparts;
-	my $root;
-	#==========================================
-	# check if system is tree or image file
-	#------------------------------------------
-	if ( -d $system ) {
-		#==========================================
-		# check image type
-		#------------------------------------------
-		if (-f &quot;$system/rootfs.tar&quot;) {
-			$kiwi -&gt; error (&quot;Can't use split root tree, run create first&quot;);
-			$kiwi -&gt; failed ();
-			return undef;
-		}
-		$xml = new KIWIXML ( $kiwi,$system.&quot;/image&quot;,undef,$imgtype,$profile );
-		if (! defined $xml) {
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		$haveTree = 1;
-	} else {
-		if (! main::mount ($system,$tmpdir)) {
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		if (-f &quot;$tmpdir/rootfs.tar&quot;) {
-			$imgtype = &quot;split&quot;;
-		}
-		$xml = new KIWIXML ( $kiwi,$tmpdir.&quot;/image&quot;,undef,$imgtype,$profile );
-		main::umount();
-		if (! defined $xml) {
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-	}
-	#==========================================
-	# load type attributes...
-	#------------------------------------------
-	my %type = %{$xml-&gt;getImageTypeAndAttributes()};
-	#==========================================
-	# use lvm together with system image only
-	#------------------------------------------
-	if (! defined $system) {
-		undef $type{lvm};
-		undef $lvm;
-	}
-	#==========================================
-	# Check for LVM...
-	#------------------------------------------
-	if (($type{lvm} =~ /true|yes/i) || ($lvm)) {
-		#==========================================
-		# add boot space if lvm based
-		#------------------------------------------
-		$lvm = 1;
-		$lvmbootMB  = 60;
-		$this-&gt;{lvm}= $lvm;
-		#==========================================
-		# set volume group name
-		#------------------------------------------
-		my $vgroupName = $xml -&gt; getLVMGroupName();
-		if ($vgroupName) {
-			$this-&gt;{lvmgroup} = $vgroupName;
-		}
-		#==========================================
-		# check and set LVM volumes setup
-		#------------------------------------------
-		%lvmparts = $xml -&gt; getLVMVolumes();
-		if (%lvmparts) {
-			if ( ! -d $system ) {
-				$kiwi -&gt; error (
-					&quot;LVM volumes setup requires root tree but got image file&quot;
-				);
-				$kiwi -&gt; failed ();
-				$this -&gt; cleanTmp ();
-				return undef;
-			}
-			foreach my $vol (keys %lvmparts) {
-				#==========================================
-				# check directory per volume
-				#------------------------------------------
-				my $pname  = $vol; $pname =~ s/_/\//g;
-				if (! -d &quot;$system/$pname&quot;) {
-					$kiwi -&gt; error (&quot;Directory $system/$pname does not exist&quot;);
-					$kiwi -&gt; failed ();
-					$this -&gt; cleanTmp ();
-					return undef;
-				}
-			}
-		}
-	}
-	#==========================================
-	# check for overlay filesystems
-	#------------------------------------------
-	if ($type{filesystem} eq &quot;clicfs&quot;) {
-		$this-&gt;{dmapper} = 1;
-		$dmapper  = 1;
-		$dmbootMB = 60;
-	}
-	#==========================================
-	# check if fs requires a boot partition
-	#------------------------------------------
-	if ($type{filesystem} eq &quot;btrfs&quot;) {
-		$needBootP  = 1;
-		$luksbootMB = 60;
-	}
-	#==========================================
-	# check for LUKS extension
-	#------------------------------------------
-	if ($type{luks}) {
-		$haveluks   = 1;
-		$luksbootMB = 60;
-	}
-	#==========================================
-	# setup boot loader type
-	#------------------------------------------
-	if ($type{bootloader}) {
-		$bootloader = $type{bootloader};
-	}
-	$this-&gt;{bootloader} = $bootloader;
-	$this-&gt;{imgtype}    = $imgtype;
-	#==========================================
-	# add boot space if syslinux based
-	#------------------------------------------
-	if ($bootloader =~ /(sys|ext)linux/) {
-		$syslbootMB= 60;
-	}
-	#==========================================
-	# check image split portion
-	#------------------------------------------
-	my $destdir  = dirname ($initrd);
-	my $label    = $xml -&gt; getImageDisplayName();
-	my $version  = $xml -&gt; getImageVersion();
-	my $diskname = $xml -&gt; getImageName();
-	my $splitfile= $destdir.&quot;/&quot;.$diskname.&quot;-read-write.&quot;.$arch.&quot;-&quot;.$version;
-	if ($imgtype eq &quot;split&quot;) {
-		if (-f $splitfile) {
-			$haveSplit = 1;
-		}
-	}
-	#==========================================
-	# set boot partition number
-	#------------------------------------------
-	my $bootpart = &quot;0&quot;;
-	if (($syszip) || ($haveSplit) || ($lvm) || ($haveluks) || ($needBootP)) {
-		$bootpart = &quot;1&quot;;
-	}
-	if ((($syszip) || ($haveSplit)) &amp;&amp; ($haveluks)) {
-		$bootpart = &quot;2&quot;;
-	}
-	if (($dmapper) &amp;&amp; ($lvm)) {
-		$bootpart = &quot;1&quot;;
-	} elsif ($dmapper) {
-		$bootpart = &quot;2&quot;
-	}
-	$this-&gt;{bootpart} = $bootpart;
-	$this-&gt;{bootlabel}= $label;
-	#==========================================
-	# obtain filesystem type from xml data
-	#------------------------------------------
-	if ($type{filesystem} =~ /(.*),(.*)/) {
-		$FSTypeRW = $1;
-		$FSTypeRO = $2;
-	} else {
-		$FSTypeRW = $type{filesystem};
-		$FSTypeRO = $FSTypeRW;
-	}
-	#==========================================
-	# Create Stick boot structure
-	#------------------------------------------
-	if (! $this -&gt; createBootStructure(&quot;vmx&quot;)) {
-		$this -&gt; cleanTmp ();
-		return undef;
-	}
-	#==========================================
-	# Import boot loader stages
-	#------------------------------------------
-	if (! $this -&gt; setupBootLoaderStages ($bootloader)) {
-		$this -&gt; cleanTmp ();
-		return undef;
-	}
-	#==========================================
-	# Find USB stick devices
-	#------------------------------------------
-	my %storage = $this -&gt; getRemovableUSBStorageDevices();
-	if (! %storage) {
-		$kiwi -&gt; error  (&quot;Couldn't find any removable USB storage devices&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
-		return undef;
-	}
-	my $prefix = $kiwi -&gt; getPrefix (1);
-	print STDERR $prefix,&quot;Found following removable USB devices:\n&quot;;
-	foreach my $dev (keys %storage) {
-		print STDERR $prefix,&quot;---&gt; $storage{$dev} at $dev\n&quot;;
-	}
-	my $stick;
-	if (! defined $device) {
-		#==========================================
-		# Let the user select the device
-		#------------------------------------------
-		while (1) {
-			$prefix = $kiwi -&gt; getPrefix (1);
-			print STDERR $prefix,&quot;Your choice (enter device name): &quot;;
-			chomp ($stick = &lt;&gt;);
-			my $found = 0;
-			foreach my $dev (keys %storage) {
-				if ($dev eq $stick) {
-					$found = 1; last;
-				}
-			}
-			if (! $found) {
-				if ($stick) {
-					print STDERR $prefix,&quot;Couldn't find [ $stick ] in list\n&quot;;
-				}
-				next;
-			}
-			last;
-		}
-	} else {
-		#==========================================
-		# Check the given device
-		#------------------------------------------
-		$stick = $device;
-		my $found = 0;
-		foreach my $dev (keys %storage) {
-			if ($dev eq $stick) {
-				$found = 1; last;
-			}
-		}
-		if (! $found) {
-			print STDERR $prefix,&quot;Couldn't find [ $stick ] in list\n&quot;;
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-	}
-	#==========================================
-	# Creating boot loader configuration
-	#------------------------------------------
-	if (! $this -&gt; setupBootLoaderConfiguration ($bootloader,&quot;USB&quot;)) {
-		return undef;
-	}
-	#==========================================
-	# umount stick mounted by hal before lock
-	#------------------------------------------
-	$this -&gt; umountDevice ($stick);
-	#==========================================
-	# Wait for umount to settle
-	#------------------------------------------
-	sleep (1);
-	#==========================================
-	# Check if system fits on storage device
-	#------------------------------------------
-	my $hardSize = $this -&gt; getStorageSize ($stick);
-	my $softSize = main::isize ($system);
-	if (-f $splitfile) {
-		$softSize += main::isize ($splitfile);
-	}
-	$softSize /= 1024;
-	$softSize += $lvmbootMB + $luksbootMB + $syslbootMB + $dmbootMB;
-	if ($hardSize &lt; $softSize) {
-		$kiwi -&gt; error  (&quot;Stick too small: got $hardSize kB need $softSize kB&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
-		return undef;
-	}
-	#==========================================
-	# Create new partition table on stick
-	#------------------------------------------
-	$kiwi -&gt; info (&quot;Creating partition table on: $stick&quot;);
-	while (1) {
-		if (defined $system) {
-			if (! $lvm) {
-				if (($syszip) || ($haveSplit) || ($dmapper)) {
-					if ($bootloader =~ /(sys|ext)linux/) {
-						my $partid = 6;
-						if ($bootloader eq &quot;extlinux&quot; ) {
-							$partid = 83;
-						}
-						$syslsize = $hardSize;
-						$syslsize /= 1024;
-						$syslsize -= $syszip;
-						$syslsize -= $syslbootMB;
-						$syslsize = sprintf (&quot;%.f&quot;,$syslsize);
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syszip.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;+&quot;.$syslsize.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,
-							&quot;t&quot;,&quot;1&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;2&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;3&quot;,$partid,
-							&quot;a&quot;,&quot;3&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					} elsif ($dmapper) {
-						$dmsize = $hardSize;
-						$dmsize /= 1024;
-						$dmsize -= $syszip;
-						$dmsize -= $dmbootMB;
-						$dmsize = sprintf (&quot;%.f&quot;,$dmsize);
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syszip.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;+&quot;.$dmsize.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,
-							&quot;t&quot;,&quot;1&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;2&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;3&quot;,&quot;83&quot;,
-							&quot;a&quot;,&quot;3&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					} elsif ($haveluks) {
-						$lukssize = $hardSize;
-						$lukssize /= 1024;
-						$lukssize -= $syszip;
-						$lukssize -= $luksbootMB;
-						$lukssize = sprintf (&quot;%.f&quot;,$lukssize);
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syszip.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;+&quot;.$lukssize.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,
-							&quot;t&quot;,&quot;1&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;2&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;3&quot;,&quot;83&quot;,
-							&quot;a&quot;,&quot;3&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					} else {
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syszip.&quot;M&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,
-							&quot;t&quot;,&quot;1&quot;,&quot;83&quot;,
-							&quot;t&quot;,&quot;2&quot;,&quot;83&quot;,
-							&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					}
-				} else {
-					if ($bootloader =~ /(sys|ext)linux/) {
-						my $partid = 6;
-						if ($bootloader eq &quot;extlinux&quot; ) {
-							$partid = 83;
-						}
-						$syslsize = $hardSize;
-						$syslsize /= 1024;
-						$syslsize -= $syslbootMB;
-						$syslsize = sprintf (&quot;%.f&quot;,$syslsize);
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syslsize.&quot;M&quot;,&quot;t&quot;,&quot;83&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;t&quot;,&quot;2&quot;,$partid,
-							&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					} elsif (($haveluks) || ($needBootP)) {
-						$lukssize = $hardSize;
-						$lukssize /= 1024;
-						$lukssize -= $luksbootMB;
-						$lukssize = sprintf (&quot;%.f&quot;,$lukssize);
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$lukssize.&quot;M&quot;,&quot;t&quot;,&quot;83&quot;,
-							&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,
-							&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					} else {
-						@commands = (
-							&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;.&quot;,&quot;t&quot;,&quot;83&quot;,
-							&quot;a&quot;,&quot;1&quot;,&quot;w&quot;,&quot;q&quot;
-						);
-					}
-				}
-			} else {
-				$lvmsize = $hardSize;
-				$lvmsize /= 1024;
-				$lvmsize -= $lvmbootMB;
-				$lvmsize = sprintf (&quot;%.f&quot;,$lvmsize);
-				if ($bootloader =~ /(sys|ext)linux/) {
-					my $partid = 6;
-					if ($bootloader eq &quot;extlinux&quot; ) {
-						$partid = 83;
-					}
-					@commands = (
-						&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$lvmsize.&quot;M&quot;,
-						&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,
-						&quot;t&quot;,&quot;1&quot;,&quot;8e&quot;,
-						&quot;t&quot;,&quot;2&quot;,$partid,
-						&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-					);
-				} else {
-					@commands = (
-						&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$lvmsize.&quot;M&quot;,
-						&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,
-						&quot;t&quot;,&quot;1&quot;,&quot;8e&quot;,
-						&quot;t&quot;,&quot;2&quot;,&quot;83&quot;,
-						&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-					);
-				}
-			}
-		} else {
-			if ($bootloader =~ /(sys|ext)linux/) {
-				my $partid = 6;
-				if ($bootloader eq &quot;extlinux&quot; ) {
-					$partid = 83;
-				}
-				$syslsize = $hardSize;
-				$syslsize /= 1024;
-				$syslsize -= $syslbootMB;
-				$syslsize = sprintf (&quot;%.f&quot;,$syslsize);
-				@commands = (
-					&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$syslsize.&quot;M&quot;,&quot;t&quot;,&quot;83&quot;,
-					&quot;n&quot;,&quot;p&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;t&quot;,&quot;2&quot;,$partid,
-					&quot;a&quot;,&quot;2&quot;,&quot;w&quot;,&quot;q&quot;
-				);
-			} else {
-				@commands = (
-					&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;.&quot;,&quot;t&quot;,&quot;83&quot;,
-					&quot;a&quot;,&quot;1&quot;,&quot;w&quot;,&quot;q&quot;
-				);
-			}
-		}
-		if (! $this -&gt; setStoragePartition ($stick,\@commands)) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't create partition table&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		#==========================================
-		# Create default device mapping table
-		#------------------------------------------
-		%deviceMap = $this -&gt; setDefaultDeviceMap ($stick);
-		#==========================================
-		# Umount possible mounted stick partitions
-		#------------------------------------------
-		$this -&gt; umountDevice ($stick);
-		for (my $try=0;$try&gt;=2;$try++) {
-			$status = qxx ( &quot;/sbin/blockdev --rereadpt $stick 2&gt;&amp;1&quot; );
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				sleep (1); next;
-			}
-			last;
-		}
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't reread partition table: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		#==========================================
-		# Wait for new partition table to settle
-		#------------------------------------------
-		sleep (1);
-		#==========================================
-		# Umount possible mounted stick partitions
-		#------------------------------------------
-		$this -&gt; umountDevice ($stick);
-		#==========================================
-		# setup volume group if requested
-		#------------------------------------------
-		if ($lvm) {
-			%deviceMap = $this -&gt; setVolumeGroup (
-				\%deviceMap,$stick,$syszip,$haveSplit,\%lvmparts
-			);
-			if (! %deviceMap) {
-				$this -&gt; cleanTmp ();
-				return undef;
-			}
-		}
-		#==========================================
-		# check partition sizes
-		#------------------------------------------
-		if ((defined $system) &amp;&amp; (($syszip) || ($haveSplit))) {
-			my $sizeOK = 1;
-			my $systemPSize = $this -&gt; getStorageSize ($deviceMap{1});
-			my $systemISize = main::isize ($system); $systemISize /= 1024;
-			chomp $systemPSize;
-			#print &quot;_______A $systemPSize : $systemISize\n&quot;;
-			if ($systemPSize &lt; $systemISize) {
-				$syszip += 10;
-				$sizeOK = 0;
-			}
-			if (! $sizeOK) {
-				#==========================================
-				# bad partition alignment try again
-				#------------------------------------------
-				sleep (1);
-				$this -&gt; deleteVolumeGroup();
-			} else {
-				#==========================================
-				# looks good go for it
-				#------------------------------------------
-				last;
-			}
-		} else {
-			#==========================================
-			# entire disk used
-			#------------------------------------------
-			last;
-		}
-		$kiwi -&gt; note (&quot;.&quot;);
-	}
-	$kiwi -&gt; done();
-	#==========================================
-	# Dump system image on stick
-	#------------------------------------------
-	if (! $haveTree) {
-		$kiwi -&gt; info (&quot;Dumping system image to stick&quot;);
-		$status = qxx ( &quot;umount $deviceMap{1} 2&gt;&amp;1&quot; );
-		$status = qxx ( &quot;umount $deviceMap{2} 2&gt;&amp;1&quot; );
-		$status = qxx (&quot;dd if=$system of=$deviceMap{1} bs=32k 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't dump system image to stick: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		$kiwi -&gt; done();
-		if ($haveSplit) {
-			$kiwi -&gt; info (&quot;Dumping split read/write part to stick&quot;);
-			$status = qxx (&quot;dd if=$splitfile of=$deviceMap{2} bs=32k 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				$kiwi -&gt; failed ();
-				$kiwi -&gt; error  (&quot;Couldn't dump split file: $status&quot;);
-				$kiwi -&gt; failed ();
-				$this -&gt; cleanTmp ();
-				return undef;
-			}
-			$kiwi -&gt; done();
-		} 
-	} else {
-		#==========================================
-		# Create fs on system image partition
-		#------------------------------------------
-		if (! $this -&gt; setupFilesystem ($FSTypeRO,$deviceMap{1},&quot;root&quot;)) {
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		#==========================================
-		# Mount system image partition
-		#------------------------------------------
-		if (! main::mount($deviceMap{1}, $loopdir)) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't mount partition: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		#==========================================
-		# Create LVM volumes filesystems
-		#------------------------------------------
-		if (($lvm) &amp;&amp; (%lvmparts)) {
-			my $VGroup = $this-&gt;{lvmgroup};
-			foreach my $name (keys %lvmparts) {
-				my $device = &quot;/dev/$VGroup/LV$name&quot;;
-				my $pname  = $name; $pname =~ s/_/\//g;
-				$status = qxx (&quot;mkdir -p $loopdir/$pname 2&gt;&amp;1&quot;);
-				$result = $? &gt;&gt; 8;
-				if ($result != 0) {
-					$kiwi -&gt; error (&quot;Can't create mount point $loopdir/$pname&quot;);
-					$this -&gt; cleanLoop ();
-					return undef;
-				}
-				if (! $this -&gt; setupFilesystem ($FSTypeRO,$device,$pname)) {
-					$this -&gt; cleanLoop ();
-					return undef;
-				}
-				if (! main::mount ($device, &quot;$loopdir/$pname&quot;)) {
-					$this -&gt; cleanLoop ();
-					return undef;
-				}
-			}
-		}
-		#==========================================
-		# Copy root tree to virtual disk
-		#------------------------------------------
-		$kiwi -&gt; info (&quot;Copying system image tree on stick&quot;);
-		$status = qxx (&quot;tar -cf - -C $system . | tar -x -C $loopdir 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Can't copy image tree on stick: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
-		#==========================================
-		# Umount system image partition
-		#------------------------------------------
-		main::umount();
-	}
-	#==========================================
-	# Check and resize filesystems
-	#------------------------------------------
-	$result = 0;
-	undef $status;
-	my $mapper = $deviceMap{1};
-	my %fsattr = main::checkFileSystem ($deviceMap{1});
-	if ($fsattr{type} eq &quot;luks&quot;) {
-		$mapper = $this -&gt; luksResize ($deviceMap{1},&quot;luks-resize&quot;);
-		if (! $mapper) {
-			$this -&gt; luksClose();
-			return undef;
-		}
-		%fsattr= main::checkFileSystem ($mapper);
-	}
-	SWITCH: for ($fsattr{type}) {
-		/^ext\d/    &amp;&amp; do {
-			$kiwi -&gt; info (&quot;Resizing system $fsattr{type} filesystem&quot;);
-			$status = qxx (&quot;/sbin/resize2fs -f -F -p $mapper 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			last SWITCH;
-		};
-		/^reiserfs/ &amp;&amp; do {
-			$kiwi -&gt; info (&quot;Resizing system $fsattr{type} filesystem&quot;);
-			$status = qxx (&quot;/sbin/resize_reiserfs $mapper 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			last SWITCH;
-		};
-		/^btrfs/    &amp;&amp; do {
-			$kiwi -&gt; info (&quot;Resizing system $fsattr{type} filesystem&quot;);
-			my $bctl = &quot;/sbin/btrfsctl -r max /mnt&quot;;
-			$status = qxx (&quot;
-				mount $mapper /mnt &amp;&amp; $bctl ; umount /mnt 2&gt;&amp;1&quot;
-			);
-			$result = $? &gt;&gt; 8;
-			last SWITCH;
-		}
-	};
-	if ($result != 0) {
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error  (&quot;Couldn't resize $fsattr{type} filesystem: $status&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; luksClose();
-		$this -&gt; cleanLoop ();
-		$this -&gt; cleanTmp ();
-		return undef;
-	}
-	$this -&gt; luksClose();
-	if ($status) {
-		$kiwi -&gt; done();
-	}
-	if ($haveSplit) {
-		$result = 0;
-		undef $status;
-		$mapper = $deviceMap{2};
-		my %fsattr = main::checkFileSystem ($deviceMap{2});
-		if ($fsattr{type} eq &quot;luks&quot;) {
-			$mapper = $this -&gt; luksResize ($deviceMap{2},&quot;luks-resize&quot;);
-			if (! $mapper) {
-				$this -&gt; luksClose();
-				return undef;
-			}
-			%fsattr= main::checkFileSystem ($mapper);
-		}
-		SWITCH: for ($fsattr{type}) {
-			/^ext\d/    &amp;&amp; do {
-				$kiwi -&gt; info (&quot;Resizing split $fsattr{type} filesystem&quot;);
-				$status = qxx (&quot;/sbin/resize2fs -f -F -p $mapper 2&gt;&amp;1&quot;);
-				$result = $? &gt;&gt; 8;
-				last SWITCH;
-			};
-			/^reiserfs/ &amp;&amp; do {
-				$kiwi -&gt; info (&quot;Resizing split $fsattr{type} filesystem&quot;);
-				$status = qxx (&quot;/sbin/resize_reiserfs $mapper 2&gt;&amp;1&quot;);
-				$result = $? &gt;&gt; 8;
-				last SWITCH;
-			};
-			/^btrfs/    &amp;&amp; do {
-				$kiwi -&gt; info (&quot;Resizing system $fsattr{type} filesystem&quot;);
-				my $bctl = &quot;/sbin/btrfsctl -r max /mnt&quot;;
-				$status = qxx (&quot;
-					mount $mapper /mnt &amp;&amp; $bctl; umount /mnt 2&gt;&amp;1&quot;
-				);
-				$result = $? &gt;&gt; 8;
-				last SWITCH;
-			}
-		};
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error(&quot;Couldn't resize $fsattr{type} filesystem: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; luksClose();
-			$this -&gt; cleanLoop ();
-			$this -&gt; cleanTmp ();
-			return undef;
-		}
-		$this -&gt; luksClose();
-		if ($status) {
-			$kiwi -&gt; done();
-		}
-	}
-	#==========================================
-	# create read/write filesystem if needed
-	#------------------------------------------
-	if (($syszip) &amp;&amp; (! $haveSplit) &amp;&amp; (! $dmapper)) {
-		$root = $deviceMap{2};
-		if ($haveluks) {
-			my $cipher = $type{luks};
-			my $name   = &quot;luksReadWrite&quot;;
-			$kiwi -&gt; info (&quot;Creating LUKS-&gt;ext3 read-write filesystem&quot;);
-			$status = qxx (&quot;echo $cipher|cryptsetup -q luksFormat $root 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			if ($status != 0) {
-				$kiwi -&gt; failed ();
-				$kiwi -&gt; error  (&quot;Couldn't setup luks format: $root&quot;);
-				$kiwi -&gt; failed ();
-				$this -&gt; cleanLoop ();
-				return undef;
-			}
-			$status = qxx (&quot;echo $cipher|cryptsetup luksOpen $root $name 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				$kiwi -&gt; failed ();
-				$kiwi -&gt; error  (&quot;Couldn't open luks device: $status&quot;);
-				$kiwi -&gt; failed ();
-				$this -&gt; cleanLoop ();
-				return undef;
-			}
-			$root = &quot;/dev/mapper/$name&quot;;
-			$this-&gt;{luks} = $name;
-		} else {
-			$kiwi -&gt; info (&quot;Creating ext3 read-write filesystem&quot;);
-		}
-		my %FSopts = main::checkFSOptions();
-		my $fsopts = $FSopts{ext3};
-		my $fstool = &quot;mkfs.ext3&quot;;
-		$status = qxx (&quot;$fstool $fsopts $root 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't create filesystem: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; luksClose();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$this -&gt; luksClose();
-		$kiwi -&gt; done();
-	} elsif ($dmapper) {
-		# /.../
-		# for USB sticks we need to make sure the write partition
-		# has been cleaned before re-use with filesystem like clicfs
-		# and friends
-		# ----
-		$root = $deviceMap{2};
-		$kiwi -&gt; info (&quot;Clean sweep read-write filesystem&quot;);
-		$status = qxx (&quot;dd if=/dev/zero of=$root bs=32k count=32 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't cleanup partition $root: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
-	}
-	#==========================================
-	# create bootloader filesystem if needed
-	#------------------------------------------
-	if ($bootloader eq &quot;syslinux&quot;) {
-		$root = $deviceMap{fat};
-		$kiwi -&gt; info (&quot;Creating DOS boot filesystem&quot;);
-		$status = qxx (&quot;/sbin/mkdosfs $root 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't create DOS filesystem: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
-	} elsif (
-		($dmapper) || ($haveluks) || ($needBootP) || ($lvm) || ($bootloader eq &quot;extlinux&quot;)
-	) {
-		$root = $deviceMap{dmapper};
-		$kiwi -&gt; info (&quot;Creating ext2 boot filesystem&quot;);
-		if (($haveluks) || ($needBootP)) {
-			if (($syszip) || ($haveSplit) || ($dmapper)) {
-				$root = $deviceMap{3};
-			} else {
-				$root = $deviceMap{2};
-			}
-		}
-		if ($lvm) {
-			$root = $deviceMap{0};
-		}
-		if ($bootloader eq &quot;extlinux&quot;) {
-			$root = $deviceMap{extlinux};
-		}
-		my %FSopts = main::checkFSOptions();
-		my $fsopts = $FSopts{ext2};
-		my $fstool = &quot;mkfs.ext2&quot;;
-		$status = qxx (&quot;$fstool $fsopts $root 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't create filesystem: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
-	}
-	#==========================================
-	# Dump boot image on virtual disk
-	#------------------------------------------
-	$kiwi -&gt; info (&quot;Copying boot data to stick&quot;);
-	#==========================================
-	# Mount system image / or rw partition
-	#------------------------------------------
-	if ($bootloader eq &quot;syslinux&quot;) {
-		$root = $deviceMap{fat};
-	} elsif ($bootloader eq &quot;extlinux&quot;) {
-		$root = $deviceMap{extlinux};
-	} elsif ($dmapper) {
-		$root = $deviceMap{dmapper};
-	} elsif (($syszip) || ($haveSplit) || ($lvm)) {
-		$root = $deviceMap{2};
-		if ($haveluks) {
-			$root = $deviceMap{3};
-		}
-		if ($lvm) {
-			$root = $deviceMap{0};
-		}
-	} elsif (($haveluks) || ($needBootP)) {
-		$root = $deviceMap{2};
-	} else {
-		$root = $deviceMap{1};
-	}
-	if (! main::mount($root, $loopdir)) {
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error  (&quot;Couldn't mount stick image: $status&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanLoop ();
-		return undef;
-	}
-	#==========================================
-	# Copy boot data on system image
-	#------------------------------------------
-	$status = qxx (&quot;rm -rf $loopdir/boot&quot;);
-	$status = qxx (&quot;cp -dR $tmpdir/boot $loopdir 2&gt;&amp;1&quot;);
-	$result = $? &gt;&gt; 8;
-	if ($result != 0) {
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error  (&quot;Couldn't copy boot data to stick: $status&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanLoop ();
-		return undef;
-	}
-	main::umount();
-	$kiwi -&gt; done();
-	#==========================================
-	# deactivate volume group
-	#------------------------------------------
-	if ($lvm) {
-		qxx (&quot;vgchange -an $this-&gt;{lvmgroup} 2&gt;&amp;1&quot;);
-	}
+	my $this   = shift;
 	#==========================================
-	# Install boot loader on USB stick
+	# search for USB stick device(s)
 	#------------------------------------------
-	if (! $this -&gt; installBootLoader ($bootloader, $stick, \%deviceMap)) {
-		$this -&gt; cleanLoop ();
+	my $stick = $this -&gt; searchUSBStickDevice ();
+	if (! $stick) {
 		return undef;
 	}
 	#==========================================
-	# cleanup temp directory
+	# run boot disk process on stick device
 	#------------------------------------------
-	qxx (&quot;rm -rf $tmpdir&quot;);
-	return $this;
+	return $this -&gt; setupBootDisk ($stick);
 }
 
 #==========================================
@@ -1464,11 +554,13 @@ sub setupBootStick {
 sub setupInstallCD {
 	my $this      = shift;
 	my $kiwi      = $this-&gt;{kiwi};
+	my $arch      = $this-&gt;{arch};
 	my $initrd    = $this-&gt;{initrd};
 	my $system    = $this-&gt;{system};
 	my $oldird    = $this-&gt;{initrd};
 	my $zipped    = $this-&gt;{zipped};
 	my $isxen     = $this-&gt;{isxen};
+	my $lvm       = $this-&gt;{lvm};
 	my $xml       = $this-&gt;{xml};
 	my $pinst     = $xml-&gt;getOEMPartitionInstall();
 	my $md5name   = $system;
@@ -1481,6 +573,21 @@ sub setupInstallCD {
 	my $ibasename;
 	my $tmpdir;
 	my %type;
+	my $haveDiskDevice;
+	my $destdir;
+	my $version;
+	#==========================================
+	# Check for disk device
+	#------------------------------------------
+	if (-b $system) {
+		$haveDiskDevice = $system;
+		$destdir = dirname ($initrd);
+		$version = $xml -&gt; getImageVersion();
+		$system  = $xml -&gt; getImageName();
+		$system  = $destdir.&quot;/&quot;.$system.&quot;.&quot;.$arch.&quot;-&quot;.$version.&quot;.raw&quot;;
+		$md5name = $system;
+		$this-&gt;{system} = $system;
+	}
 	#==========================================
 	# read config XML attributes
 	#------------------------------------------
@@ -1511,13 +618,13 @@ sub setupInstallCD {
 		return undef;
 	}
 	$this-&gt;{tmpdir} = $tmpdir;
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	#==========================================
 	# check if initrd is zipped
 	#------------------------------------------
 	if (! $zipped) {
 		$kiwi -&gt; error  (&quot;Compressed boot image required&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	#==========================================
@@ -1535,52 +642,47 @@ sub setupInstallCD {
 		# build label from xml data
 		#------------------------------------------
 		$this-&gt;{bootlabel} = $xml -&gt; getImageDisplayName();
+		if (! $haveDiskDevice) {
+			#==========================================
+			# bind $system to loop device
+			#------------------------------------------
+			$kiwi -&gt; info (&quot;Binding disk to loop device&quot;);
+			if (! $this -&gt; bindDiskDevice($system)) {
+				$kiwi -&gt; failed ();
+				return undef;
+			}
+			$kiwi -&gt; done();
+			#==========================================
+			# setup device mapper
+			#------------------------------------------
+			$kiwi -&gt; info (&quot;Setup device mapper for partition access&quot;);
+			if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
+				$kiwi -&gt; failed ();
+				$this -&gt; cleanLoop ();
+				return undef;
+			}
+			$kiwi -&gt; done();
+		} else {
+			$kiwi -&gt; info (&quot;Using disk device: $haveDiskDevice&quot;);
+			$this-&gt;{loop}     = $haveDiskDevice;
+			$this-&gt;{bindloop} = $haveDiskDevice;
+			qxx (&quot;vgchange -a y 2&gt;&amp;1&quot;);
+			$kiwi -&gt; done();
+		}
 		#==========================================
-		# bind $system to loop device
+		# find partition to check
 		#------------------------------------------
-		$kiwi -&gt; info (&quot;Binding virtual disk to loop device&quot;);
-		if (! $this -&gt; bindLoopDevice($system)) {
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
+		my $sdev = $this-&gt;{bindloop}.&quot;1&quot;;
+		if (! -e $sdev) {
+			$sdev = $this-&gt;{bindloop}.&quot;2&quot;;
 		}
-		$kiwi -&gt; done();
 		#==========================================
-		# setup device mapper
+		# check for activated volume group
 		#------------------------------------------
-		$kiwi -&gt; info (&quot;Setup device mapper for virtual partition access&quot;);
-		$status = qxx ( &quot;/sbin/kpartx -a $this-&gt;{loop} 2&gt;&amp;1&quot; );
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Failed mapping virtual partition: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
+		$sdev = $this -&gt; checkLVMbind ($sdev);
 		#==========================================
-		# find partition to check
+		# perform mount call
 		#------------------------------------------
-		my $dmap = $this-&gt;{loop}; $dmap =~ s/dev\///;
-		my $sdev = &quot;/dev/mapper&quot;.$dmap.&quot;p1&quot;;
-		if (! -e $sdev) {
-			$sdev = &quot;/dev/mapper&quot;.$dmap.&quot;p2&quot;;
-		}
-		for (my $try=0;$try&lt;=3;$try++) {
-			if (defined (my $lvroot = glob (&quot;/dev/mapper/*-LVRoot&quot;))) {
-				$this-&gt;{lvm} = 1;
-				$sdev = $lvroot;
-				if (defined ($lvroot = glob (&quot;/dev/mapper/*-LVComp&quot;))) {
-					$sdev = $lvroot;
-				}
-				if ($lvroot =~ /mapper\/(.*)-.*/) {
-					$this-&gt;{lvmgroup} = $1;
-				}
-				last;
-			}
-			sleep 1;
-		}
 		if (! main::mount ($sdev, $tmpdir)) {
 			$kiwi -&gt; error (&quot;Failed to mount system partition: $status&quot;);
 			$kiwi -&gt; failed ();
@@ -1591,30 +693,49 @@ sub setupInstallCD {
 			$imgtype = &quot;split&quot;;
 			$this-&gt;{imgtype} = $imgtype;
 		}
-		$this -&gt; cleanLoop(&quot;keep-mountpoints&quot;);
+		$this -&gt; cleanLoop();
 	}
 	$this-&gt;{imgtype} = $imgtype;
 	#==========================================
 	# Build md5sum of system image
 	#------------------------------------------
-	$this -&gt; buildMD5Sum ($system);
+	if (! $haveDiskDevice) {
+		$this -&gt; buildMD5Sum ($system);
+	} else {
+		$this -&gt; buildMD5Sum ($this-&gt;{loop},$system);
+	}
 	#==========================================
 	# Compress system image
 	#------------------------------------------
 	$md5name =~ s/\.raw$/\.md5/;
 	if (! $pinst) {
 		$kiwi -&gt; info (&quot;Compressing installation image...&quot;);
-		$status = qxx (&quot;$main::Gzip -f $system 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
+		if (! $haveDiskDevice) {
+			$status = qxx (&quot;$main::Gzip -f $system 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+		} else {
+			$status = qxx (&quot;cat $haveDiskDevice|$main::Gzip -f &gt; $system.gz&quot;);
+			$result = $? &gt;&gt; 8;
+		}
 		if ($result != 0) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Failed to compress system image: $status&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		$kiwi -&gt; done();
 		$system = $system.&quot;.gz&quot;;
+	} elsif ($haveDiskDevice) {
+		$kiwi -&gt; info (&quot;Loading system image image file...&quot;);
+		$status = qxx (&quot;cat $haveDiskDevice &gt; $system&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; failed ();
+			$kiwi -&gt; error  (&quot;Failed to load system image: $status&quot;);
+			$kiwi -&gt; failed ();
+			return undef;
+		}
+		$kiwi -&gt; done();
 	}
 	#==========================================
 	# Setup image basename
@@ -1628,8 +749,7 @@ sub setupInstallCD {
 		if ($namecd !~ /(.*)-(\d+\.\d+\.\d+)$suffix$/) {
 			$kiwi -&gt; error  (&quot;Couldn't extract version information&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -1645,8 +765,7 @@ sub setupInstallCD {
 	#------------------------------------------
 	$initrd = $this -&gt; setupInstallFlags();
 	if (! defined $initrd) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -1657,8 +776,7 @@ sub setupInstallCD {
 	$this-&gt;{initrd} = $initrd;
 	if (! $this -&gt; createBootStructure()) {
 		$this-&gt;{initrd} = $oldird;
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -1667,8 +785,7 @@ sub setupInstallCD {
 	# Import boot loader stages
 	#------------------------------------------
 	if (! $this -&gt; setupBootLoaderStages ($bootloader,&quot;iso&quot;)) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -1684,8 +801,7 @@ sub setupInstallCD {
 		$title = &quot;KIWI CD Boot: $namecd&quot;;
 	}
 	if (! $this -&gt; setupBootLoaderConfiguration ($bootloader,$title)) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -1697,8 +813,7 @@ sub setupInstallCD {
 		if (! open (FD,&quot;&gt;$tmpdir/config.isoclient&quot;)) {
 			$kiwi -&gt; error  (&quot;Couldn't create CD install flag file&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -1712,8 +827,7 @@ sub setupInstallCD {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Failed importing system image: $status&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -1724,13 +838,12 @@ sub setupInstallCD {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Failed importing system md5 sum: $status&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
 		}
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 			$system =~ s/\.gz$//;
 		}
@@ -1770,7 +883,6 @@ sub setupInstallCD {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Bootloader not supported for CD inst: $bootloader&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	my $wdir = qxx (&quot;pwd&quot;); chomp $wdir;
@@ -1781,7 +893,6 @@ sub setupInstallCD {
 		$kiwi,$tmpdir,$name,undef,&quot;checkmedia&quot;
 	);
 	if (! defined $iso) {
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	my $tool= $iso -&gt; getTool();
@@ -1794,7 +905,6 @@ sub setupInstallCD {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Failed creating ISO image: $status&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		$iso  -&gt; cleanISO ();
 		return undef;
 	}
@@ -1809,7 +919,6 @@ sub setupInstallCD {
 	qxx (&quot;rm -rf $tmpdir&quot;);
 	$kiwi -&gt; info (&quot;Created $name to be burned on CD&quot;);
 	$kiwi -&gt; done ();
-	$this -&gt; cleanTmp ();
 	$iso  -&gt; cleanISO ();
 	return $this;
 }
@@ -1820,10 +929,12 @@ sub setupInstallCD {
 sub setupInstallStick {
 	my $this      = shift;
 	my $kiwi      = $this-&gt;{kiwi};
+	my $arch      = $this-&gt;{arch};
 	my $initrd    = $this-&gt;{initrd};
 	my $system    = $this-&gt;{system};
 	my $oldird    = $this-&gt;{initrd};
 	my $vmsize    = $this-&gt;{vmsize};
+	my $device    = $this-&gt;{device};
 	my $loopdir   = $this-&gt;{loopdir};
 	my $zipped    = $this-&gt;{zipped};
 	my $isxen     = $this-&gt;{isxen};
@@ -1837,11 +948,28 @@ sub setupInstallStick {
 	my $imgtype   = &quot;oem&quot;;
 	my $gotsys    = 1;
 	my $bootloader= &quot;grub&quot;;
+	my $haveDiskDevice;
 	my $status;
 	my $result;
+	my $destdir;
+	my $version;
 	my $ibasename;
 	my $tmpdir;
 	my %type;
+	my $stick;
+	#==========================================
+	# Check for disk device
+	#------------------------------------------
+	if (-b $system) {
+		$haveDiskDevice = $system;
+		$destdir = dirname ($initrd);
+		$version = $xml -&gt; getImageVersion();
+		$system  = $xml -&gt; getImageName();
+		$system  = $destdir.&quot;/&quot;.$system.&quot;.&quot;.$arch.&quot;-&quot;.$version.&quot;.raw&quot;;
+		$diskname= $system.&quot;.install.raw&quot;;
+		$md5name = $system;
+		$this-&gt;{system} = $system;
+	}
 	#==========================================
 	# read config XML attributes
 	#------------------------------------------
@@ -1865,13 +993,13 @@ sub setupInstallStick {
 		return undef;
 	}
 	$this-&gt;{tmpdir} = $tmpdir;
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	#==========================================
 	# check if initrd is zipped
 	#------------------------------------------
 	if (! $zipped) {
 		$kiwi -&gt; error  (&quot;Compressed boot image required&quot;);
 		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	#==========================================
@@ -1891,52 +1019,47 @@ sub setupInstallStick {
 		# build label from xml data
 		#------------------------------------------
 		$this-&gt;{bootlabel} = $xml -&gt; getImageDisplayName();
+		if (! $haveDiskDevice) {
+			#==========================================
+			# bind $system to loop device
+			#------------------------------------------
+			$kiwi -&gt; info (&quot;Binding disk to loop device&quot;);
+			if (! $this -&gt; bindDiskDevice ($system)) {
+				$kiwi -&gt; failed ();
+				return undef;
+			}
+			$kiwi -&gt; done();
+			#==========================================
+			# setup device mapper
+			#------------------------------------------
+			$kiwi -&gt; info (&quot;Setup device mapper for partition access&quot;);
+			if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
+				$kiwi -&gt; failed ();
+				$this -&gt; cleanLoop ();
+				return undef;
+			}
+			$kiwi -&gt; done();
+		} else {
+			$kiwi -&gt; info (&quot;Using disk device: $haveDiskDevice&quot;);
+			$this-&gt;{loop}     = $haveDiskDevice;
+			$this-&gt;{bindloop} = $haveDiskDevice;
+			qxx (&quot;vgchange -a y 2&gt;&amp;1&quot;);
+			$kiwi -&gt; done();
+		}
 		#==========================================
-		# bind $system to loop device
+		# find partition to check
 		#------------------------------------------
-		$kiwi -&gt; info (&quot;Binding virtual disk to loop device&quot;);
-		if (! $this -&gt; bindLoopDevice ($system)) {
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
+		my $sdev = $this-&gt;{bindloop}.&quot;1&quot;;
+		if (! -e $sdev) {
+			$sdev = $this-&gt;{bindloop}.&quot;2&quot;;
 		}
-		$kiwi -&gt; done();
 		#==========================================
-		# setup device mapper
+		# check for activated volume group
 		#------------------------------------------
-		$kiwi -&gt; info (&quot;Setup device mapper for virtual partition access&quot;);
-		$status = qxx ( &quot;/sbin/kpartx -a $this-&gt;{loop} 2&gt;&amp;1&quot; );
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Failed mapping virtual partition: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
-		}
-		$kiwi -&gt; done();
+		$sdev = $this -&gt; checkLVMbind ($sdev);
 		#==========================================
-		# find partition to check
+		# perform mount call
 		#------------------------------------------
-		my $dmap = $this-&gt;{loop}; $dmap =~ s/dev\///;
-		my $sdev = &quot;/dev/mapper&quot;.$dmap.&quot;p1&quot;;
-		if (! -e $sdev) {
-			$sdev = &quot;/dev/mapper&quot;.$dmap.&quot;p2&quot;;
-		}
-		for (my $try=0;$try&lt;=3;$try++) {
-			if (defined (my $lvroot = glob (&quot;/dev/mapper/*-LVRoot&quot;))) {
-				$this-&gt;{lvm} = 1;
-				$sdev = $lvroot;
-				if (defined ($lvroot = glob (&quot;/dev/mapper/*-LVComp&quot;))) {
-					$sdev = $lvroot;
-				}
-				if ($lvroot =~ /mapper\/(.*)-.*/) {
-					$this-&gt;{lvmgroup} = $1;
-				}
-				last;
-			}
-			sleep 1;
-		}
 		if (! main::mount ($sdev, $tmpdir)) {
 			$kiwi -&gt; error  (&quot;Failed to mount system partition: $status&quot;);
 			$kiwi -&gt; failed ();
@@ -1947,31 +1070,50 @@ sub setupInstallStick {
 			$imgtype = &quot;split&quot;;
 			$this-&gt;{imgtype} = $imgtype;
 		}
-		$this -&gt; cleanLoop(&quot;keep-mountpoints&quot;);
+		$this -&gt; cleanLoop();
 	}
 	$this-&gt;{imgtype} = $imgtype;
 	$this-&gt;{bootpart}= 0;
 	#==========================================
 	# Build md5sum of system image
 	#------------------------------------------
-	$this -&gt; buildMD5Sum ($system);
+	if (! $haveDiskDevice) {
+		$this -&gt; buildMD5Sum ($system);
+	} else {
+		$this -&gt; buildMD5Sum ($this-&gt;{loop},$system);
+	}
 	#==========================================
 	# Compress system image
 	#------------------------------------------
 	$md5name=~ s/\.raw$/\.md5/;
 	if (! $pinst) {
 		$kiwi -&gt; info (&quot;Compressing installation image...&quot;);
-		$status = qxx (&quot;$main::Gzip -f $system 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
+		if (! $haveDiskDevice) {
+			$status = qxx (&quot;$main::Gzip -f $system 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+		} else {
+			$status = qxx (&quot;cat $haveDiskDevice|$main::Gzip -f &gt; $system.gz&quot;);
+			$result = $? &gt;&gt; 8;
+		}
 		if ($result != 0) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Failed to compress system image: $status&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		$kiwi -&gt; done();
 		$system = $system.&quot;.gz&quot;;
+	} elsif ($haveDiskDevice) {
+		$kiwi -&gt; info (&quot;Loading system image image file...&quot;);
+		$status = qxx (&quot;cat $haveDiskDevice &gt; $system&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; failed ();
+			$kiwi -&gt; error  (&quot;Failed to load system image: $status&quot;);
+			$kiwi -&gt; failed ();
+			return undef;
+		}
+		$kiwi -&gt; done();
 	}
 	#==========================================
 	# setup required disk size
@@ -1994,8 +1136,9 @@ sub setupInstallStick {
 		if ($nameusb !~ /(.*)-(\d+\.\d+\.\d+)$suffix$/) {
 			$kiwi -&gt; error  (&quot;Couldn't extract version information&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			qxx ( &quot;$main::Gzip -d $system&quot; );
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
+				qxx ( &quot;$main::Gzip -d $system&quot; );
+			}
 			return undef;
 		}
 		if (! $pinst) {
@@ -2009,20 +1152,18 @@ sub setupInstallStick {
 	#------------------------------------------
 	$initrd = $this -&gt; setupInstallFlags();
 	if (! defined $initrd) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
 	}
 	$this-&gt;{initrd} = $initrd;
 	#==========================================
-	# Create Virtual Disk boot structure
+	# Create Disk boot structure
 	#------------------------------------------
 	if (! $this -&gt; createBootStructure(&quot;vmx&quot;)) {
 		$this-&gt;{initrd} = $oldird;
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -2031,8 +1172,7 @@ sub setupInstallStick {
 	# Import boot loader stages
 	#------------------------------------------
 	if (! $this -&gt; setupBootLoaderStages ($bootloader)) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -2045,44 +1185,55 @@ sub setupInstallStick {
 		$title = &quot;KIWI USB Boot: $nameusb&quot;;
 	}
 	if (! $this -&gt; setupBootLoaderConfiguration ($bootloader,$title)) {
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
 	}
 	$this-&gt;{initrd} = $oldird;
 	#==========================================
-	# create virtual disk
+	# create/use disk
 	#------------------------------------------
-	$kiwi -&gt; info (&quot;Creating virtual disk...&quot;);
-	$status = qxx (&quot;qemu-img create $diskname $vmsize 2&gt;&amp;1&quot;);
-	$result = $? &gt;&gt; 8;
-	if ($result != 0) {
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error  (&quot;Failed creating virtual disk: $status&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
-			qxx ( &quot;$main::Gzip -d $system&quot; );
+	if (! $haveDiskDevice) {
+		#==========================================
+		# Create virtual disk to be dumped on stick
+		#------------------------------------------
+		$kiwi -&gt; info (&quot;Creating virtual disk...&quot;);
+		$status = qxx (&quot;qemu-img create $diskname $vmsize 2&gt;&amp;1&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; failed ();
+			$kiwi -&gt; error  (&quot;Failed creating virtual disk: $status&quot;);
+			$kiwi -&gt; failed ();
+			if (! $pinst) {
+				qxx ( &quot;$main::Gzip -d $system&quot; );
+			}
+			return undef;
 		}
-		return undef;
-	}
-	$kiwi -&gt; done();
-	$kiwi -&gt; info (&quot;Binding virtual disk to loop device&quot;);
-	if (! $this -&gt; bindLoopDevice ($diskname)) {
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanTmp ();
-		if (! $pinst) {
-			qxx ( &quot;$main::Gzip -d $system&quot; );
+		$kiwi -&gt; done();
+		$kiwi -&gt; info (&quot;Binding virtual disk to loop device&quot;);
+		if (! $this -&gt; bindDiskDevice ($diskname)) {
+			$kiwi -&gt; failed ();
+			if (! $pinst) {
+				qxx ( &quot;$main::Gzip -d $system&quot; );
+			}
+			return undef;
 		}
-		return undef;
+		$kiwi -&gt; done();
+	} else {
+		#==========================================
+		# Find USB stick devices
+		#------------------------------------------
+		my $stick = $this -&gt; searchUSBStickDevice ();
+		if (! $stick) {
+			return undef;
+		}
+		$this-&gt;{loop} = $stick;
 	}
-	$kiwi -&gt; done();
 	#==========================================
-	# create virtual disk partitions
+	# create disk partitions
 	#------------------------------------------
-	$kiwi -&gt; info (&quot;Create partition table for virtual disk&quot;);
+	$kiwi -&gt; info (&quot;Create partition table for disk&quot;);
 	if ($gotsys) {
 		@commands = (
 			&quot;n&quot;,&quot;p&quot;,&quot;1&quot;,&quot;.&quot;,&quot;+&quot;.$irdsize.&quot;M&quot;,
@@ -2100,46 +1251,76 @@ sub setupInstallStick {
 		$kiwi -&gt; error  (&quot;Couldn't create partition table&quot;);
 		$kiwi -&gt; failed ();
 		$this -&gt; cleanLoop();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
 	}
 	$kiwi -&gt; done();
-	#==========================================
-	# Create loop device mapping table
-	#------------------------------------------
-	%deviceMap = $this -&gt; setLoopDeviceMap ($this-&gt;{loop});
+	if (! $haveDiskDevice ) {
+		#==========================================
+		# setup device mapper
+		#------------------------------------------
+		$kiwi -&gt; info (&quot;Setup device mapper for partition access&quot;);
+		if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
+			$kiwi -&gt; failed ();
+			$this -&gt; cleanLoop ();
+			if (! $pinst) {
+				qxx ( &quot;$main::Gzip -d $system&quot; );
+			}
+			return undef;
+		}
+		$kiwi -&gt; done();
+		#==========================================
+		# Create loop device mapping table
+		#------------------------------------------
+		%deviceMap = $this -&gt; setLoopDeviceMap ($this-&gt;{loop});
+		$kiwi -&gt; done();
+	} else {
+		#==========================================
+		# Create disk device mapping table
+		#------------------------------------------
+		%deviceMap = $this -&gt; setDefaultDeviceMap ($this-&gt;{loop});
+		#==========================================
+		# Umount possible mounted stick partitions
+		#------------------------------------------
+		$this -&gt; umountDevice ($this-&gt;{loop});
+		for (my $try=0;$try&gt;=2;$try++) {
+			$status = qxx (&quot;/sbin/blockdev --rereadpt $this-&gt;{loop} 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+			if ($result != 0) {
+				sleep (1); next;
+			}
+			last;
+		}
+		if ($result != 0) {
+			$kiwi -&gt; failed ();
+			$kiwi -&gt; error  (&quot;Couldn't reread partition table: $status&quot;);
+			$kiwi -&gt; failed ();
+			return undef;
+		}
+		#==========================================
+		# Wait for new partition table to settle
+		#------------------------------------------
+		sleep (1);
+		#==========================================
+		# Umount possible mounted stick partitions
+		#------------------------------------------
+		$this -&gt; umountDevice ($this-&gt;{loop});
+	}
 	if ($bootloader eq &quot;extlinux&quot;) {
 		$deviceMap{extlinux} = $deviceMap{1};
 	}
 	if ($bootloader eq &quot;syslinux&quot;) {
 		$deviceMap{fat} = $deviceMap{1};
 	}
-	#==========================================
-	# setup device mapper
-	#------------------------------------------
-	$kiwi -&gt; info (&quot;Setup device mapper for virtual partition access&quot;);
-	$status = qxx ( &quot;/sbin/kpartx -a $this-&gt;{loop} 2&gt;&amp;1&quot; );
-	$result = $? &gt;&gt; 8;
-	if ($result != 0) {
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error  (&quot;Failed mapping virtual partition: $status&quot;);
-		$kiwi -&gt; failed ();
-		$this -&gt; cleanLoop ();
-		if (! $pinst) {
-			qxx ( &quot;$main::Gzip -d $system&quot; );
-		}
-		return undef;
-	}
 	my $boot = $deviceMap{1};
 	my $data;
 	if ($gotsys) {
 		$data = $deviceMap{2};
 	}
-	$kiwi -&gt; done();
 	#==========================================
-	# Create filesystem on virtual partitions
+	# Create filesystem on partitions
 	#------------------------------------------
 	foreach my $root ($boot,$data) {
 		next if ! defined $root;
@@ -2157,7 +1338,7 @@ sub setupInstallStick {
 			$kiwi -&gt; error  (&quot;Failed creating filesystem: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -2167,13 +1348,13 @@ sub setupInstallStick {
 	#==========================================
 	# Copy boot data on first partition
 	#------------------------------------------
-	$kiwi -&gt; info (&quot;Installing boot data to virtual disk&quot;);
+	$kiwi -&gt; info (&quot;Installing boot data to disk&quot;);
 	if (! main::mount ($boot, $loopdir)) {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Couldn't mount boot partition: $status&quot;);
 		$kiwi -&gt; failed ();
 		$this -&gt; cleanLoop ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -2185,7 +1366,7 @@ sub setupInstallStick {
 		$kiwi -&gt; error  (&quot;Couldn't install boot data: $status&quot;);
 		$kiwi -&gt; failed ();
 		$this -&gt; cleanLoop ();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		return undef;
@@ -2196,13 +1377,13 @@ sub setupInstallStick {
 	# Copy system image if defined
 	#------------------------------------------
 	if ($gotsys) {
-		$kiwi -&gt; info (&quot;Installing image data to virtual disk&quot;);
+		$kiwi -&gt; info (&quot;Installing image data to disk&quot;);
 		if (! main::mount($data, $loopdir)) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Couldn't mount data partition: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -2214,7 +1395,7 @@ sub setupInstallStick {
 			$kiwi -&gt; error  (&quot;Failed importing system image: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -2226,7 +1407,7 @@ sub setupInstallStick {
 			$kiwi -&gt; error  (&quot;Failed importing system md5 sum: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -2236,7 +1417,7 @@ sub setupInstallStick {
 			$kiwi -&gt; error  (&quot;Couldn't create USB install flag file&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
-			if (! $pinst) {
+			if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 				qxx ( &quot;$main::Gzip -d $system&quot; );
 			}
 			return undef;
@@ -2244,22 +1425,30 @@ sub setupInstallStick {
 		print FD &quot;IMAGE=$ibasename\n&quot;;
 		close FD;
 		main::umount();
-		if (! $pinst) {
+		if ((! $pinst) &amp;&amp; (! $haveDiskDevice)) {
 			qxx ( &quot;$main::Gzip -d $system&quot; );
 		}
 		$kiwi -&gt; done();
 	}
 	#==========================================
-	# Install boot loader on virtual disk
+	# Install boot loader on disk
 	#------------------------------------------
-	if (! $this -&gt; installBootLoader ($bootloader, $diskname, \%deviceMap)) {
+	my $bootdevice = $diskname;
+	if ($haveDiskDevice) {
+		$bootdevice = $this-&gt;{loop};
+	}
+	if (! $this -&gt; installBootLoader ($bootloader, $bootdevice, \%deviceMap)) {
 		$this -&gt; cleanLoopMaps();
 		$this -&gt; cleanLoop ();
 		return undef;
 	}
 	$this -&gt; cleanLoopMaps();
 	$this -&gt; cleanLoop();
-	$kiwi -&gt; info (&quot;Created $diskname to be dd'ed on Stick&quot;);
+	if (! $haveDiskDevice) {
+		$kiwi -&gt; info (&quot;Created $diskname to be dd'ed on Stick&quot;);
+	} else {
+		$kiwi -&gt; info (&quot;Successfully created install stick on $this-&gt;{loop}&quot;);
+	}
 	$kiwi -&gt; done ();
 	return $this;
 }
@@ -2269,6 +1458,7 @@ sub setupInstallStick {
 #------------------------------------------
 sub setupBootDisk {
 	my $this      = shift;
+	my $device    = shift;
 	my $kiwi      = $this-&gt;{kiwi};
 	my $arch      = $this-&gt;{arch};
 	my $system    = $this-&gt;{system};
@@ -2297,6 +1487,7 @@ sub setupBootDisk {
 	my $haveluks  = 0;
 	my $needBootP = 0;
 	my $bootloader= &quot;grub&quot;;
+	my $haveDiskDevice;
 	my $splitfile;
 	my $version;
 	my $label;
@@ -2310,6 +1501,12 @@ sub setupBootDisk {
 	my $xml;
 	my %lvmparts;
 	#==========================================
+	# check if we got a real device
+	#------------------------------------------
+	if ($device) {
+		$haveDiskDevice = $device;
+	}
+	#==========================================
 	# check if image type is oem
 	#------------------------------------------
 	if ($initrd =~ /oemboot/) {
@@ -2329,7 +1526,6 @@ sub setupBootDisk {
 		}
 		$xml = new KIWIXML ( $kiwi,$system.&quot;/image&quot;,undef,$imgtype,$profile );
 		if (! defined $xml) {
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		$haveTree = 1;
@@ -2338,7 +1534,6 @@ sub setupBootDisk {
 		# build disk name and label from xml data
 		#------------------------------------------
 		if (! main::mount ($system,$tmpdir)) {
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		#==========================================
@@ -2350,7 +1545,6 @@ sub setupBootDisk {
 		$xml = new KIWIXML ( $kiwi,$tmpdir.&quot;/image&quot;,undef,$imgtype,$profile );
 		main::umount();
 		if (! defined $xml) {
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 	}
@@ -2385,7 +1579,6 @@ sub setupBootDisk {
 					&quot;LVM volumes setup requires root tree but got image file&quot;
 				);
 				$kiwi -&gt; failed ();
-				$this -&gt; cleanTmp ();
 				return undef;
 			}
 			foreach my $vol (keys %lvmparts) {
@@ -2396,7 +1589,6 @@ sub setupBootDisk {
 				if (! -d &quot;$system/$pname&quot;) {
 					$kiwi -&gt; error (&quot;LVM: No such directory $system/$pname&quot;);
 					$kiwi -&gt; failed ();
-					$this -&gt; cleanTmp ();
 					return undef;
                 }
 				#==========================================
@@ -2558,15 +1750,13 @@ sub setupBootDisk {
 		if ($fsattr{readonly}) {
 			$kiwi -&gt; error (&quot;Can't copy data into requested RO filesystem&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 	}
 	#==========================================
-	# Create Virtual Disk boot structure
+	# Create Disk boot structure
 	#------------------------------------------
 	if (! $this -&gt; createBootStructure(&quot;vmx&quot;)) {
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	#==========================================
@@ -2589,12 +1779,11 @@ sub setupBootDisk {
 	# Import boot loader stages
 	#------------------------------------------
 	if (! $this -&gt; setupBootLoaderStages ($bootloader)) {
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	#==========================================
 	# add extra Xen boot options if necessary
-	#==========================================
+	#------------------------------------------
 	my $extra = &quot;&quot;;
 	if (($type{bootprofile} eq &quot;xen&quot;) &amp;&amp; ($xendomain eq &quot;domU&quot;)) {
 		$extra = &quot;xencons=tty &quot;;
@@ -2603,41 +1792,47 @@ sub setupBootDisk {
 	# Create boot loader configuration
 	#------------------------------------------
 	if (! $this -&gt; setupBootLoaderConfiguration ($bootloader,$bootfix,$extra)) {
-		$this -&gt; cleanTmp ();
 		return undef;
 	}
 	#==========================================
-	# create virtual disk
+	# create/use disk
 	#------------------------------------------
-	$kiwi -&gt; info (&quot;Creating virtual disk...&quot;);
 	my $dmap; # device map
 	my $root; # root device
 	while (1) {
 		if (! defined $system) {
-			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;No system image given&quot;);
 			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
-			return undef;
-		}	
-		$status = qxx (&quot;qemu-img create $diskname $vmsize 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Failed creating virtual disk: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
-		#==========================================
-		# setup loop device for virtual disk
-		#------------------------------------------
-		if (! $this -&gt; bindLoopDevice($diskname)) {
-			$this -&gt; cleanTmp ();
-			return undef;
+		if (! $haveDiskDevice) {
+			$kiwi -&gt; info (&quot;Creating virtual disk...&quot;);
+			$status = qxx (&quot;qemu-img create $diskname $vmsize 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+			if ($result != 0) {
+				$kiwi -&gt; failed ();
+				$kiwi -&gt; error  (&quot;Failed creating virtual disk: $status&quot;);
+				$kiwi -&gt; failed ();
+				return undef;
+			}
+			#==========================================
+			# setup loop device for virtual disk
+			#------------------------------------------
+			if (! $this -&gt; bindDiskDevice($diskname)) {
+				return undef;
+			}
+		} else {
+			$kiwi -&gt; info (&quot;Using disk device $haveDiskDevice...&quot;);
+			$this-&gt;{loop} = $haveDiskDevice;
+			if (! -b $this-&gt;{loop}) {
+				$kiwi -&gt; failed ();
+				$kiwi -&gt; error  (&quot;No such block device: $this-&gt;{loop}&quot;);
+				$kiwi -&gt; failed ();
+				return undef;
+			}
 		}
 		#==========================================
-		# create virtual disk partition
+		# create disk partition
 		#------------------------------------------
 		if (! $lvm) {
 			if (($syszip) || ($haveSplit) || ($dmapper)) {
@@ -2737,21 +1932,50 @@ sub setupBootDisk {
 			$this -&gt; cleanLoop();
 			return undef;
 		}
-		#==========================================
-		# Create loop device mapping table
-		#------------------------------------------
-		%deviceMap = $this -&gt; setLoopDeviceMap ($this-&gt;{loop});
-		#==========================================
-		# setup device mapper
-		#------------------------------------------
-		$status = qxx ( &quot;/sbin/kpartx -a $this-&gt;{loop} 2&gt;&amp;1&quot; );
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Failed mapping virtual partition: $status&quot;);
-			$kiwi -&gt; failed ();
-			$this -&gt; cleanLoop ();
-			return undef;
+		if (! $haveDiskDevice ) {
+			#==========================================
+			# setup device mapper
+			#------------------------------------------
+			if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
+				$kiwi -&gt; failed ();
+				$this -&gt; cleanLoop ();
+				return undef;
+			}
+			#==========================================
+			# Create loop device mapping table
+			#------------------------------------------
+			%deviceMap = $this -&gt; setLoopDeviceMap ($this-&gt;{loop});
+		} else {
+			#==========================================
+			# Create disk device mapping table
+			#------------------------------------------
+			%deviceMap = $this -&gt; setDefaultDeviceMap ($this-&gt;{loop});
+			#==========================================
+			# Umount possible mounted stick partitions
+			#------------------------------------------
+			$this -&gt; umountDevice ($this-&gt;{loop});
+			for (my $try=0;$try&gt;=2;$try++) {
+				$status = qxx (&quot;/sbin/blockdev --rereadpt $this-&gt;{loop} 2&gt;&amp;1&quot;);
+				$result = $? &gt;&gt; 8;
+				if ($result != 0) {
+					sleep (1); next;
+				}
+				last;
+			}
+			if ($result != 0) {
+				$kiwi -&gt; failed ();
+				$kiwi -&gt; error  (&quot;Couldn't reread partition table: $status&quot;);
+				$kiwi -&gt; failed ();
+				return undef;
+			}
+			#==========================================
+			# Wait for new partition table to settle
+			#------------------------------------------
+			sleep (1);
+			#==========================================
+			# Umount possible mounted stick partitions
+			#------------------------------------------
+			$this -&gt; umountDevice ($this-&gt;{loop});
 		}
 		#==========================================
 		# setup volume group if requested
@@ -2806,15 +2030,15 @@ sub setupBootDisk {
 	}
 	$kiwi -&gt; done();
 	#==========================================
-	# Dump system image on virtual disk
+	# Dump system image on disk
 	#------------------------------------------
 	if (! $haveTree) {
-		$kiwi -&gt; info (&quot;Dumping system image on virtual disk&quot;);
+		$kiwi -&gt; info (&quot;Dumping system image on disk&quot;);
 		$status = qxx (&quot;dd if=$system of=$root bs=32k 2&gt;&amp;1&quot;);
 		$result = $? &gt;&gt; 8;
 		if ($result != 0) {
 			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Couldn't dump image to virtual disk: $status&quot;);
+			$kiwi -&gt; error  (&quot;Couldn't dump image to disk: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
 			return undef;
@@ -2862,7 +2086,6 @@ sub setupBootDisk {
 			);
 			$kiwi -&gt; failed ();
 			$this -&gt; luksClose();
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		$this -&gt; luksClose();
@@ -2870,7 +2093,7 @@ sub setupBootDisk {
 			$kiwi -&gt; done();
 		}
 		if ($haveSplit) {
-			$kiwi -&gt; info (&quot;Dumping split read/write part on virtual disk&quot;);
+			$kiwi -&gt; info (&quot;Dumping split read/write part on disk&quot;);
 			$root = $deviceMap{2};
 			$status = qxx (&quot;dd if=$splitfile of=$root bs=32k 2&gt;&amp;1&quot;);
 			$result = $? &gt;&gt; 8;
@@ -2924,7 +2147,6 @@ sub setupBootDisk {
 				);
 				$kiwi -&gt; failed ();
 				$this -&gt; luksClose();
-				$this -&gt; cleanTmp ();
 				return undef;
 			}
 			$this -&gt; luksClose();
@@ -2937,7 +2159,6 @@ sub setupBootDisk {
 		# Create fs on system image partition
 		#------------------------------------------
 		if (! $this -&gt; setupFilesystem ($FSTypeRO,$root,&quot;root&quot;)) {
-			$this -&gt; cleanTmp ();
 			return undef;
 		}
 		#==========================================
@@ -2973,14 +2194,14 @@ sub setupBootDisk {
 			}
 		}
 		#==========================================
-		# Copy root tree to virtual disk
+		# Copy root tree to disk
 		#------------------------------------------
-		$kiwi -&gt; info (&quot;Copying system image tree on virtual disk&quot;);
+		$kiwi -&gt; info (&quot;Copying system image tree on disk&quot;);
 		$status = qxx (&quot;tar -cf - -C $system . | tar -x -C $loopdir 2&gt;&amp;1&quot;);
 		$result = $? &gt;&gt; 8;
 		if ($result != 0) {
 			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Can't copy image tree to virtual disk: $status&quot;);
+			$kiwi -&gt; error  (&quot;Can't copy image tree to disk: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
 			return undef;
@@ -3054,7 +2275,8 @@ sub setupBootDisk {
 		}
 		$kiwi -&gt; done();
 	} elsif (
-		($dmapper) || ($haveluks) || ($needBootP) || ($lvm) || ($bootloader eq &quot;extlinux&quot;)
+		($dmapper) || ($haveluks) || ($needBootP) ||
+		($lvm) || ($bootloader eq &quot;extlinux&quot;)
 	) {
 		$root = $deviceMap{dmapper};
 		$kiwi -&gt; info (&quot;Creating ext2 boot filesystem&quot;);
@@ -3086,9 +2308,9 @@ sub setupBootDisk {
 		$kiwi -&gt; done();
 	}
 	#==========================================
-	# Dump boot image on virtual disk
+	# Dump boot image on disk
 	#------------------------------------------
-	$kiwi -&gt; info (&quot;Copying boot image to virtual disk&quot;);
+	$kiwi -&gt; info (&quot;Copying boot image to disk&quot;);
 	#==========================================
 	# Mount system image / or rw partition
 	#------------------------------------------
@@ -3140,9 +2362,13 @@ sub setupBootDisk {
 	}
 	$this -&gt; cleanLoopMaps();
 	#==========================================
-	# Install boot loader on virtual disk
+	# Install boot loader on disk
 	#------------------------------------------
-	if (! $this -&gt; installBootLoader ($bootloader, $diskname, \%deviceMap)) {
+	my $bootdevice = $diskname;
+	if ($haveDiskDevice) {
+		$bootdevice = $this-&gt;{loop};
+	}
+	if (! $this-&gt;installBootLoader ($bootloader,$bootdevice,\%deviceMap)) {
 		$this -&gt; cleanLoop ();
 		return undef;
 	}
@@ -3159,8 +2385,11 @@ sub setupBootDisk {
 		#------------------------------------------
 		if ($type{installiso} =~ /true|yes/i) {
 			$this -&gt; {system} = $diskname;
+			if ($haveDiskDevice) {
+				$this -&gt; {system} = $this-&gt;{loop};
+			}
 			$kiwi -&gt; info (&quot;Creating install ISO image\n&quot;);
-			$this -&gt; cleanLoop (&quot;keep-mountpoints&quot;);
+			$this -&gt; cleanLoop ();
 			if (! $this -&gt; setupInstallCD()) {
 				return undef;
 			}
@@ -3170,8 +2399,11 @@ sub setupBootDisk {
 		#------------------------------------------
 		if ($type{installstick} =~ /true|yes/i) {
 			$this -&gt; {system} = $diskname;
+			if ($haveDiskDevice) {
+				$this -&gt; {system} = $this-&gt;{loop};
+			}
 			$kiwi -&gt; info (&quot;Creating install USB Stick image\n&quot;);
-			$this -&gt; cleanLoop (&quot;keep-mountpoints&quot;);
+			$this -&gt; cleanLoop ();
 			if (! $this -&gt; setupInstallStick()) {
 				return undef;
 			}
@@ -3374,7 +2606,6 @@ sub setupSplash {
 	}
 	chomp $spldir;
 	my $irddir = &quot;$spldir/initrd&quot;;
-
 	#==========================================
 	# unpack initrd files
 	#------------------------------------------
@@ -3539,44 +2770,22 @@ sub setupSplashForGrub {
 }
 
 #==========================================
-# cleanTmp
-#------------------------------------------
-sub cleanTmp {
-	my $this = shift;
-	if ($this-&gt;{lvm}) {
-		qxx (&quot;vgchange -an $this-&gt;{lvmgroup} 2&gt;&amp;1&quot;);
-	}
-	my $tmpdir = $this-&gt;{tmpdir};
-	my $loopdir= $this-&gt;{loopdir};
-	qxx (&quot;rm -rf $tmpdir 2&gt;&amp;1&quot;);
-	qxx (&quot;rm -rf $loopdir 2&gt;&amp;1&quot;);
-	return $this;
-}
-
-#==========================================
 # cleanLoop
 #------------------------------------------
 sub cleanLoop {
 	my $this = shift;
-	my $rmdir= shift;
 	my $tmpdir = $this-&gt;{tmpdir};
 	my $loop   = $this-&gt;{loop};
 	my $lvm    = $this-&gt;{lvm};
 	my $loopdir= $this-&gt;{loopdir};
 	main::umount();
-	if (defined $loop) {
+	if ((defined $loop) &amp;&amp; ($loop =~ /loop/)) {
 		if (defined $lvm) {
 			qxx (&quot;vgchange -an $this-&gt;{lvmgroup} 2&gt;&amp;1&quot;);
 		}
 		$this -&gt; cleanLoopMaps();
 		qxx (&quot;/sbin/losetup -d $loop 2&gt;&amp;1&quot;);
-		if (! defined $rmdir) {
-			undef $this-&gt;{loop};
-		}
-	}
-	if (! defined $rmdir) {
-		qxx (&quot;rm -rf $tmpdir&quot;);
-		qxx (&quot;rm -rf $loopdir&quot;);
+		undef $this-&gt;{loop};
 	}
 	return $this;
 }
@@ -3606,6 +2815,7 @@ sub cleanLoopMaps {
 sub buildMD5Sum {
 	my $this = shift;
 	my $file = shift;
+	my $outf = shift;
 	my $kiwi = $this-&gt;{kiwi};
 	$kiwi -&gt; info (&quot;Creating image MD5 sum...&quot;);
 	my $size = main::isize ($file);
@@ -3618,6 +2828,9 @@ sub buildMD5Sum {
 	my $blocks = $size / $blocksize;
 	my $sum  = qxx (&quot;cat $file | md5sum - | cut -f 1 -d-&quot;);
 	chomp $sum;
+	if ($outf) {
+		$file = $outf;
+	}
 	if ($file =~ /\.raw$/) {
 		$file =~ s/raw$/md5/;
 	}
@@ -4384,7 +3597,7 @@ sub installBootLoader {
 	if ($loader eq &quot;grub&quot;) {
 		$kiwi -&gt; info (&quot;Installing grub on device: $diskname&quot;);
 		#==========================================
-		# Create device map for the virtual disk
+		# Create device map for the disk
 		#------------------------------------------
 		my $dmfile = &quot;$tmpdir/grub-device.map&quot;;
 		my $dmfd = new FileHandle;
@@ -4514,7 +3727,11 @@ sub installBootLoader {
 			$device = $deviceMap{extlinux};
 		}
 		if (($device =~ /mapper/) &amp;&amp; (! -e $device)) {
-			qxx (&quot;kpartx -a $diskname&quot;);
+			if (! $this -&gt; bindDiskPartitions ($diskname)) {
+				$kiwi -&gt; failed ();
+				$this -&gt; cleanLoop ();
+				return undef;
+			}
 		}
 		if ($loader eq &quot;syslinux&quot;) {
 			$kiwi -&gt; info (&quot;Installing syslinux on device: $device&quot;);
@@ -4570,33 +3787,20 @@ sub installBootLoader {
 		#==========================================
 		# loop mount disk image file
 		#------------------------------------------
-		$status = qxx (&quot;/sbin/losetup -s -f $diskname 2&gt;&amp;1&quot;); chomp $status;
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Can't loop mount image file: $status&quot;);
-			$kiwi -&gt; failed ();
+		if (! $this-&gt;bindDiskDevice ($diskname)) {
 			return undef;
 		}
-		my $loop = $status;
-		$status = qxx (&quot;/sbin/kpartx -a $loop 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; failed ();
-			$kiwi -&gt; error  (&quot;Can't map loop mounted image file: $status&quot;);
+		if (! $this -&gt; bindDiskPartitions ($this-&gt;{loop})) {
 			$kiwi -&gt; failed ();
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
-		my $bootdev= $loop;
-		$bootdev =~ s/\/dev\///;
-		$bootdev = &quot;/dev/mapper/&quot;.$bootdev.&quot;p&quot;.$geometry[2];
+		my $bootdev = $this-&gt;{bindloop}.$geometry[2];
 		if (! -e $bootdev) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Can't find loop map: $bootdev&quot;);
 			$kiwi -&gt; failed ();
-			qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
 		$status = qxx (&quot;mount $bootdev /mnt 2&gt;&amp;1&quot;);
@@ -4605,8 +3809,7 @@ sub installBootLoader {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Can't mount boot partition: $status&quot;);
 			$kiwi -&gt; failed ();
-			qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
 		my $mount = &quot;/mnt&quot;;
@@ -4619,8 +3822,7 @@ sub installBootLoader {
 			$kiwi -&gt; error  (&quot;Can't open config file for reading: $!&quot;);
 			$kiwi -&gt; failed ();
 			qxx (&quot;umount $mount 2&gt;&amp;1&quot;);
-			qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
 		my @data = &lt;FD&gt;; close FD;
@@ -4629,14 +3831,13 @@ sub installBootLoader {
 			$kiwi -&gt; error  (&quot;Can't open config file for writing: $!&quot;);
 			$kiwi -&gt; failed ();
 			qxx (&quot;umount $mount 2&gt;&amp;1&quot;);
-			qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
 		foreach my $line (@data) {
 			print FD $line;
 			if ($line =~ /^:menu/) {
-				print FD &quot;\t&quot;.&quot;targetbase = $loop&quot;.&quot;\n&quot;;
+				print FD &quot;\t&quot;.&quot;targetbase = $this-&gt;{loop}&quot;.&quot;\n&quot;;
 				print FD &quot;\t&quot;.&quot;targettype = SCSI&quot;.&quot;\n&quot;;
 				print FD &quot;\t&quot;.&quot;targetblocksize = 512&quot;.&quot;\n&quot;;
 				print FD &quot;\t&quot;.&quot;targetoffset = $geometry[1]&quot;.&quot;\n&quot;;
@@ -4653,13 +3854,11 @@ sub installBootLoader {
 			$kiwi -&gt; error  (&quot;Couldn't install zipl on $diskname: $status&quot;);
 			$kiwi -&gt; failed ();
 			qxx (&quot;umount $mount 2&gt;&amp;1&quot;);
-			qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-			qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+			$this -&gt; cleanLoop ();
 			return undef;
 		}
 		qxx (&quot;umount $mount 2&gt;&amp;1&quot;);
-		qxx (&quot;kpartx  -d $loop 2&gt;&amp;1&quot;);
-		qxx (&quot;losetup -d $loop 2&gt;&amp;1&quot;);
+		$this -&gt; cleanLoop ();
 		$kiwi -&gt; done();
 	}
 	#==========================================
@@ -4678,9 +3877,9 @@ sub installBootLoader {
 }
 
 #==========================================
-# bindLoopDevice
+# bindDiskDevice
 #------------------------------------------
-sub bindLoopDevice {
+sub bindDiskDevice {
 	my $this   = shift;
 	my $system = shift;
 	my $kiwi   = $this-&gt;{kiwi};
@@ -4723,6 +3922,60 @@ sub bindLoopDevice {
 }
 
 #==========================================
+# bindDiskPartitions
+#------------------------------------------
+sub bindDiskPartitions {
+	# ...
+	# make sure we can access the partitions of the
+	# loop mounted disk file
+	# ---
+	my $this   = shift;
+	my $disk   = shift;
+	my $kiwi   = $this-&gt;{kiwi};
+	my $status;
+	my $result;
+	my $part;
+	$status = qxx (&quot;/sbin/kpartx -a $disk 2&gt;&amp;1&quot;);
+	$result = $? &gt;&gt; 8;
+	if ($result != 0) {
+		$kiwi -&gt; loginfo (&quot;Failed mapping partition: $status&quot;);
+		return undef;
+	}
+	$disk =~ s/dev\///;
+	$part = &quot;/dev/mapper&quot;.$disk.&quot;p&quot;;
+	$this-&gt;{bindloop} = $part;
+	return $this;
+}
+
+#==========================================
+# checkLVMbind
+#------------------------------------------
+sub checkLVMbind {
+	# ...
+	# check if the volume group was activated due to a
+	# previos call of kpartx. In this case the image has
+	# LVM enabled and we have to use the LVM devices
+	# ---
+	my $this = shift;
+	my $sdev = shift;
+	for (my $try=0;$try&lt;=3;$try++) {
+		if (defined (my $lvroot = glob (&quot;/dev/mapper/*-LVRoot&quot;))) {
+			$this-&gt;{lvm} = 1;
+			$sdev = $lvroot;
+			if (defined ($lvroot = glob (&quot;/dev/mapper/*-LVComp&quot;))) {
+				$sdev = $lvroot;
+			}
+			if ($lvroot =~ /mapper\/(.*)-.*/) {
+				$this-&gt;{lvmgroup} = $1;
+			}
+			last;
+		}
+		sleep 1;
+	}
+	return $sdev;
+}
+
+#==========================================
 # getCylinderSizeAndCount
 #------------------------------------------
 sub getCylinderSizeAndCount {
@@ -5369,13 +4622,6 @@ sub luksClose {
 		qxx (&quot;cryptsetup luksClose $this-&gt;{luks} 2&gt;&amp;1&quot;);
 		undef $this-&gt;{luks};
 	}
-	if ($this-&gt;{lhald}) {
-		$this-&gt;{lhald} -&gt; unlock (
-			$this-&gt;{lhalddevice}
-		);
-		undef $this-&gt;{lhald};
-		undef $this-&gt;{lhalddevice};
-	}
 	return $this;
 }
 
@@ -5587,4 +4833,79 @@ sub diskGeometry {
 	return ($geometry,$bootsector,$bootid);
 }
 
+#==========================================
+# searchUSBStickDevice
+#------------------------------------------
+sub searchUSBStickDevice {
+	my $this   = shift;
+	my $kiwi   = $this-&gt;{kiwi};
+	my $device = $this-&gt;{device};
+	my $stick;
+	#==========================================
+	# Find USB stick devices
+	#------------------------------------------
+	my %storage = $this -&gt; getRemovableUSBStorageDevices();
+	if (! %storage) {
+		$kiwi -&gt; error  (&quot;Couldn't find any removable USB storage devices&quot;);
+		$kiwi -&gt; failed ();
+		return undef;
+	}
+	my $prefix = $kiwi -&gt; getPrefix (1);
+	print STDERR $prefix,&quot;Found following removable USB devices:\n&quot;;
+	foreach my $dev (keys %storage) {
+		print STDERR $prefix,&quot;---&gt; $storage{$dev} at $dev\n&quot;;
+	}
+	if (! defined $device) {
+		#==========================================
+		# Let the user select the device
+		#------------------------------------------
+		while (1) {
+			$prefix = $kiwi -&gt; getPrefix (1);
+			print STDERR $prefix,&quot;Your choice (enter device name): &quot;;
+			chomp ($stick = &lt;&gt;);
+			my $found = 0;
+			foreach my $dev (keys %storage) {
+				if ($dev eq $stick) {
+					$found = 1; last;
+				}
+			}
+			if (! $found) {
+				if ($stick) {
+					print STDERR $prefix,&quot;Couldn't find [ $stick ] in list\n&quot;;
+				}
+				next;
+			}
+			last;
+		}
+	} else {
+		#==========================================
+		# Check the given device
+		#------------------------------------------
+		$stick = $device;
+		my $found = 0;
+		foreach my $dev (keys %storage) {
+			if ($dev eq $stick) {
+				$found = 1; last;
+			}
+		}
+		if (! $found) {
+			print STDERR $prefix,&quot;Couldn't find [ $stick ] in list\n&quot;;
+			return undef;
+		}
+	}
+	return $stick;
+}
+
+#==========================================
+# Destructor
+#------------------------------------------
+sub DESTROY {
+	my $this = shift;
+	my $dirs = $this-&gt;{tmpdirs};
+	foreach my $dir (@{$dirs}) {
+		qxx (&quot;rm -rf $dir 2&gt;&amp;1&quot;);
+	}
+	return $this;
+}
+
 1; 
diff --git a/modules/KIWIImage.pm b/modules/KIWIImage.pm
index 7650d2a..565b73b 100644
--- a/modules/KIWIImage.pm
+++ b/modules/KIWIImage.pm
@@ -670,6 +670,7 @@ sub createImageUSB {
 		$kiwi -&gt; failed ();
 		return undef;
 	}
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	$main::Survive  = &quot;yes&quot;;
 	$main::RootTree = &quot;$tmpdir/kiwi-&quot;.$text.&quot;boot-$$&quot;;
 	$main::Prepare  = $boot;
@@ -842,7 +843,6 @@ sub createImageUSB {
 		return undef;
 	}
 	my $newinitrd = $kboot -&gt; setupSplash();
-	$kboot -&gt; cleanTmp();
 	#==========================================
 	# inflate/deflate initrd to make xen happy
 	#------------------------------------------
@@ -1288,7 +1288,7 @@ sub createImageLiveCD {
 		$this -&gt; restoreCDRootData();
 		return undef;
 	}
-	my $tmpdir = qxx (&quot; mktemp -q -d /tmp/kiwi-cdboot.XXXXXX &quot;); chomp $tmpdir;
+	my $tmpdir = qxx (&quot;mktemp -q -d /tmp/kiwi-cdboot.XXXXXX&quot;); chomp $tmpdir;
 	my $result = $? &gt;&gt; 8;
 	if ($result != 0) {
 		$kiwi -&gt; error  (&quot;Couldn't create tmp dir: $tmpdir: $!&quot;);
@@ -1296,6 +1296,7 @@ sub createImageLiveCD {
 		$this -&gt; restoreCDRootData();
 		return undef;
 	}
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	$main::Survive  = &quot;yes&quot;;
 	$main::RootTree = &quot;$tmpdir/kiwi-cdboot-$$&quot;;
 	$main::Prepare  = $boot;
@@ -2469,6 +2470,7 @@ sub createImageSplit {
 		$kiwi -&gt; failed ();
 		return undef;
 	}
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	$main::Survive  = &quot;yes&quot;;
 	$main::RootTree = &quot;$tmpdir/kiwi-splitboot-$$&quot;;
 	$main::Prepare  = $boot;
@@ -2620,7 +2622,6 @@ sub createImageSplit {
 		return undef;
 	}
 	$kboot -&gt; setupSplash();
-	$kboot -&gt; cleanTmp();
 	#==========================================
 	# Check further actions due to boot image
 	#------------------------------------------
@@ -3919,6 +3920,7 @@ sub checkKernel {
 		$kiwi -&gt; failed ();
 		return undef;
 	}
+	push @{$this-&gt;{tmpdirs}},$tmpdir;
 	#==========================================
 	# 1) unpack initrd...
 	#------------------------------------------
@@ -4091,6 +4093,18 @@ sub getMBRDiskLabel {
 	return $this;
 }
 
+#==========================================
+# Destructor
+#------------------------------------------
+sub DESTROY {
+	my $this = shift;
+	my $dirs = $this-&gt;{tmpdirs};
+	foreach my $dir (@{$dirs}) {
+		qxx (&quot;rm -rf $dir 2&gt;&amp;1&quot;);
+	}
+	return $this;
+}
+
 1;
 
 # vim: set noexpandtab:
diff --git a/modules/KIWIImageFormat.pm b/modules/KIWIImageFormat.pm
index 3d94e3a..39a90e1 100644
--- a/modules/KIWIImageFormat.pm
+++ b/modules/KIWIImageFormat.pm
@@ -76,7 +76,6 @@ sub new {
 		if ($boot) {
 			$xml = $boot-&gt;{xml};
 			$boot -&gt; cleanLoop();
-			$boot -&gt; cleanTmp();
 		}
 		if (! defined $xml) {
 			$kiwi -&gt; error  (&quot;Can't load XML configuration, not an image ?&quot;);


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002631.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. b6b85432e32779a7ef445aac22c4c498f878de25
</A></li>
	<LI>Next message: <A HREF="002633.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 98f2b06176944a2ff4bfc2960d18727eef8abd73
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2632">[ date ]</a>
              <a href="thread.html#2632">[ thread ]</a>
              <a href="subject.html#2632">[ subject ]</a>
              <a href="author.html#2632">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
