<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] r1943 - in kiwi-head: . rpm template	template/suse-11.1-JeOS template/suse-11.1-JeOS/root	template/suse-11.1-JeOS/root/etc	template/suse-11.1-JeOS/root/etc/X11	template/suse-11.1-JeOS/root/etc/sysconfig	template/suse-11.1-JeOS/root/etc/sysconfig/network tools	tools/burner
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1943%20-%20in%20kiwi-head%3A%20.%20rpm%20template%0A%09template/suse-11.1-JeOS%20template/suse-11.1-JeOS/root%0A%09template/suse-11.1-JeOS/root/etc%0A%09template/suse-11.1-JeOS/root/etc/X11%0A%09template/suse-11.1-JeOS/root/etc/sysconfig%0A%09template/suse-11.1-JeOS/root/etc/sysconfig/network%20tools%0A%09tools/burner&In-Reply-To=%3C200903031354.n23Ds0PM016618%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001064.html">
   <LINK REL="Next"  HREF="001066.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] r1943 - in kiwi-head: . rpm template	template/suse-11.1-JeOS template/suse-11.1-JeOS/root	template/suse-11.1-JeOS/root/etc	template/suse-11.1-JeOS/root/etc/X11	template/suse-11.1-JeOS/root/etc/sysconfig	template/suse-11.1-JeOS/root/etc/sysconfig/network tools	tools/burner</H1>
    <B>marcus_schaefer at mail.berlios.de</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1943%20-%20in%20kiwi-head%3A%20.%20rpm%20template%0A%09template/suse-11.1-JeOS%20template/suse-11.1-JeOS/root%0A%09template/suse-11.1-JeOS/root/etc%0A%09template/suse-11.1-JeOS/root/etc/X11%0A%09template/suse-11.1-JeOS/root/etc/sysconfig%0A%09template/suse-11.1-JeOS/root/etc/sysconfig/network%20tools%0A%09tools/burner&In-Reply-To=%3C200903031354.n23Ds0PM016618%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] r1943 - in kiwi-head: . rpm template	template/suse-11.1-JeOS template/suse-11.1-JeOS/root	template/suse-11.1-JeOS/root/etc	template/suse-11.1-JeOS/root/etc/X11	template/suse-11.1-JeOS/root/etc/sysconfig	template/suse-11.1-JeOS/root/etc/sysconfig/network tools	tools/burner">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Tue Mar  3 14:54:00 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001064.html">[Kiwi-devel] r1942 - in kiwi-branches/KIWI-301-SuSE-11-1-Devel: doc	doc/LaTex modules rpm system/boot/ix86/oemboot
</A></li>
        <LI>Next message: <A HREF="001066.html">[Kiwi-devel] r1944 - kiwi-head/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1065">[ date ]</a>
              <a href="thread.html#1065">[ thread ]</a>
              <a href="subject.html#1065">[ subject ]</a>
              <a href="author.html#1065">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: marcus_schaefer
Date: 2009-03-03 14:53:40 +0100 (Tue, 03 Mar 2009)
New Revision: 1943

Added:
   kiwi-head/template/
   kiwi-head/template/suse-11.1-JeOS/
   kiwi-head/template/suse-11.1-JeOS/config.sh
   kiwi-head/template/suse-11.1-JeOS/config.xml
   kiwi-head/template/suse-11.1-JeOS/root/
   kiwi-head/template/suse-11.1-JeOS/root/etc/
   kiwi-head/template/suse-11.1-JeOS/root/etc/X11/
   kiwi-head/template/suse-11.1-JeOS/root/etc/X11/xorg.conf
   kiwi-head/template/suse-11.1-JeOS/root/etc/motd
   kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/
   kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/network/
   kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/network/ifcfg-eth0
   kiwi-head/tools/burner/
   kiwi-head/tools/burner/.make
   kiwi-head/tools/burner/DeviceItem.h
   kiwi-head/tools/burner/MainWindow.cpp
   kiwi-head/tools/burner/MainWindow.h
   kiwi-head/tools/burner/Platform.cpp
   kiwi-head/tools/burner/Platform.h
   kiwi-head/tools/burner/PlatformLinux.cpp
   kiwi-head/tools/burner/PlatformLinux.h
   kiwi-head/tools/burner/PlatformMac.cpp
   kiwi-head/tools/burner/PlatformMac.h
   kiwi-head/tools/burner/PlatformWindows.cpp
   kiwi-head/tools/burner/PlatformWindows.h
   kiwi-head/tools/burner/README
   kiwi-head/tools/burner/imagewriter.pro
   kiwi-head/tools/burner/imagewriter.qrc
   kiwi-head/tools/burner/logo-empty.png
   kiwi-head/tools/burner/logo-mini.png
   kiwi-head/tools/burner/main.cpp
Modified:
   kiwi-head/.newversion
   kiwi-head/Makefile
   kiwi-head/kiwi.pl
   kiwi-head/rpm/kiwi.changes
   kiwi-head/rpm/kiwi.spec
   kiwi-head/tools/Makefile
Log:

- v3.25
- added package kiwi-templates, JeOS templates. Wrote
  one template so far which is: suse-11.1-JeOS
- added package kiwi-tools-burner, Matt's burner tool
- added option --build which allows prepare and create
  in one step, useful for building templates



Modified: kiwi-head/.newversion
===================================================================
--- kiwi-head/.newversion	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/.newversion	2009-03-03 13:53:40 UTC (rev 1943)
@@ -14,7 +14,7 @@
 # spec file version update
 cat rpm/kiwi.spec | sed \
 	-e s&quot;@Version:       .*@Version:        $version@&quot; \
-	-e s&quot;@kiwi (Version .*@kiwi (Version $version@&quot; \
+	-e s&quot;@kiwi (Version .*@kiwi (Version $version)@&quot; \
 &gt; rpm/kiwi.spec.new &amp;&amp; mv rpm/kiwi.spec.new rpm/kiwi.spec
 
 echo &quot;update to version: $version... done&quot;

Modified: kiwi-head/Makefile
===================================================================
--- kiwi-head/Makefile	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/Makefile	2009-03-03 13:53:40 UTC (rev 1943)
@@ -121,11 +121,16 @@
 	#install -m 755 pxeboot/pxelinux.0.config ${TFTPBOOTCONF}/default
 
 	#============================================
-	# Install image descriptions
+	# Install boot image descriptions
 	#--------------------------------------------
 	cp -a system/boot/${arch}/* ${KIWIIMAGE} &amp;&gt;/dev/null || true
 
 	#============================================
+	# Install system image template descriptions
+	#--------------------------------------------
+	cp -a template/* ${KIWIIMAGE}
+
+	#============================================
 	# Install kiwi repo
 	#--------------------------------------------
 	cp -a system/suse-repo ${KIWIREPO}

Modified: kiwi-head/kiwi.pl
===================================================================
--- kiwi-head/kiwi.pl	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/kiwi.pl	2009-03-03 13:53:40 UTC (rev 1943)
@@ -44,7 +44,7 @@
 #============================================
 # Globals (Version)
 #--------------------------------------------
-our $Version       = &quot;3.24&quot;;
+our $Version       = &quot;3.25&quot;;
 our $Publisher     = &quot;SUSE LINUX Products GmbH&quot;;
 our $Preparer      = &quot;KIWI - <A HREF="http://kiwi.berlios.de">http://kiwi.berlios.de</A>&quot;;
 our $openSUSE      = &quot;<A HREF="http://download.opensuse.org">http://download.opensuse.org</A>&quot;;
@@ -126,6 +126,7 @@
 #============================================
 # Globals
 #--------------------------------------------
+our $Build;                 # run prepare and create in one step
 our $Prepare;               # control XML file for building chroot extend
 our $Create;                # image description for building image extend
 our $CreateInstSource;      # create installation source from meta packages
@@ -253,8 +254,26 @@
 			}
 		}
 	}
-
 	#========================================
+	# Prepare and Create in one step
+	#----------------------------------------
+	if (defined $Build) {
+		$main::Prepare = $Build;
+		$main::RootTree= $Destination.&quot;/image-root&quot;;
+		$main::Survive = &quot;yes&quot;;
+		$main::ForceNewRoot = 1;
+		undef $main::Build;
+		if (! defined main::main()) {
+			$main::Survive = &quot;default&quot;;
+			my $code = kiwiExit (1); return $code;
+		}
+		undef $main::Prepare;
+		undef $main::ForceNewRoot;
+		$main::Survive = &quot;default&quot;;
+		$main::Create = $RootTree;
+		main::main();
+	}
+	#========================================
 	# Prepare image and build chroot system
 	#----------------------------------------
 	if (defined $Prepare) {
@@ -1144,6 +1163,7 @@
 		&quot;version&quot;               =&gt; \&amp;version,
 		&quot;v|verbose+&quot;            =&gt; \$Verbosity,
 		&quot;logfile=s&quot;             =&gt; \$LogFile,
+		&quot;build|b=s&quot;             =&gt; \$Build,
 		&quot;prepare|p=s&quot;           =&gt; \$Prepare,
 		&quot;add-profile=s&quot;         =&gt; \@Profiles,
 		&quot;migrate|m=s&quot;           =&gt; \$Migrate,
@@ -1251,6 +1271,7 @@
 	# Check option combination/values
 	#------------------------------------------
 	if (
+		(! defined $Build)              &amp;&amp;
 		(! defined $Prepare)            &amp;&amp;
 		(! defined $Create)             &amp;&amp;
 		(! defined $BootStick)          &amp;&amp;
@@ -1348,6 +1369,11 @@
 			my $code = kiwiExit (1); return $code;
 		}
 	}
+	if ((defined $Build) &amp;&amp; (! defined $Destination)) {
+		$kiwi -&gt; error  (&quot;No destination directory specified&quot;);
+		$kiwi -&gt; failed ();
+		my $code = kiwiExit (1); return $code;
+	}
 }
 
 #==========================================
@@ -1366,12 +1392,14 @@
 
 	print &quot;Usage:\n&quot;;
 	print &quot;  kiwi -l | --list\n&quot;;
-	print &quot;Image Preparation/Creation:\n&quot;;
+	print &quot;Image Creation in one step:\n&quot;;
+	print &quot;  kiwi -b | --build &lt;image-path&gt; -d &lt;destination&gt;\n&quot;;
+	print &quot;Image Preparation/Creation in two steps:\n&quot;;
 	print &quot;  kiwi -p | --prepare &lt;image-path&gt;\n&quot;;
 	print &quot;     [ --base-root &lt;base-path&gt; ]\n&quot;;
 	print &quot;     [ --base-root-mode &lt;copy|union|recycle&gt; ]\n&quot;;
 	print &quot;     [ --add-profile &lt;profile-name&gt; ]\n&quot;;
-	print &quot;  kiwi -c | --create  &lt;image-root&gt;\n&quot;;
+	print &quot;  kiwi -c | --create  &lt;image-root&gt; -d &lt;destination&gt;\n&quot;;
 	print &quot;     [ --base-root &lt;base-path&gt; ]\n&quot;;
 	print &quot;     [ --base-root-mode &lt;copy|union|recycle&gt; ]\n&quot;;
 	print &quot;     [ --prebuiltbootimage &lt;directory&gt;]\n&quot;;

Modified: kiwi-head/rpm/kiwi.changes
===================================================================
--- kiwi-head/rpm/kiwi.changes	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/rpm/kiwi.changes	2009-03-03 13:53:40 UTC (rev 1943)
@@ -1,4 +1,14 @@
 -------------------------------------------------------------------
+Tue Mar  3 12:12:28 CET 2009 - <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>
+
+- v3.25
+- added package kiwi-templates, JeOS templates. Wrote
+  one template so far which is: suse-11.1-JeOS
+- added package kiwi-tools-burner, Matt's burner tool
+- added option --build which allows prepare and create
+  in one step, useful for building templates
+
+-------------------------------------------------------------------
 Mon Mar  2 10:19:09 CET 2009 - <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>
 
 - v3.24

Modified: kiwi-head/rpm/kiwi.spec
===================================================================
--- kiwi-head/rpm/kiwi.spec	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/rpm/kiwi.spec	2009-03-03 13:53:40 UTC (rev 1943)
@@ -1,5 +1,5 @@
 #
-# spec file for package kiwi (Version 3.24
+# spec file for package kiwi (Version 3.25)
 #
 # Copyright (c) 2008 SUSE LINUX Products GmbH, Nuernberg, Germany.
 # This file and all modifications and additions to the pristine
@@ -43,7 +43,7 @@
 Summary:        OpenSuSE - KIWI Image System
 Provides:       kiwi2 &lt;= 2.14
 Obsoletes:      kiwi2 &lt;= 2.14
-Version:        3.24
+Version:        3.25
 Release:        80
 Group:          System/Management
 License:        GPL v2 or later
@@ -57,29 +57,43 @@
 image solution for Linux supported hardware platforms as well as for
 virtualization systems like Xen.
 
-
-
 Authors:
 --------
     Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
 
-%ifarch %ix86 x86_64
-%package -n kiwi-pxeboot
-License:        GPL v2 or later
-Requires:       syslinux
-Summary:        OpenSuSE - KIWI Image System PXE boot structure
-Obsoletes:      kiwi2-pxeboot &lt;= 2.14
-Provides:       kiwi2-pxeboot &lt;= 2.14
+%package -n kiwi-instsource
+License:        GPL v2 only
+Requires:       kiwi = %{version}
+Requires:       inst-source-utils createrepo
+Summary:        Installation Source creation
 Group:          System/Management
 
-%description -n kiwi-pxeboot
-PXE basic directory structure and pre-build boot images
+%description -n kiwi-instsource
+This package contains modules used for installation source creation.
+With those it is possible to create a valid installation repository
+from blank RPM file trees. The created tree can be used directly for
+the image creation process afterwards. This package allows using the
+--create-instsource &lt;path-to-config.xml&gt; switch.
 
 Authors:
 --------
-    Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
-%endif
+	Adrian Schroeter &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">adrian at novell.com</A>&gt;
+	Jan Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at novell.com</A>&gt;
 
+%package -n kiwi-doc
+License:        LGPL v2.0 or later
+Summary:        OpenSuSE - KIWI Image System Documentation
+Group:          Documentation/Howto
+
+%description -n kiwi-doc
+This package contains the documentation and manual pages for the KIWI
+Image System
+
+Authors:
+--------
+    Thomas Schraitle
+    Marcus Schaefer
+
 %package -n kiwi-tools
 License:        GPL v2 or later
 Summary:        OpenSuSE - KIWI tools collection
@@ -91,11 +105,41 @@
 This package contains the OpenSuSE - KIWI tools set usable in and
 outside of operating system images
 
+Authors:
+--------
+    Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
 
 
+%package -n kiwi-tools-imagewriter
+License:        GPL v2 or later
+Summary:        OpenSuSE - KIWI tools graphical image writer application
+Group:          System/Management
+
+%description -n kiwi-tools-imagewriter
+This package contains the OpenSuSE - KIWI graphical image writer
+application
+
 Authors:
 --------
+    Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbaringer at novell.com</A>&gt;
+
+
+%ifarch %ix86 x86_64
+%package -n kiwi-pxeboot
+License:        GPL v2 or later
+Requires:       syslinux
+Summary:        OpenSuSE - KIWI Image System PXE boot structure
+Obsoletes:      kiwi2-pxeboot &lt;= 2.14
+Provides:       kiwi2-pxeboot &lt;= 2.14
+Group:          System/Management
+
+%description -n kiwi-pxeboot
+PXE basic directory structure and pre-build boot images
+
+Authors:
+--------
     Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
+%endif
 
 %ifarch %ix86 x86_64
 %package -n kiwi-pxeboot-prebuild
@@ -215,42 +259,27 @@
 This package contains the OpenSuSE - KIWI image descriptions. Each
 image description exists in a single directory and contains an oemboot
 image description
-%endif
 
-%package -n kiwi-doc
-License:        LGPL v2.0 or later
-Summary:        OpenSuSE - KIWI Image System Documentation
-Group:          Documentation/Howto
-
-%description -n kiwi-doc
-This package contains the documentation and manual pages for the KIWI
-Image System
-
 Authors:
 --------
-    Thomas Schraitle
-    Marcus Schaefer
+    Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
+%endif
 
-
-%package -n kiwi-instsource
-License:        GPL v2 only
-Requires:       kiwi = %{version}
-Requires:       inst-source-utils createrepo
-Summary:        Installation Source creation
+%ifarch %ix86 x86_64
+%package -n kiwi-templates
+License:        GPL v2.0 or later
+Requires:       kiwi-desc-vmxboot = %{version}
+Summary:        OpenSuSE - KIWI JeOS system image templates
 Group:          System/Management
 
-%description -n kiwi-instsource
-This package contains modules used for installation source creation.
-With those it is possible to create a valid installation repository
-from blank RPM file trees. The created tree can be used directly for
-the image creation process afterwards. This package allows using the
---create-instsource &lt;path-to-config.xml&gt; switch.
+%description -n kiwi-templates
+This package contains system image templates to easily build
+a JeOS based operating system image with kiwi 
 
-
-
 Authors:
 --------
-    Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at novell.com</A>&gt;
+    Marcus Schaefer
+%endif
 
 %prep
 %setup -n kiwi
@@ -367,9 +396,6 @@
 	echo /srv/tftpboot/pxelinux.0 &gt; kiwi.loader
 test -f $RPM_BUILD_ROOT/srv/tftpboot/mboot.c32 &amp;&amp; \
 	echo /srv/tftpboot/mboot.c32 &gt;&gt; kiwi.loader
-install -m 644 tools/README \
-	$RPM_BUILD_ROOT/usr/share/doc/packages/kiwi/README.tools
-rm -rf $RPM_BUILD_ROOT/usr/share/doc/packages/kiwi/kiwi-man
 %perl_process_packlist
 rm -f $RPM_BUILD_ROOT/%{perl_vendorarch}/KIWI/example.pl
 ./.links
@@ -391,6 +417,7 @@
 %defattr(-, root, root)
 %dir %{_datadir}/kiwi
 %dir %{_datadir}/kiwi/image
+%exclude %{_datadir}/kiwi/image/suse-11.1-JeOS
 %{_datadir}/kiwi/.revision
 %{_datadir}/kiwi/modules
 %{_datadir}/kiwi/repo
@@ -459,15 +486,22 @@
 #=================================================
 # KIWI-tools files...  
 # ------------------------------------------------
-
 %files -n kiwi-tools
 %defattr(-, root, root)
 %doc %{_defaultdocdir}/kiwi/README.tools
 %exclude /usr/bin/suse-isolinux
+%exclude /usr/bin/imagewriter
 /usr/bin/*
 #=================================================
-# KIWI-desc-*...
+# KIWI-tools-imagewriter files...  
 # ------------------------------------------------
+%files -n kiwi-tools-imagewriter
+%defattr(-, root, root)
+%doc %{_defaultdocdir}/kiwi/README.imagewriter
+/usr/bin/imagewriter
+#=================================================
+# KIWI-desc-* and templates...
+# ------------------------------------------------
 %ifarch %ix86 x86_64
 %files -n kiwi-desc-isoboot
 %defattr(-, root, root)
@@ -515,3 +549,10 @@
 %doc %{_datadir}/kiwi/image/oemboot/README
 %{_datadir}/kiwi/image/oemboot/suse*
 %endif
+
+%ifarch %ix86 x86_64
+%files -n kiwi-templates
+%defattr(-, root, root)
+%dir %{_datadir}/kiwi/image/suse-11.1-JeOS
+%{_datadir}/kiwi/image/suse-11.1-JeOS
+%endif

Added: kiwi-head/template/suse-11.1-JeOS/config.sh
===================================================================
--- kiwi-head/template/suse-11.1-JeOS/config.sh	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/template/suse-11.1-JeOS/config.sh	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,74 @@
+#!/bin/bash
+#================
+# FILE          : config.sh
+#----------------
+# PROJECT       : OpenSuSE KIWI Image System
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
+#               :
+# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : configuration script for SUSE based
+#               : operating systems
+#               :
+#               :
+# STATUS        : BETA
+#----------------
+#======================================
+# Functions...
+#--------------------------------------
+test -f /.kconfig &amp;&amp; . /.kconfig
+test -f /.profile &amp;&amp; . /.profile
+
+#======================================
+# Greeting...
+#--------------------------------------
+echo &quot;Configure image: [$kiwi_iname]...&quot;
+
+#======================================
+# Activate services
+#--------------------------------------
+suseInsertService sshd
+suseInsertService boot.device-mapper
+suseRemoveService avahi-dnsconfd
+suseRemoveService avahi-daemon
+
+#==========================================
+# remove unneeded packages
+#------------------------------------------
+rpm -e --nodeps --noscripts \
+	$(rpm -q `baseGetPackagesForDeletion` | grep -v &quot;is not installed&quot;)
+
+#==========================================
+# remove package docs
+#------------------------------------------
+rm -rf /usr/share/doc/packages/*
+rm -rf /usr/share/doc/manual/*
+rm -rf /opt/kde3
+
+#======================================
+# SuSEconfig
+#--------------------------------------
+suseConfig
+
+#======================================
+# Add 11.1 repo
+#--------------------------------------
+baseRepo=&quot;<A HREF="http://download.opensuse.org/distribution/11.1/repo/oss">http://download.opensuse.org/distribution/11.1/repo/oss</A>&quot;
+baseName=&quot;suse-11.1&quot;
+zypper ar $baseRepo $baseName
+
+#======================================
+# Remove unneeded packages
+#--------------------------------------
+rpm -qa | grep yast | xargs rpm -e --nodeps
+rpm -qa | grep perl | xargs rpm -e --nodeps
+rpm -qa | grep cracklib | xargs rpm -e --nodeps
+
+#======================================
+# Umount kernel filesystems
+#--------------------------------------
+baseCleanMount
+
+exit 0


Property changes on: kiwi-head/template/suse-11.1-JeOS/config.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: kiwi-head/template/suse-11.1-JeOS/config.xml
===================================================================
--- kiwi-head/template/suse-11.1-JeOS/config.xml	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/template/suse-11.1-JeOS/config.xml	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,78 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;image schemeversion=&quot;2.4&quot; name=&quot;LimeJeOS-openSUSE-11.1&quot;&gt;
+	&lt;!-- Base Information --&gt;
+	&lt;description type=&quot;system&quot;&gt;
+		&lt;author&gt;Marcus Sch&#228;fer&lt;/author&gt;
+		&lt;contact&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&lt;/contact&gt;
+		&lt;specification&gt;
+			openSUSE 11.1 JeOS, is a small text based image which
+			allows editing of files as well as upgrading to a full
+			distro by using zypper with the pre-defined repository 
+		&lt;/specification&gt;
+	&lt;/description&gt;
+	&lt;!-- Image Type and Preferences --&gt;
+	&lt;preferences&gt;
+		&lt;type 
+			primary=&quot;true&quot;
+			filesystem=&quot;ext3&quot;
+			boot=&quot;vmxboot/suse-11.1&quot;
+			format=&quot;vmdk&quot;
+		&gt;vmx&lt;/type&gt;
+		&lt;type 
+			filesystem=&quot;ext3&quot;
+			boot=&quot;oemboot/suse-11.1&quot;
+			format=&quot;iso&quot;
+		&gt;oem&lt;/type&gt;
+		&lt;type 
+			boot=&quot;isoboot/suse-11.1&quot;
+			flags=&quot;unified&quot;
+		&gt;iso&lt;/type&gt;
+		&lt;type 
+			filesystem=&quot;ext3&quot;
+			boot=&quot;xenboot/suse-11.1&quot;
+		&gt;xen&lt;/type&gt;
+		&lt;version&gt;1.11.1&lt;/version&gt;
+		&lt;packagemanager&gt;zypper&lt;/packagemanager&gt;
+		&lt;locale&gt;en_US.UTF-8&lt;/locale&gt;
+		&lt;keytable&gt;de-latin1-nodeadkeys.map.gz&lt;/keytable&gt;
+		&lt;timezone&gt;Europe/Berlin&lt;/timezone&gt;
+		&lt;rpm-excludedocs&gt;yes&lt;/rpm-excludedocs&gt;
+	&lt;/preferences&gt;
+	&lt;!-- Users setup --&gt;
+	&lt;users group=&quot;root&quot;&gt;
+		&lt;user 
+			pwd=&quot;$1$wYJUgpM5$RXMMeASDc035eX.NbYWFl0&quot;
+			home=&quot;/root&quot;
+			name=&quot;root&quot;
+		/&gt;
+	&lt;/users&gt;
+	&lt;!-- Package Repositories --&gt;
+	&lt;repository type=&quot;yast2&quot;&gt;
+		&lt;source path=&quot;<A HREF="opensuse://11.1/repo/oss/">opensuse://11.1/repo/oss/</A>&quot;/&gt;
+	&lt;/repository&gt;
+	&lt;!-- Packages and Patterns --&gt;
+	&lt;packages type=&quot;image&quot;&gt;
+		&lt;package name=&quot;kernel-default&quot; replaces=&quot;kernel-xen&quot;/&gt;
+		&lt;package name=&quot;bootsplash&quot;/&gt;
+		&lt;package name=&quot;bootsplash-branding-openSUSE&quot;/&gt;
+		&lt;package name=&quot;ifplugd&quot;/&gt;
+		&lt;package name=&quot;vim&quot;/&gt;
+		&lt;opensusePattern name=&quot;base&quot;/&gt;
+	&lt;/packages&gt;
+	&lt;packages type=&quot;xen&quot;&gt;
+		&lt;package name=&quot;kernel-xen&quot; replaces=&quot;kernel-default&quot;/&gt;
+		&lt;package name=&quot;xen&quot;/&gt;
+	&lt;/packages&gt;
+	&lt;packages type=&quot;bootstrap&quot;&gt;
+		&lt;package name=&quot;filesystem&quot;/&gt;
+		&lt;package name=&quot;glibc-locale&quot;/&gt;
+	&lt;/packages&gt;
+	&lt;!-- Virtual Machine configurations --&gt;
+	&lt;vmwareconfig memory=&quot;256&quot; guestOS=&quot;suse&quot; HWversion=&quot;4&quot;&gt;
+		&lt;vmwaredisk controller=&quot;scsi&quot; id=&quot;0&quot;/&gt;
+		&lt;vmwarenic driver=&quot;e1000&quot; interface=&quot;0&quot; mode=&quot;bridged&quot;/&gt;
+	&lt;/vmwareconfig&gt;
+	&lt;xenconfig memory=&quot;256&quot;&gt;
+		&lt;xendisk device=&quot;/dev/sda&quot;/&gt;
+	&lt;/xenconfig&gt;
+&lt;/image&gt;

Added: kiwi-head/template/suse-11.1-JeOS/root/etc/X11/xorg.conf
===================================================================
--- kiwi-head/template/suse-11.1-JeOS/root/etc/X11/xorg.conf	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/template/suse-11.1-JeOS/root/etc/X11/xorg.conf	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,230 @@
+# generic XFree86 4.x configuration file
+
+Section &quot;Files&quot;
+  FontPath		&quot;/usr/share/fonts/truetype/&quot;
+  FontPath		&quot;/usr/share/fonts/uni/&quot;
+  FontPath		&quot;/usr/share/fonts/misc/&quot;
+  ModulePath		&quot;/usr/lib/xorg/modules&quot;
+  InputDevices	&quot;/dev/ttyS0&quot;
+  InputDevices	&quot;/dev/ttyS1&quot;
+  InputDevices	&quot;/dev/ttyS2&quot;
+  InputDevices	&quot;/dev/ttyS3&quot;
+  InputDevices	&quot;/dev/ttyS4&quot;
+  InputDevices	&quot;/dev/ttyS5&quot;
+  InputDevices	&quot;/dev/ttyS6&quot;
+  InputDevices	&quot;/dev/ttyS7&quot;
+  InputDevices	&quot;/dev/ttyS8&quot;
+  InputDevices	&quot;/dev/psaux&quot;
+  InputDevices	&quot;/dev/logibm&quot;
+  InputDevices	&quot;/dev/sunmouse&quot;
+  InputDevices	&quot;/dev/atibm&quot;
+  InputDevices	&quot;/dev/amigamouse&quot;
+  InputDevices	&quot;/dev/atarimouse&quot;
+  InputDevices	&quot;/dev/inportbm&quot;
+  InputDevices	&quot;/dev/gpmdata&quot;
+  InputDevices	&quot;/dev/usbmouse&quot;
+  InputDevices	&quot;/dev/adbmouse&quot;
+  InputDevices	&quot;/dev/input/mice&quot;
+  InputDevices	&quot;/dev/input/event0&quot;
+EndSection
+
+Section &quot;ServerFlags&quot;
+  Option	&quot;AllowMouseOpenFail&quot;
+  Option	&quot;BlankTime&quot;	&quot;0&quot;
+EndSection
+
+Section &quot;Module&quot;
+  Load	&quot;dbe&quot;
+  Load	&quot;extmod&quot;
+EndSection
+
+Section &quot;InputDevice&quot;
+  Driver		&quot;kbd&quot;
+  Identifier	&quot;Keyboard[0]&quot;
+  Option		&quot;Protocol&quot;		&quot;Standard&quot;
+  Option		&quot;XkbRules&quot;		&quot;xfree86&quot;
+  Option		&quot;XkbKeycodes&quot;	&quot;xfree86&quot;
+  Option		&quot;XkbModel&quot;		&quot;pc104&quot;
+  Option		&quot;XkbLayout&quot;		&quot;us&quot;
+EndSection
+
+Section &quot;InputDevice&quot;
+  Driver     &quot;mouse&quot;
+  Identifier &quot;Mouse[1]&quot;
+  Option     &quot;Protocol&quot; &quot;Auto&quot;
+  Option     &quot;Device&quot;   &quot;/dev/input/mice&quot;
+EndSection
+
+Section &quot;Monitor&quot;
+  HorizSync		25-40
+  Identifier	&quot;Monitor[0]&quot;
+  ModelName		&quot;Initial&quot;
+  VendorName	&quot;Initial&quot;
+  VertRefresh	47-75
+  UseModes		&quot;Modes[0]&quot;
+EndSection
+
+
+Section &quot;Modes&quot;
+  Identifier	&quot;Modes[0]&quot;
+  Modeline      &quot;800x600&quot; 40.0   800 840 968 1056 600 601 605 628 +hsync +vsync
+  Modeline		&quot;640x480&quot; 31.5   640 656 720 840  480 481 484 500 # 6. Try
+  Modeline		&quot;640x480&quot; 31.5   640 680 720 864  480 488 491 521 # 5. Try
+  Modeline		&quot;640x480&quot; 28     640 664 760 800  480 491 493 525 # 4. Try
+  Modeline		&quot;640x480&quot; 28.32  640 664 760 800  480 491 493 525 # 3. Try
+  Modeline		&quot;640x480&quot; 25.18  640 664 760 800  480 491 493 525 # 2. Try
+  Modeline		&quot;640x480&quot; 25.175 640 664 760 800  480 491 493 525 # 1. Try
+EndSection
+
+Section &quot;Monitor&quot;
+  HorizSync		28-33
+  Identifier	&quot;Monitor[vmware]&quot;
+  ModelName		&quot;Initial&quot;
+  VendorName	&quot;Initial&quot;
+  VertRefresh	43-72
+  UseModes		&quot;Modes[vmware]&quot;
+EndSection
+    
+Section &quot;Modes&quot;
+  Identifier	&quot;Modes[vmware]&quot;
+  Modeline		&quot;800x600&quot; 29.38 800 816 896 992 600 601 604 617
+EndSection
+
+Section &quot;Monitor&quot;
+  HorizSync		31-48
+  Identifier	&quot;Monitor[vesa]&quot;
+  ModelName		&quot;VESA&quot;
+  VendorName	&quot;VESA&quot;
+  VertRefresh	50-60
+EndSection
+
+# Screen Section for module X support
+# -------------------------------------
+Section &quot;Screen&quot;
+  DefaultDepth 16
+  SubSection &quot;Display&quot;
+    Depth		16
+    Modes		&quot;800x600&quot; 
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		24
+    Modes		&quot;800x600&quot; 
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		32
+    Modes		&quot;800x600&quot; 
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		8
+    Modes		&quot;800x600&quot; 
+  EndSubSection
+  Device		&quot;Device[0]&quot;
+  Identifier	&quot;Screen[0]&quot;
+  Monitor		&quot;Monitor[0]&quot;
+EndSection
+
+# Screen Section for fbdev support
+# vesafb defaults to 16bit
+# others default to 8bit, force a higher colordepth
+# on Apple onboard controllers, remove the default #207338
+# changes for DefaultDepth have to be made in /usr/lib/YaST2/startup/YaST2.call as well
+# ----------------------------------
+Section &quot;Screen&quot;
+#@DefaultDepth@
+  SubSection &quot;Display&quot;
+    Depth		16
+    Modes		&quot;default&quot;            
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		15
+    Modes		&quot;default&quot;            
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		24
+    Modes		&quot;default&quot;  
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		32
+    Modes		&quot;default&quot;  
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		8
+    Modes		&quot;default&quot;  
+  EndSubSection
+  Device		&quot;Device[fbdev]&quot;
+  Identifier	&quot;Screen[fbdev]&quot;
+  Monitor		&quot;Monitor[0]&quot;
+EndSection
+
+# Screen Section for vesa support
+# ----------------------------------
+Section &quot;Screen&quot;
+  SubSection &quot;Display&quot;
+    Depth		16
+    Modes		&quot;default&quot;            
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		8
+    Modes		&quot;default&quot;  
+  EndSubSection
+  Device		&quot;Device[vesa]&quot;
+  Identifier	&quot;Screen[vesa]&quot;
+  Monitor       &quot;Monitor[vesa]&quot;
+EndSection
+
+# Screen Section for vmware support
+# ----------------------------------
+Section &quot;Screen&quot;
+  SubSection &quot;Display&quot;
+    Depth		8
+    Modes		&quot;800x600&quot;
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		16
+    Modes		&quot;800x600&quot;
+  EndSubSection
+  SubSection &quot;Display&quot;
+    Depth		24
+    Modes		&quot;800x600&quot;
+  EndSubSection
+  Device		&quot;Device[vmware]&quot;
+  Identifier	&quot;Screen[vmware]&quot;
+  Monitor		&quot;Monitor[vmware]&quot;
+EndSection
+
+# Device Sections...
+# -------------------
+Section &quot;Device&quot;
+  #BusID        &quot;1:0:0&quot;
+  Driver		&quot;vesa&quot;
+  Identifier	&quot;Device[0]&quot;
+  # device_options
+  Option		&quot;sw_cursor&quot;	&quot;on&quot;
+EndSection
+
+Section &quot;Device&quot;
+  Driver		&quot;fbdev&quot;
+  Identifier	&quot;Device[fbdev]&quot;
+  # fbdev_options
+EndSection
+
+Section &quot;Device&quot;
+  Driver		&quot;vesa&quot;
+  #Option        &quot;DefaultRefresh&quot;
+  Option        &quot;ModeSetClearScreen&quot; &quot;no&quot;
+  Identifier	&quot;Device[vesa]&quot;
+EndSection
+
+Section &quot;Device&quot;
+  Driver		&quot;vmware&quot;
+  Identifier	&quot;Device[vmware]&quot;
+EndSection
+
+Section &quot;ServerLayout&quot;
+  Identifier	&quot;Layout[all]&quot;
+  InputDevice	&quot;Keyboard[0]&quot;	&quot;CoreKeyboard&quot;
+  InputDevice  &quot;Mouse[1]&quot; &quot;CorePointer&quot;
+  Option		&quot;Xinerama&quot;		&quot;off&quot;
+  Screen   &quot;Screen[vesa]&quot;
+EndSection
+

Added: kiwi-head/template/suse-11.1-JeOS/root/etc/motd
===================================================================
--- kiwi-head/template/suse-11.1-JeOS/root/etc/motd	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/template/suse-11.1-JeOS/root/etc/motd	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,7 @@
+This is the Lime-JeOS 11.1 SuSE Linux System.
+To upgrade your system call:
+
+    zypper refresh
+    zypper install -t product openSUSE-11.1
+
+Have a lot of fun...

Added: kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/network/ifcfg-eth0
===================================================================
--- kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/network/ifcfg-eth0	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/template/suse-11.1-JeOS/root/etc/sysconfig/network/ifcfg-eth0	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,4 @@
+BOOTPROTO='dhcp'
+MTU=''
+REMOTE_IPADDR=''
+STARTMODE='onboot'

Modified: kiwi-head/tools/Makefile
===================================================================
--- kiwi-head/tools/Makefile	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/Makefile	2009-03-03 13:53:40 UTC (rev 1943)
@@ -11,9 +11,14 @@
 			true;\
 		fi\
 	)
+	( cd burner &amp;&amp; .make )
+	${MAKE} -C burner all
 
 install:
+	install -m 644 README ${PACKDOCVZ}/README.tools
+	install -m 644 burner/README ${PACKDOCVZ}/README.imagewriter
 	#install -m 755 init/* ${INITVZ}
+	install -m 755 burner/imagewriter ${bin_prefix}
 	install -m 755 startshell/startshell ${TOOLSVZ}
 	install -m 755 pigz/pigz ${TOOLSVZ}
 	install -m 755 driveready/driveready ${TOOLSVZ}
@@ -28,6 +33,7 @@
 	)
 
 clean:
+	${MAKE} -C burner clean
 	${MAKE} -C startshell clean
 	${MAKE} -C pigz clean
 	${MAKE} -C driveready clean


Property changes on: kiwi-head/tools/burner
___________________________________________________________________
Name: svn:ignore
   + Makefile
imagewriter


Added: kiwi-head/tools/burner/.make
===================================================================
--- kiwi-head/tools/burner/.make	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/.make	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,14 @@
+#!/bin/sh
+# Copyright (c) 2001 SuSE GmbH Nuernberg, Germany.  All rights reserved.
+#
+# Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbaringer at novell.com</A>&gt;, 2008
+# Status: Up-to-date
+#
+if [ -d /usr/share/qt/mkspecs/linux-g++ ];then
+	export QMAKESPEC=/usr/share/qt/mkspecs/linux-g++/
+	`which qmake` -makefile -unix -o Makefile imagewriter.pro
+else
+	export QMAKESPEC=/usr/share/qt4/mkspecs/linux-g++/
+	`which qmake` -makefile -unix -o Makefile imagewriter.pro
+fi
+


Property changes on: kiwi-head/tools/burner/.make
___________________________________________________________________
Name: svn:executable
   + *

Added: kiwi-head/tools/burner/DeviceItem.h
===================================================================
--- kiwi-head/tools/burner/DeviceItem.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/DeviceItem.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,39 @@
+#ifndef __DEVICE_ITEM_H__
+#define __DEVICE_ITEM_H__
+
+#include &lt;QWidget&gt;
+
+// This class represents the devices we find
+// TODO: This should be subclassed for the different platforms, as they need different identifying details
+class DeviceItem
+{
+public:
+    DeviceItem() {};
+
+    QString getPath() { return mPath; }
+    QString getVendorString() { return mVendorString; }
+    QString getModelString() { return mModelString; }
+    QString getDisplayString() { return mDisplayString; }
+    QString getUDI() { return mUDI; }
+    qint64 getSize() { return mSize; }
+    bool isRemovable() { return mIsRemovable; }
+
+    void setPath(QString path) { mPath = path; }
+    void setVendorString(QString vendor) { mVendorString = vendor; }
+    void setModelString(QString modelString) { mModelString = modelString; }
+    void setDisplayString(QString str) { mDisplayString = str; }
+    void setSize(qint64 size) { mSize = size; }
+    void setUDI(QString UDI) { mUDI = UDI; }
+    void setIsRemovable(bool removable) { mIsRemovable = removable; }
+
+private:
+    QString mPath, // Path to the device (example: /dev/sdb)
+            mUDI, // UDI for HAL
+            mVendorString, // The vendor found in /proc/scsi/usb-storage/[id]
+            mModelString, // the model string that has not had non-word characters replaced with &quot;_&quot;
+            mDisplayString; // The string used in the pulldown device selection display
+    qint64 mSize;
+    bool mIsRemovable;
+};
+
+#endif

Added: kiwi-head/tools/burner/MainWindow.cpp
===================================================================
--- kiwi-head/tools/burner/MainWindow.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/MainWindow.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,282 @@
+#include &lt;QtGui&gt;
+#include &lt;QFileDialog&gt;
+#include &lt;QProgressDialog&gt;
+
+#include &quot;MainWindow.h&quot;
+
+MainWindow::MainWindow (const char *cmddevice, const char *cmdfile, bool unsafe, QWidget *parent)
+ : QWidget(parent)
+{
+    int dev = -1;
+
+    QVBoxLayout *mainLayout;
+    QStackedLayout *logoLayout;
+    QGridLayout *bottomLayout;
+
+    QHBoxLayout *pathSizeLayout;
+    QPushButton *writeButton;
+    
+
+    file = QString();
+
+    // Set the background colour
+    QPalette pal = palette();
+    pal.setColor(QPalette::Window, Qt::white);
+    setPalette(pal);
+
+    // The upper left studio logo
+    imageLabel = new CustomLabel(this);
+    imageLabel-&gt;setBackgroundRole(QPalette::Base);
+    imageLabel-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
+    imageLabel-&gt;setScaledContents(false);
+    QImage image(&quot;:logo-empty.png&quot;);
+    imageLabel-&gt;setPixmap(QPixmap::fromImage(image));
+    imageLabel-&gt;setAlignment(Qt::AlignCenter);
+
+    fileSize = new QLabel(&quot;      &quot;);
+    fileLabel = new QLabel(&quot;     &quot;);
+    directive = new CustomLabel(this);
+    directive-&gt;setText(tr(&quot;Drag appliance image here\n or click to select.&quot;));
+    directive-&gt;setAlignment(Qt::AlignCenter);
+    deviceComboBox = new QComboBox;
+
+    writeButton = new QPushButton(tr(&quot;Copy&quot;));
+    connect(writeButton, SIGNAL(clicked()), this, SLOT(write()));
+
+    // These layouts are kind of a mess
+    logoLayout = new QStackedLayout;
+    logoLayout-&gt;setStackingMode(QStackedLayout::StackAll);
+    logoLayout-&gt;addWidget(directive);
+    logoLayout-&gt;addWidget(imageLabel);
+
+    pathSizeLayout = new QHBoxLayout;
+    pathSizeLayout-&gt;addWidget(fileLabel, Qt::AlignLeft);
+    pathSizeLayout-&gt;addWidget(fileSize, Qt::AlignLeft);
+
+    bottomLayout = new QGridLayout;
+    bottomLayout-&gt;addLayout(pathSizeLayout, 0, 0);
+
+    mainLayout = new QVBoxLayout;
+    mainLayout-&gt;addLayout(logoLayout, Qt::AlignHCenter);
+
+    QGridLayout *comboLayout = new QGridLayout;
+    comboLayout-&gt;addLayout(bottomLayout, 0, 0, Qt::AlignBottom);
+    comboLayout-&gt;addWidget(deviceComboBox, 1,0);
+    comboLayout-&gt;addWidget(writeButton, 1, 1, Qt::AlignRight);
+    mainLayout-&gt;addLayout(comboLayout);
+
+    setLayout(mainLayout);
+    setWindowTitle(tr(VERSION));
+
+    // Setup the platform-specific bits
+#if defined (Q_OS_LINUX)
+    platform = new PlatformLinux;
+#elif defined (Q_OS_WIN)
+    platform = new PlatformWindows;
+#elif defined (Q_OS_MAC)
+    platform = new PlatformMacintosh;
+#else
+    QMessageBox msgBox;
+    msgBox.setText(tr(&quot;Your platform is not currently supported.&quot;));
+    msgBox.exec();
+    qFatal(&quot;Unsupported platform.&quot;);
+#endif
+
+    platform-&gt;findDevices(unsafe);
+
+    // Now that we've found the devices, add them to the combo box
+    QLinkedList&lt;DeviceItem *&gt; list = platform-&gt;getDeviceList();
+    QLinkedList&lt;DeviceItem *&gt;::iterator i;
+    for (i = list.begin(); i != list.end(); ++i)
+    {
+        if (!(*i)-&gt;getPath().isEmpty())
+            deviceComboBox-&gt;addItem((*i)-&gt;getDisplayString(), 0);
+        if (cmddevice != NULL)
+            if ((*i)-&gt;getPath().compare(cmddevice) == 0)
+                dev = deviceComboBox-&gt;findText((*i)-&gt;getDisplayString(), 0);
+    }
+
+    if (dev != -1)
+        deviceComboBox-&gt;setCurrentIndex(dev);
+
+    if (cmdfile != NULL)
+    {
+        if(QFile(cmdfile).exists())
+        {
+          setFile(cmdfile);
+          setSizeLabel(cmdfile);
+        }
+    }
+
+
+    resize(600, 400);
+    setAcceptDrops(true);
+    centerWindow();
+}
+
+void
+MainWindow::centerWindow()
+{
+    QDesktopWidget *desktop = QApplication::desktop();
+    
+    int screenWidth, width; 
+    int screenHeight, height;
+    int x, y;
+    int screen = desktop-&gt;screenNumber(this);
+    QSize windowSize;
+ 
+    screenWidth = desktop-&gt;screenGeometry(screen).width();
+    screenHeight = desktop-&gt;screenGeometry(screen).height();
+    
+    windowSize = size();
+    width = windowSize.width(); 
+    height = windowSize.height();
+    
+    x = (screenWidth - width) / 2;
+    y = (screenHeight - height) / 2;
+    y -= 50;
+    
+    move ( x, y );
+}
+
+void
+MainWindow::selectImage()
+{
+    QString fileName = QFileDialog::getOpenFileName(this,
+                        tr(&quot;Open Image&quot;),
+                        QDir::currentPath(),
+                        tr(&quot;Image Files (*.raw)&quot;));
+    if (!fileName.isEmpty())
+    {
+        setFile(fileName);
+        setSizeLabel(fileName);
+    }
+
+    return;
+}
+
+void
+MainWindow::setSizeLabel(QString fileName) 
+{
+    QFile filecheck(fileName);
+    if(filecheck.exists())
+    {
+        int size = filecheck.size() / (1024*1024);
+        fileSize-&gt;setText(&quot;(&lt;b&gt;&quot; + QString::number(size) + &quot; MB&lt;/b&gt;)&quot; );
+    }
+    return;
+}
+
+void MainWindow::dragEnterEvent(QDragEnterEvent *event)
+{
+#if 0
+    qDebug() &lt;&lt; event-&gt;mimeData()-&gt;text();
+    qDebug() &lt;&lt; event-&gt;mimeData()-&gt;formats();
+    qDebug() &lt;&lt; event-&gt;mimeData()-&gt;urls();
+#endif
+    if (event-&gt;mimeData()-&gt;hasFormat(&quot;text/uri-list&quot;))
+        event-&gt;acceptProposedAction();
+
+}
+
+void MainWindow::dropEvent(QDropEvent *event)
+{
+    QString file = event-&gt;mimeData()-&gt;urls()[0].toLocalFile();
+    setFile(file);
+    setSizeLabel(file);
+}
+
+void MainWindow::setFile(QString newFile)
+{
+    file = newFile;
+    QImage image(&quot;:logo-mini.png&quot;);
+    imageLabel-&gt;setPixmap(QPixmap::fromImage(image));
+    fileLabel-&gt;setText(&quot;&lt;b&gt;Selected:&lt;/b&gt; &quot; + file);
+    directive-&gt;setText(&quot;&quot;);
+}
+
+void
+MainWindow::write()
+{
+    if (file.isEmpty())
+    {
+        QMessageBox msgBox;
+        msgBox.setText(tr(&quot;Please select an image to use.&quot;));
+        msgBox.exec();
+        return;
+    }
+
+    DeviceItem *item = NULL;
+    QLinkedList&lt;DeviceItem *&gt; list = platform-&gt;getDeviceList();
+
+    QLinkedList&lt;DeviceItem *&gt;::iterator i;
+    for (i = list.begin(); i != list.end(); ++i)
+    {
+        if ((*i)-&gt;getDisplayString() == deviceComboBox-&gt;currentText())
+            item = (*i);
+    }
+
+    if (item != NULL)
+    {
+        if (platform-&gt;isMounted(item-&gt;getUDI()))
+        {
+            // We won't let them nuke a mounted device
+            QMessageBox msgBox;
+            msgBox.setText(tr(&quot;This device is already mounted.  Would you like me to attempt to unmount it?&quot;));
+            msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
+            msgBox.setDefaultButton(QMessageBox::No);
+            switch (msgBox.exec())
+            {
+                case QMessageBox::Yes:
+                {
+                    if (!platform-&gt;unmountDevice(item-&gt;getUDI()))
+                    {
+                        QMessageBox failedBox;
+                        failedBox.setText(tr(&quot;Unmount failed.  I will not write to this device.&quot;));
+                        failedBox.exec();
+                        return;
+                    }
+                    break;
+                }
+                case QMessageBox::No:
+                    return;
+                default:
+                    break;
+            }
+        }
+
+        QMessageBox msgBox;
+        QString messageString;
+        if (item-&gt;isRemovable())
+            messageString = tr(&quot;This will overwrite the contents of &quot;) + item-&gt;getPath() + tr(&quot;.  Are you sure you want to continue?&quot;);
+        else
+            messageString = item-&gt;getPath() + tr(&quot; is a non-removable hard drive, and this will overwrite the contents.  Are you &lt;b&gt;sure&lt;/b&gt; you want to continue?&quot;);
+        msgBox.setText(messageString);
+        msgBox.setStandardButtons(QMessageBox::Cancel | QMessageBox::Ok);
+        msgBox.setDefaultButton(QMessageBox::Cancel);
+        switch (msgBox.exec())
+        {
+            case QMessageBox::Ok:
+            {
+                platform-&gt;writeData(item-&gt;getPath(), file, item-&gt;getSize());
+                break;
+            }
+            default:
+                break;
+        }
+    }
+}
+
+CustomLabel::CustomLabel(QWidget* parent)
+ : QLabel(parent)
+{
+}
+
+void CustomLabel::mousePressEvent(QMouseEvent *event)
+{
+    if (event-&gt;button() == Qt::LeftButton)
+    {
+        MainWindow *window = (MainWindow *) parentWidget();
+        window-&gt;selectImage();
+    }
+}

Added: kiwi-head/tools/burner/MainWindow.h
===================================================================
--- kiwi-head/tools/burner/MainWindow.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/MainWindow.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,67 @@
+#ifndef __MAIN_WINDOW_H__
+#define __MAIN_WINDOW_H__
+
+#include &lt;QtGui&gt;
+#include &lt;QWidget&gt;
+
+#include &quot;Platform.h&quot;
+
+#if defined (Q_OS_LINUX)
+#include &quot;PlatformLinux.h&quot;
+#endif
+
+#if defined (Q_OS_WIN)
+#include &quot;PlatformWindows.h&quot;
+#endif
+
+#if defined (Q_OS_MAC)
+#include &quot;PlatformMac.h&quot;
+#endif
+
+#include &quot;DeviceItem.h&quot;
+#define VERSION &quot;SUSE Studio Image Writer 1.0&quot;
+
+class MainWindow : public QWidget
+{
+    Q_OBJECT
+
+public:
+    MainWindow(const char *cmddevice, const char *cmdfile, bool unsafe = false, QWidget *parent = 0);
+    void selectImage();
+
+private slots:
+    void write();
+
+protected:
+    void dragEnterEvent(QDragEnterEvent *event);
+    void dropEvent(QDropEvent *event);
+    void setSizeLabel(QString fileName);
+
+private:
+    void findDevices();
+    void setFile(QString newFile);
+    void divineMeaning(QString path);
+    void divineFurther(DeviceItem *item);
+    bool isMounted(QString path);
+    void writeData(QString path);
+    void centerWindow();
+
+    QLabel *imageLabel, *directive;
+    QString file;
+    QLabel *fileSize, *fileLabel;
+    QComboBox *deviceComboBox;
+    Platform *platform;
+};
+
+// Rather than grabbing a mouse click for the entire window, just grab it for the part
+// that contains the graphics
+class CustomLabel : public QLabel
+{
+public:
+    CustomLabel(QWidget* parent);
+
+protected:
+    void mousePressEvent(QMouseEvent *event);
+};
+
+#endif

Added: kiwi-head/tools/burner/Platform.cpp
===================================================================
--- kiwi-head/tools/burner/Platform.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/Platform.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,5 @@
+#include &quot;Platform.h&quot;
+
+Platform::Platform()
+{
+}
\ No newline at end of file

Added: kiwi-head/tools/burner/Platform.h
===================================================================
--- kiwi-head/tools/burner/Platform.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/Platform.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,26 @@
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#include &lt;QtCore&gt;
+
+#include &quot;DeviceItem.h&quot;
+
+// Virtual class for platform-specific operations
+class Platform
+{
+
+public:
+    Platform();
+    virtual void findDevices(bool unsafe = false) = 0;
+    virtual bool isMounted(QString path) = 0;
+    virtual bool unmountDevice(QString path) = 0;
+    virtual void writeData(QString path, QString fileName, qint64 deviceSize) = 0;
+
+    QLinkedList&lt;DeviceItem *&gt; getDeviceList() { return itemList; }
+
+protected:
+    DeviceItem *pDevice;
+    QLinkedList&lt;DeviceItem *&gt; itemList;
+};
+
+#endif

Added: kiwi-head/tools/burner/PlatformLinux.cpp
===================================================================
--- kiwi-head/tools/burner/PlatformLinux.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformLinux.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,339 @@
+#include &lt;sys/mount.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;QtCore&gt;
+#include &lt;QtGui&gt;
+#include &lt;QDir&gt;
+#include &lt;QProgressDialog&gt;
+#include &lt;QtDBus&gt;
+
+#include &quot;DeviceItem.h&quot;
+#include &quot;PlatformLinux.h&quot;
+
+#define BLOCKSIZE 1048576
+
+// Figure out which devices we should allow a user to write to.
+void
+PlatformLinux::findDevices(bool unsafe)
+{
+    char **drives;
+    char *device, *product, *vendor;
+    int drive_count, i;
+    long long size;
+    bool isRemovable = true;
+    LibHalContext *context;
+
+    if ((context = initHal()) == NULL)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;Could not initialize HAL.&quot;));
+        msgBox.exec();
+        return;
+    }
+
+    // We want to only write to USB drives, unless the user specifies
+    // the unsafe flag on the command line
+    if (unsafe)
+        drives = libhal_manager_find_device_string_match(context,
+                                                        &quot;storage.drive_type&quot;,
+                                                        &quot;disk&quot;,
+                                                        &amp;drive_count,
+                                                        NULL);
+    else
+        drives = libhal_manager_find_device_string_match(context,
+                                                        &quot;storage.bus&quot;,
+                                                        &quot;usb&quot;,
+                                                        &amp;drive_count,
+                                                        NULL);
+
+    for(i = 0; i &lt; drive_count; i++)
+    {
+        device = libhal_device_get_property_string(context,
+                                                  drives[i],
+                                                  &quot;block.device&quot;,
+                                                  NULL);
+        if (device == NULL)
+            continue;
+
+        product = libhal_device_get_property_string(context,
+                                                    drives[i],
+                                                    &quot;info.product&quot;,
+                                                    NULL);
+
+        vendor = libhal_device_get_property_string(context,
+                                                   drives[i],
+                                                   &quot;info.vendor&quot;,
+                                                   NULL);
+        size = libhal_device_get_property_uint64(context,
+                                                 drives[i],
+                                                 &quot;storage.removable.media_size&quot;,
+                                                 NULL);
+        
+        isRemovable = libhal_device_get_property_bool(context,
+                                                      drives[i],
+                                                      &quot;storage.removable&quot;,
+                                                      NULL);
+
+        DeviceItem *devItem = new DeviceItem;
+        devItem-&gt;setUDI(drives[i]);
+        devItem-&gt;setPath(device);
+        devItem-&gt;setIsRemovable(isRemovable);
+        devItem-&gt;setSize(size);
+
+        if (!strcmp(product, &quot;&quot;))
+            devItem-&gt;setModelString(&quot;&quot;);
+        else
+            devItem-&gt;setModelString(product);
+
+        if (!strcmp(vendor, &quot;&quot;))
+#ifdef KIOSKHACK
+            devItem-&gt;setVendorString(&quot;SUSE Studio USB Key&quot;);
+#else
+            devItem-&gt;setVendorString(&quot;Unknown Device&quot;);
+#endif
+        else
+            devItem-&gt;setVendorString(vendor);
+
+        QString newDisplayString = QString(&quot;%1 %2 - %3 (%4 MB)&quot;).arg(devItem-&gt;getVendorString()).arg(devItem-&gt;getModelString()).arg(devItem-&gt;getPath()).arg(devItem-&gt;getSize() / 1048576);
+        devItem-&gt;setDisplayString(newDisplayString);
+
+#ifdef KIOSKHACK
+        // VERY VERY VERY VERY VERY  ugly hack for kiosk: ignore hard disks bigger than 100GB
+        if((devItem-&gt;getSize() / 1048576) &lt; 200000) 
+#endif
+            itemList &lt;&lt; devItem;
+
+        libhal_free_string(device);
+        libhal_free_string(product);
+        libhal_free_string(vendor);
+    }
+
+    libhal_free_string_array(drives);
+    libhal_ctx_shutdown(context, NULL);
+    libhal_ctx_free(context);
+
+    return;
+}
+
+LibHalContext *
+PlatformLinux::initHal()
+{
+    DBusError error;
+    DBusConnection *dbus_connection;
+    LibHalContext *context;
+    char **devices;
+    int device_count;
+
+    if ((context = libhal_ctx_new()) == NULL)
+        return(NULL);
+
+    dbus_error_init(&amp;error);
+    dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &amp;error);
+    if(dbus_error_is_set(&amp;error))
+    {
+            dbus_error_free(&amp;error);
+            libhal_ctx_free(context);
+            return(NULL);
+    }
+
+    libhal_ctx_set_dbus_connection(context, dbus_connection);
+    if(!libhal_ctx_init(context, &amp;error))
+    {
+            dbus_error_free(&amp;error);
+            libhal_ctx_free(context);
+            return(NULL);
+    }
+
+    devices = libhal_get_all_devices(context, &amp;device_count, NULL);
+    if(devices == NULL)
+    {
+            libhal_ctx_shutdown(context, NULL);
+            libhal_ctx_free(context);
+            context = NULL;
+            return(NULL);
+    }
+
+    libhal_free_string_array(devices);
+    return(context);
+}
+
+bool
+PlatformLinux::isMounted(QString path)
+{
+    LibHalContext *context;
+    LibHalVolume *halVolume;
+    bool ret = false;
+    char **volumes;
+    int volumeCount, i;
+    
+    if ((context = initHal()) == NULL)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;Could not initialize HAL.&quot;));
+        msgBox.exec();
+        return false;
+    }
+    
+    volumes = libhal_manager_find_device_string_match(context,
+                                                      &quot;info.parent&quot;,
+                                                      path.toLatin1().data(),
+                                                      &amp;volumeCount,
+                                                      NULL);
+    for(i = 0; i &lt; volumeCount; i++)
+    {
+        halVolume = libhal_volume_from_udi(context, volumes[i]);
+        // I don't really know if this is better than just looking for the volume.is_mounted property,
+        // might as well be on the safe side.
+        if (libhal_volume_is_mounted(halVolume))
+            ret = true;
+        
+        libhal_volume_free(halVolume);
+    }
+
+    libhal_free_string_array(volumes);
+    libhal_ctx_shutdown(context, NULL);
+    libhal_ctx_free(context);
+    return ret;
+}
+
+bool
+PlatformLinux::unmountDevice (QString path)
+{
+    LibHalContext *context;
+    bool ret = true;
+    char **volumes;
+    int volumeCount, i;
+    
+    if ((context = initHal()) == NULL)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;Could not initialize HAL.&quot;));
+        msgBox.exec();
+        return false;
+    }
+    
+    volumes = libhal_manager_find_device_string_match(context,
+                                                      &quot;info.parent&quot;,
+                                                      path.toLatin1().data(),
+                                                      &amp;volumeCount,
+                                                      NULL);
+    for(i = 0; i &lt; volumeCount; i++)
+    {
+        if (!performUnmount(volumes[i]))
+            ret = false;
+    }
+
+    libhal_free_string_array(volumes);
+    libhal_ctx_shutdown(context, NULL);
+    libhal_ctx_free(context);
+    return ret;
+}
+
+bool
+PlatformLinux::performUnmount(QString udi)
+{
+    bool ret = true;
+    QDBusConnection connection = QDBusConnection::systemBus();
+    QDBusMessage message, reply;
+    QList&lt;QVariant&gt; options;
+
+    message = QDBusMessage::createMethodCall(&quot;org.freedesktop.Hal&quot;, udi, &quot;org.freedesktop.Hal.Device.Volume&quot;, &quot;Unmount&quot;);
+    message &lt;&lt; QStringList();
+    reply = connection.call(message);
+
+    if (reply.type() == QDBusMessage::ErrorMessage)
+    {
+        qDebug() &lt;&lt; &quot;Failure: &quot; &lt;&lt;  reply;
+        ret = false;
+    }
+
+    return ret;
+}
+
+// TODO make this routine not be shit
+void
+PlatformLinux::writeData(QString path, QString fileName, qint64 deviceSize)
+{
+    QFileInfo info(fileName);
+    qint64 realSize = info.size();
+
+    if (realSize &gt; deviceSize)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;The image you are trying to write is larger than your USB stick.&quot;));
+        msgBox.exec();
+        return;
+    }
+
+    qint64 i = 0;
+    char *buffer = (char *) malloc(BLOCKSIZE);
+    qint64 read = 0;
+    qint64 written = 0;
+
+    int ofd = -1;
+    int ifd = -1;
+
+    int percentWritten, megsWritten, megsTotal;
+    megsTotal = realSize / 1048576;
+
+    // Open the file to read from 
+    if ((ifd = ::open(fileName.toLocal8Bit().data(), O_RDONLY)) == -1)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;Couldn't open &quot;) + fileName);
+        msgBox.exec();
+        return;
+    }
+
+    if ((ofd = ::open(path.toLocal8Bit().data(), O_WRONLY|O_SYNC)) == -1)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;Couldn't open &quot;) + path + &quot;: &quot; + strerror(errno));
+        msgBox.exec();
+        ::close(ifd);
+        return;
+    }
+
+    QProgressDialog progress(&quot; &quot;, &quot;Cancel&quot;, 0, 100);
+    progress.setMinimumDuration(0);
+    progress.setWindowModality(Qt::WindowModal);
+    progress.setValue(100);
+    progress.setWindowTitle(QObject::tr(&quot;Writing&quot;));
+
+    for (i = 0; i &lt;= realSize; i++)
+    {
+        if ((read = ::read(ifd, buffer, BLOCKSIZE)) == -1)
+        {
+            QMessageBox msgBox;
+            msgBox.setText(QObject::tr(&quot;Read failure&quot;));
+            msgBox.exec();
+            break;
+        }
+
+        written = ::write(ofd, buffer, read);
+        if (written == -1)
+        {
+            QMessageBox msgBox;
+            msgBox.setText(QObject::tr(&quot;Write failure&quot;));
+            msgBox.exec();
+            break;
+        }
+
+        i += written;
+        percentWritten = (i*100)/realSize;
+        megsWritten = i / 1048576;
+        progress.setValue(percentWritten);
+        progress.setLabelText(QObject::tr(&quot;Written %1MB out of %2MB&quot;).arg(megsWritten).arg(megsTotal));
+        qApp-&gt;processEvents();
+
+        if (progress.wasCanceled())
+             break;
+     }
+    ::close(ofd);
+    ::close(ifd);
+    free(buffer);
+    progress.setValue(100);
+}

Added: kiwi-head/tools/burner/PlatformLinux.h
===================================================================
--- kiwi-head/tools/burner/PlatformLinux.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformLinux.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,27 @@
+#ifndef __PLATFORM_LINUX_H__
+#define __PLATFORM_LINUX_H__
+
+#include &lt;hal/libhal.h&gt;
+#include &lt;hal/libhal-storage.h&gt;
+
+#include &quot;Platform.h&quot;
+
+class PlatformLinux : public Platform
+{
+public:
+    PlatformLinux() { };
+    void findDevices(bool unsafe = false);
+    bool isMounted(QString path);
+    void writeData(QString path, QString fileName, qint64 deviceSize);
+    bool unmountDevice(QString path);
+
+private:
+    LibHalContext *initHal();
+    bool performUnmount(QString udi);
+
+public slots:
+    void tick(qint64 lastWritten, qint64 bytesWritten);
+};
+
+
+#endif

Added: kiwi-head/tools/burner/PlatformMac.cpp
===================================================================
--- kiwi-head/tools/burner/PlatformMac.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformMac.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,155 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/param.h&gt;
+#include &lt;sys/mount.h&gt;
+
+#include &lt;fcntl.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;QtGui&gt;
+#include &lt;CoreFoundation/CoreFoundation.h&gt;
+#include &lt;IOKit/IOKitLib.h&gt;
+#include &lt;IOKit/IOCFPlugIn.h&gt; 
+#include &lt;IOKit/IOBSD.h&gt; 
+
+#include &quot;PlatformMac.h&quot;
+#include &quot;DeviceItem.h&quot;
+
+#define BLOCKSIZE 1048576
+
+void
+PlatformMacintosh::findDevices()
+{
+    kern_return_t ret;
+    io_registry_entry_t entry;
+    io_iterator_t iterator;
+    io_name_t devName;
+    CFStringRef bsdname;
+    CFNumberRef data;
+    SInt64 capacity = 0;
+
+    // Search for USB devices
+    CFMutableDictionaryRef dict = NULL;
+    dict = IOServiceMatching(&quot;IOUSBDevice&quot;);
+
+    ret = IOServiceGetMatchingServices(kIOMasterPortDefault, dict, &amp;iterator);
+
+    entry = IOIteratorNext(iterator);
+    while (entry)
+    {
+        bsdname = (CFStringRef) IORegistryEntrySearchCFProperty(entry, kIOServicePlane, CFSTR(kIOBSDNameKey), kCFAllocatorDefault, kIORegistryIterateRecursively);
+        data = (CFNumberRef) IORegistryEntrySearchCFProperty(entry, kIOServicePlane, CFSTR(&quot;Size&quot;), kCFAllocatorDefault, kIORegistryIterateRecursively);
+        if (bsdname) // If we can't look up &quot;BSD name&quot; then it isn't a removable device
+        {
+            IORegistryEntryGetName(entry, devName);
+            DeviceItem *devItem = new DeviceItem;
+            
+            if (data)
+            {
+                CFNumberGetValue(data, kCFNumberSInt64Type, &amp;capacity );
+                devItem-&gt;setSize(capacity);
+            }
+            devItem-&gt;setVendorString(devName);
+
+            QString newDevString = QString(&quot;/dev/%1&quot;).arg(CFStringGetCStringPtr(bsdname, kCFStringEncodingMacRoman));
+            devItem-&gt;setPath(newDevString);
+
+            QString newDisplayString = QString(&quot;%1 - %2 (%3 MB)&quot;).arg(devItem-&gt;getVendorString()).arg(devItem-&gt;getPath()).arg(devItem-&gt;getSize() / 1048576);
+            devItem-&gt;setDisplayString(newDisplayString);
+            itemList &lt;&lt; devItem;
+        }
+        entry = IOIteratorNext(iterator);
+    }
+}
+ 
+bool
+PlatformMacintosh::isMounted(QString path)
+{
+    // This doesn't actually work
+    // TODO: Figure out how to make it work
+
+    if (unmount(path.toLatin1().data(), 0) == -1)
+        return true;
+
+    return false;
+}
+
+void
+PlatformMacintosh::writeData(QString path, QString fileName, qint64 deviceSize)
+{
+    QFileInfo info(fileName);
+    qint64 realSize = info.size();
+
+    if (realSize &gt; deviceSize)
+    {
+        QMessageBox msgBox;
+        msgBox.setText(QObject::tr(&quot;The image you are trying to write is larger than your USB stick.&quot;));
+        msgBox.exec();
+        return;
+    }
+
+    qint64 i = 0;
+    char *buffer = (char *) malloc(BLOCKSIZE);
+    qint64 read = 0;
+    qint64 written = 0;
+
+    int ofd = -1;
+    int ifd = -1;
+
+    int percentWritten, megsWritten, megsTotal;
+    megsTotal = realSize / 1048576;
+
+    // Open the file to read from 
+    if ((ifd = ::open(fileName.toLocal8Bit().data(), O_RDONLY)) == -1)
+    {
+        qDebug() &lt;&lt; &quot;Couldn't open &quot; + fileName;
+        return;
+    }
+
+    if ((ofd = ::open(path.toLocal8Bit().data(), O_WRONLY|O_SYNC)) == -1)
+    {
+        // TODO complain
+        qDebug() &lt;&lt; &quot;Couldn't open &quot; + path + &quot;: &quot; + strerror(errno);
+        ::close(ifd);
+        return;
+    }
+
+    QProgressDialog progress(&quot; &quot;, &quot;Cancel&quot;, 0, 100);
+    progress.setMinimumDuration(0);
+    progress.setWindowModality(Qt::WindowModal);
+    progress.setValue(100);
+    progress.setWindowTitle(QObject::tr(&quot;Writing Image...&quot;));
+
+    for (i = 0; i &lt;= realSize; i++)
+    {
+        if ((read = ::read(ifd, buffer, BLOCKSIZE)) == -1)
+        {
+            qDebug() &lt;&lt; &quot;Uh oh&quot;;
+            break;
+        }
+
+        written = ::write(ofd, buffer, read);
+        if (written == -1)
+        {
+            qDebug() &lt;&lt; &quot;Hit a problem at &quot; &lt;&lt; i;
+            break;
+        }
+
+        i += written;
+        percentWritten = (i*100)/realSize;
+        megsWritten = i / 1048576;
+        progress.setValue(percentWritten);
+        progress.setLabelText(QObject::tr(&quot;Written %1MB out of %2MB&quot;).arg(megsWritten).arg(megsTotal));
+        qApp-&gt;processEvents();
+
+        if (progress.wasCanceled())
+             break;
+     }
+    ::close(ofd);
+    ::close(ifd);
+    free(buffer);
+    progress.setValue(100);
+
+    return;
+}
+

Added: kiwi-head/tools/burner/PlatformMac.h
===================================================================
--- kiwi-head/tools/burner/PlatformMac.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformMac.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,17 @@
+#ifndef __PLATFORM_MACINTOSH_H__
+#define __PLATFORM_MACINTOSH_H__
+
+#include &quot;Platform.h&quot;
+
+class PlatformMacintosh : public Platform
+{
+public:
+    PlatformMacintosh() { };
+    // Override the Platform functions
+    void findDevices();
+    bool isMounted(QString path);
+    void writeData(QString path, QString fileName, qint64 deviceSize);
+};
+
+#endif
+

Added: kiwi-head/tools/burner/PlatformWindows.cpp
===================================================================
--- kiwi-head/tools/burner/PlatformWindows.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformWindows.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,53 @@
+#include &lt;QtGui&gt;
+
+#include &quot;PlatformWindows.h&quot;
+
+#define NUM_HOST_CONTROLLER_CHECKS 10
+
+void
+PlatformWindows::findDevices()
+{
+    wchar_t controllerName[16];
+    int controllerNum;
+    HANDLE controllerHandle;
+
+    // There appear to be two ways of finding USB devices on Windows: iterate through
+    // a bunch of shit like &quot;\\.\HCD1&quot; and iterate using GUIDs.
+
+    // We have to do a trial and error method of finding the USB host controllers
+    // which pretty much means &quot;try to open every possible device name and see what happens&quot;.
+    // This may be sub-optimal.
+    for (controllerNum = 0; controllerNum &lt; NUM_HOST_CONTROLLER_CHECKS; controllerNum++)
+    {
+        wsprintf(controllerName, L&quot;\\\\.\\HCD%d&quot;, controllerNum);
+        controllerHandle = CreateFile(controllerName,
+                                      GENERIC_WRITE,
+                                      FILE_SHARE_WRITE,
+                                      NULL,
+                                      OPEN_EXISTING,
+                                      0,
+                                      NULL);
+
+        // Is the handler valid?
+        if (controllerHandle != INVALID_HANDLE_VALUE)
+        {
+            // Super, we found a controller.  Lets see what devices are attached...
+            examineController(controllerHandle);
+            CloseHandle(controllerHandle);
+        }
+    }
+
+    // TODO: GUID iteration
+}
+
+void
+PlatformWindows::examineController(HANDLE controllerHandle)
+{
+    return;
+}
+  
+bool
+PlatformWindows::isMounted(QString path) { return true; }
+
+void
+PlatformWindows::writeData(QString path, QString fileName, qint64 deviceSize) { return; }

Added: kiwi-head/tools/burner/PlatformWindows.h
===================================================================
--- kiwi-head/tools/burner/PlatformWindows.h	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/PlatformWindows.h	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,30 @@
+#ifndef __PLATFORM_WINDOWS_H__
+#define __PLATFORM_WINDOWS_H__
+
+#include &lt;windows.h&gt;
+#include &lt;basetyps.h&gt;
+#include &lt;winioctl.h&gt;
+#include &lt;setupapi.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;tchar.h&gt;
+
+#include &quot;Platform.h&quot;
+
+class PlatformWindows : public Platform
+{
+
+public:
+    PlatformWindows() { };
+    // Override the Platform functions
+    void findDevices();
+    bool isMounted(QString path);
+    void writeData(QString path, QString fileName, qint64 deviceSize);
+
+private:
+    void examineController(HANDLE controllerHandle);
+
+};
+
+
+#endif

Added: kiwi-head/tools/burner/README
===================================================================
--- kiwi-head/tools/burner/README	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/README	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,18 @@
+In order to compile, run
+qmake 
+to create the make file and then 
+
+make
+
+In order to compile in the kiosk hack (ignores hard disks &gt; 100GB in order to avoid flashing the kiosk's hard disk, unknown usb sticks as &quot;SUSE Studio&quot;), run
+qmake DEFINES+=KIOSKHACK
+to create the make file and then
+
+make
+
+in order to start burner with sudo, do the following:
+
+xhost +SI:localuser:root
+
+to allow root access to the current screen and then start the program with:
+sudo DISPLAY=:0 burner

Added: kiwi-head/tools/burner/imagewriter.pro
===================================================================
--- kiwi-head/tools/burner/imagewriter.pro	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/imagewriter.pro	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,35 @@
+######################################################################
+# Automatically generated by qmake (2.01a) Thu Oct 23 14:13:58 2008
+######################################################################
+
+TEMPLATE = app
+TARGET = 
+DEPENDPATH += .
+INCLUDEPATH += .
+
+# Input
+HEADERS += DeviceItem.h \
+           MainWindow.h \
+           Platform.h \
+           PlatformLinux.h \
+           PlatformWindows.h \
+           PlatformMac.h
+SOURCES += main.cpp MainWindow.cpp Platform.cpp
+unix {
+	exists (&quot;/usr/include/hal/libhal.h&quot;)
+	{
+		CONFIG += link_pkgconfig
+		PKGCONFIG += hal hal-storage
+	}
+}
+unix:SOURCES += PlatformLinux.cpp
+unix:CONFIG += qdbus
+macx:SOURCES += PlatformMac.cpp
+win32:SOURCES += PlatformWindows.cpp
+win32:SDKDIR = $$(WindowsSdkDir)
+win32:INCLUDEPATH += E:\WINDDK\3790.1830\inc\wxp $$quote($$SDKDIR\..\v6.0A\include)
+win32:LIBS += user32.lib
+win32:LIBPATH += $$quote($$SDKDIR\..\v6.0A\Lib)
+macx:CONFIG += x86 ppc
+macx:LIBS += -framework IOKit
+RESOURCES += imagewriter.qrc

Added: kiwi-head/tools/burner/imagewriter.qrc
===================================================================
--- kiwi-head/tools/burner/imagewriter.qrc	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/imagewriter.qrc	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,8 @@
+ &lt;!DOCTYPE RCC&gt;&lt;RCC version=&quot;1.0&quot;&gt;
+ &lt;qresource&gt;
+     &lt;file&gt;logo-mini.png&lt;/file&gt;
+ &lt;/qresource&gt;
+ &lt;qresource&gt;
+     &lt;file&gt;logo-empty.png&lt;/file&gt;
+ &lt;/qresource&gt;
+ &lt;/RCC&gt;

Added: kiwi-head/tools/burner/logo-empty.png
===================================================================
(Binary files differ)


Property changes on: kiwi-head/tools/burner/logo-empty.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: kiwi-head/tools/burner/logo-mini.png
===================================================================
(Binary files differ)


Property changes on: kiwi-head/tools/burner/logo-mini.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: kiwi-head/tools/burner/main.cpp
===================================================================
--- kiwi-head/tools/burner/main.cpp	2009-03-02 17:10:48 UTC (rev 1942)
+++ kiwi-head/tools/burner/main.cpp	2009-03-03 13:53:40 UTC (rev 1943)
@@ -0,0 +1,58 @@
+#include &lt;QApplication&gt;
+#include &quot;MainWindow.h&quot;
+
+#if defined (Q_OS_UNIX)
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/sysctl.h&gt;
+#endif
+
+int
+main (int argc, char *argv[])
+{
+    int c;
+    char *device = NULL;
+    char *file = NULL;
+    bool unsafe = false;
+#if defined(Q_OS_UNIX) 
+#ifndef KIOSKHACK
+    if (getuid() != 0)
+        qFatal(&quot;You must run this program as the root user.&quot;);
+#endif
+#endif
+
+    while ((c = getopt (argc, argv, &quot;vuhd:f:&quot;)) != -1)
+    {
+        switch (c)
+        {
+            case 'h':
+                fprintf(stdout, &quot;Usage:\t%s [-d &lt;device&gt;] [-f &lt;raw file&gt;] [-u] [-v]\n&quot;, argv[0]);
+                fprintf(stdout, &quot;Flashes a raw disk file to a device\n\n&quot;);
+                fprintf(stdout, &quot;-d &lt;device&gt;\t\tSpecify a device, for example: /dev/sdc\n&quot;);
+                fprintf(stdout, &quot;-f &lt;raw file\t\tSpecify the file to write\n&quot;);
+                fprintf(stdout, &quot;-u\t\t\tOperate in unsafe mode, listing all disks, not just removable ones\n&quot;);
+                fprintf(stdout, &quot;-v\t\t\tVersion and author information\n&quot;);
+                exit(0);
+            case 'u':
+                unsafe = true;
+                break;
+            case 'd':
+                device = strdup(optarg);
+                break;
+            case 'f':
+                file = strdup(optarg);
+                break;
+            case 'v':
+                fprintf(stdout, &quot;%s\nWritten by Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;\n&quot;, VERSION);
+                exit(0);
+                break;
+            default:
+                break;
+        }
+    }
+
+    QApplication app(argc, argv);
+    MainWindow window(device, file, unsafe);
+    window.show();
+    return app.exec();
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001064.html">[Kiwi-devel] r1942 - in kiwi-branches/KIWI-301-SuSE-11-1-Devel: doc	doc/LaTex modules rpm system/boot/ix86/oemboot
</A></li>
	<LI>Next message: <A HREF="001066.html">[Kiwi-devel] r1944 - kiwi-head/tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1065">[ date ]</a>
              <a href="thread.html#1065">[ thread ]</a>
              <a href="subject.html#1065">[ subject ]</a>
              <a href="author.html#1065">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
