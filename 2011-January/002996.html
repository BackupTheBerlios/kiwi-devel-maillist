<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch,	KIWI-374-SuSE-11-1-SLE-SP-Devel,	updated. 3eef1af9ae18d485e1a8401e4cc8cda3b987d5eb
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2011-January/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%0A%09KIWI-374-SuSE-11-1-SLE-SP-Devel%2C%0A%09updated.%203eef1af9ae18d485e1a8401e4cc8cda3b987d5eb&In-Reply-To=%3C20110124122340.1C393481290%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002995.html">
   <LINK REL="Next"  HREF="002997.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch,	KIWI-374-SuSE-11-1-SLE-SP-Devel,	updated. 3eef1af9ae18d485e1a8401e4cc8cda3b987d5eb</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%0A%09KIWI-374-SuSE-11-1-SLE-SP-Devel%2C%0A%09updated.%203eef1af9ae18d485e1a8401e4cc8cda3b987d5eb&In-Reply-To=%3C20110124122340.1C393481290%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch,	KIWI-374-SuSE-11-1-SLE-SP-Devel,	updated. 3eef1af9ae18d485e1a8401e4cc8cda3b987d5eb">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Mon Jan 24 13:23:39 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002995.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 696f4fee72f6539219d2b6f6028de61641b665a9
</A></li>
        <LI>Next message: <A HREF="002997.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch,	KIWI-374-SuSE-11-1-SLE-SP-Devel,	updated. a20a429596ae7187f93695fc45e041850ebb8391
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2996">[ date ]</a>
              <a href="thread.html#2996">[ thread ]</a>
              <a href="subject.html#2996">[ subject ]</a>
              <a href="author.html#2996">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, KIWI-374-SuSE-11-1-SLE-SP-Devel has been updated
       via  3eef1af9ae18d485e1a8401e4cc8cda3b987d5eb (commit)
      from  3f9c0b8845673e21fecb42523c2047fb38e29293 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3eef1af9ae18d485e1a8401e4cc8cda3b987d5eb
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Mon Jan 24 13:23:03 2011 +0100

    - added support for raid 1 (mirroring) for pxe images

-----------------------------------------------------------------------

Summary of changes:
diff --git a/modules/KIWIConfig.sh b/modules/KIWIConfig.sh
index 4e4970f..7d6fdd3 100644
--- a/modules/KIWIConfig.sh
+++ b/modules/KIWIConfig.sh
@@ -877,7 +877,7 @@ function suseStripInitrd {
 		/usr/lib*/hal /usr/lib*/*.a /usr/lib*/*.la /usr/lib*/librpm*
 		/usr/lib*/libpanel* /usr/lib*/libmenu* /usr/src/packages/RPMS
 		/usr/lib*/X11 /var/X11R6 /usr/share/X11 /etc/X11
-		/usr/lib*/xorg /usr/lib*/libidn* /usr/share/locale-bundle
+		/usr/lib*/xorg /usr/share/locale-bundle
 		/etc/ppp /etc/xdg /etc/NetworkManager /lib*/YaST /lib*/security
 		/lib*/mkinitrd/boot /lib*/mkinitrd/dev /lib*/mkinitrd/scripts
 		/lib*/mkinitrd/setup
@@ -935,8 +935,7 @@ function suseStripInitrd {
 		tune2fs swapon swapoff shutdown sfdisk resize_reiserfs
 		reiserfsck reboot halt pivot_root modprobe modinfo rmmod
 		mkswap mkinitrd mkreiserfs mkfs.cramfs
-		losetup ldconfig insmod init ifconfig fdisk e2fsck fsck.ext2
-		fsck.ext3 fsck.ext4 dhcpcd mkfs.ext2 mkfs.ext3 mkfs.ext4
+		losetup ldconfig insmod init ifconfig fdisk e2fsck dhcpcd 
 		depmod atftpd klogconsole hwinfo xargs wc tail tac readlink
 		mkfifo md5sum head expr file free find env du dirname cut
 		column chroot atftp tr host test printf mount dd uname umount
@@ -953,7 +952,7 @@ function suseStripInitrd {
 		pvchange pvresize pvscan vgscan vgchange vgextend vgdisplay
 		lvchange lvresize lvextend lvcreate grub dcounter tty
 		dmsetup dialog awk gawk clicfs cryptsetup clear blkid fbiterm
-		gettext diff bc utimer cmp busybox kexec setterm
+		gettext diff bc utimer cmp busybox kexec setterm mdadm yes
 	&quot;
 	tools=&quot;$tools $@&quot;
 	for path in /sbin /usr/sbin /usr/bin /bin;do
diff --git a/modules/KIWILinuxRC.sh b/modules/KIWILinuxRC.sh
index 83faef0..d4fb83b 100644
--- a/modules/KIWILinuxRC.sh
+++ b/modules/KIWILinuxRC.sh
@@ -1142,6 +1142,9 @@ function setupBootLoaderGrub {
 	#--------------------------------------
 	local diskByID=`getDiskID $rdev`
 	local swapByID=`getDiskID $swap`
+	if [ ! -z &quot;$RAID&quot; ];then
+		diskByID=$imageDevice
+	fi
 	#======================================
 	# check for boot image .profile
 	#--------------------------------------
@@ -5063,6 +5066,21 @@ function dn {
 	echo $part
 }
 #======================================
+# nd
+#--------------------------------------
+function nd {
+	# /.../
+	# print the number of the disk device according to the
+	# device node name. 
+	# ----
+	local part=$(getDiskDevice $1)
+	local part_new=$(echo $part | sed -e 's@\(^.*\)p\(.*$\)@\2@')
+	if [ $part = $part_new ];then
+		part_new=$(echo $part | sed -e 's@\(^.*\)\([0-9].*$\)@\2@')
+	fi
+	echo $part_new
+}
+#======================================
 # runInteractive
 #--------------------------------------
 function runInteractive {
@@ -5306,7 +5324,380 @@ function SAPStartMediaChanger {
 	test -e /tmp/runme_at_boot &amp;&amp; mv /tmp/runme_at_boot $runme
 	test -e /tmp/install.inf &amp;&amp; mv /tmp/install.inf $ininf
 }
-
+#======================================
+# pxeSwapDevice
+#--------------------------------------
+function pxeSwapDevice {
+	local field=0
+	local count=0
+	local device
+	local IFS=&quot;,&quot;
+	for i in $PART;do
+		field=0
+		count=$((count + 1))
+		IFS=&quot;;&quot; ; for n in $i;do
+		case $field in
+			0) partSize=$n   ; field=1 ;;
+			1) partID=$n     ; field=2 ;;
+			2) partMount=$n;
+		esac
+		done
+		if test $partID = &quot;82&quot; -o $partID = &quot;S&quot;;then
+			device=$(ddn $DISK $count)
+			waitForStorageDevice $device
+			echo $device
+			return
+		fi
+	done
+}
+#======================================
+# pxeBootDevice
+#--------------------------------------
+function pxeBootDevice {
+	local field=0
+	local count=0
+	local device
+	local IFS=&quot;,&quot;
+	for i in $PART;do
+		field=0
+		count=$((count + 1))
+		IFS=&quot;;&quot; ; for n in $i;do
+		case $field in
+			0) partSize=$n   ; field=1 ;;
+			1) partID=$n     ; field=2 ;;
+			2) partMount=$n;
+		esac
+		done
+		if [ $partMount = &quot;/boot&quot; ];then
+			device=$(ddn $DISK $count)
+			waitForStorageDevice $device
+			echo $device
+			return
+		fi
+	done
+}
+#======================================
+# callPartitioner
+#--------------------------------------
+function callPartitioner {
+	local input=$1
+	if [ $PARTITIONER = &quot;sfdisk&quot; ];then
+		Echo &quot;Repartition the disk according to real geometry [ fdisk ]&quot;
+		local pstart=$(checkFDiskFirstSector $imageDiskDevice)
+		fdisk $imageDiskDevice &lt; $input 1&gt;&amp;2
+		if test $? != 0; then
+			systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
+		fi
+		local pstopp_new=$(checkFDiskEndSector   $imageDiskDevice)
+		local pstart_new=$(checkFDiskFirstSector $imageDiskDevice)
+		if [ $pstart_new -ne $pstart ];then
+			local fixpart=/part.input-fixupStartSector
+			local numpdevs=$(fdisk -ul $imageDiskDevice | grep '^/dev/' | wc -l)
+			echo &quot;d&quot;          &gt; $fixpart
+			if [ $numpdevs -gt 1 ];then
+				echo &quot;1&quot;     &gt;&gt; $fixpart
+			fi
+			echo &quot;n&quot;         &gt;&gt; $fixpart
+			echo &quot;p&quot;         &gt;&gt; $fixpart
+			echo &quot;1&quot;         &gt;&gt; $fixpart
+			echo $pstart     &gt;&gt; $fixpart
+			echo $pstopp_new &gt;&gt; $fixpart
+			echo &quot;w&quot;         &gt;&gt; $fixpart
+			echo &quot;q&quot;         &gt;&gt; $fixpart
+			fdisk -u $imageDiskDevice &lt; $fixpart 1&gt;&amp;2
+			if test $? != 0; then
+				systemException &quot;Failed to fix partition table&quot; &quot;reboot&quot;
+			fi
+		fi
+		if [ ! -z &quot;$OEM_ALIGN&quot; ];then
+			if [ ! -z &quot;$haveLVM&quot; ];then
+				vgchange -an
+			fi
+			fixupFDiskSectors $input $pstart
+		fi
+	else
+		# /.../
+		# nothing to do for parted here as we write
+		# imediately with parted and don't create a
+		# command input file as for fdisk
+		# ----
+		:
+	fi
+}
+#======================================
+# createPartitionerInput
+#--------------------------------------
+function createPartitionerInput {
+	if [ $PARTITIONER = &quot;sfdisk&quot; ];then
+		createFDiskInput $@
+	else
+		Echo &quot;Repartition the disk according to real geometry [ parted ]&quot;
+		partedInit $imageDiskDevice
+		createPartedInput $imageDiskDevice $@
+    fi
+}
+#======================================
+# checkFDiskFirstSector
+#--------------------------------------
+function checkFDiskFirstSector {
+	# /.../
+	# check number of start sector for first partition
+	# ----
+	local dev=$1
+	local p1=$(ddn $dev 1)
+	fdisk -ul ${dev} | grep '^'$p1 | \
+		sed -e's@'$p1'[ \*]*\([0-9]\+\) .*$@\1@'
+}
+#======================================
+# checkFDiskEndSector
+#--------------------------------------
+function checkFDiskEndSector {
+	# /.../
+	# check number of end sector for first partition
+	# ----
+	local dev=$1
+	local p1=$(ddn $dev 1)
+	fdisk -ul ${dev} | grep '^'$p1 | \
+		sed -e's@'$p1'[ \*]*\([0-9]\+\)[ \*]*\([0-9]\+\) .*$@\2@'
+}
+#======================================
+# fixupFDiskSectors
+#--------------------------------------
+function fixupFDiskSectors {
+	# /.../
+	# align the first partition start sector using fdisk
+	# ----
+	local input=$1
+	local palign=$2
+	local pstart pend act psize ptype rest
+	case &quot;$palign&quot; in
+		64) palign=8;;
+		2048) palign=2048;;
+		*) return;;
+	esac
+	local numpdevs=$(fdisk -ul $imageDiskDevice | grep '^/dev/' | wc -l)
+	rm -f $input
+	fdisk -ul $imageDiskDevice | grep '^/dev/' | \
+	while read pdev act pstart pend psize ptype rest; do
+		pdev=${pdev#$imageDiskDevice}
+		if [ &quot;$act&quot; != '*' ]; then
+			ptype=&quot;$psize&quot;
+			pend=&quot;$pstart&quot;
+			pstart=&quot;$act&quot;
+		fi
+		local aligned=$(( ( $pstart + $palign - 1 ) / $palign * $palign ))
+		if [ &quot;$aligned&quot; -ne &quot;$pstart&quot; ]; then
+			echo &quot;d&quot; &gt;&gt; $input
+			test $numpdevs -gt 1 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
+			echo &quot;n&quot; &gt;&gt; $input
+			echo &quot;p&quot; &gt;&gt; $input
+			test $numpdevs -lt 4 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
+			echo &quot;$aligned&quot; &gt;&gt; $input
+			echo &quot;$pend&quot; &gt;&gt; $input
+			echo &quot;t&quot; &gt;&gt; $input
+			test $numpdevs -gt 1 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
+			echo &quot;$ptype&quot; &gt;&gt; $input
+			if [ &quot;$act&quot; = '*' ]; then
+				echo &quot;a&quot; &gt;&gt; $input
+				echo &quot;$pdev&quot; &gt;&gt; $input
+			fi
+		fi
+		# handle only the first partition
+		break
+	done
+	if [ -s $input ]; then
+		echo &quot;w&quot; &gt;&gt; $input
+		echo &quot;q&quot; &gt;&gt; $input
+		fdisk -u $imageDiskDevice &lt; $input 1&gt;&amp;2
+		if test $? != 0; then
+			systemException &quot;Failed to fix up partition table&quot; &quot;reboot&quot;
+		fi
+	fi
+}
+#======================================
+# createFDiskInput
+#--------------------------------------
+function createFDiskInput {
+	local input=/part.input
+	rm -f $input
+	for cmd in $*;do
+		if [ $cmd = &quot;.&quot; ];then
+			echo &gt;&gt; $input
+			continue
+		fi
+		echo $cmd &gt;&gt; $input
+	done
+}
+#======================================
+# partedInit
+#--------------------------------------
+function partedInit {
+	# /.../
+	# initialize current partition table output
+	# as well as the number of cylinders and the
+	# cyliner size in kB for this disk
+	# ----
+	local device=$1
+	local IFS=&quot;&quot;
+	local parted=$(parted -m $device unit cyl print)
+	local header=$(echo $parted | head -n 3 | tail -n 1)
+	local ccount=$(echo $header | cut -f1 -d:)
+	local cksize=$(echo $header | cut -f4 -d: | cut -f1 -dk)
+	export partedOutput=$parted
+	export partedCylCount=$ccount
+	export partedCylKSize=$cksize
+}
+#======================================
+# partedWrite
+#--------------------------------------
+function partedWrite {
+	# /.../
+	# call parted with current command queue.
+	# This will immediately change the partition table
+	# ----
+	local device=$1
+	local cmds=$2
+	if ! parted -m $device unit cyl $cmds;then
+		systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
+	fi
+	partedInit $device
+}
+#======================================
+# partedStartCylinder
+#--------------------------------------
+function partedStartCylinder {
+	# /.../
+	# return start cylinder of given partition.
+	# lowest cylinder number is 0
+	# ----
+	local part=$(($1 + 3))
+	local IFS=&quot;&quot;
+	local header=$(echo $partedOutput | head -n $part | tail -n 1)
+	local ccount=$(echo $header | cut -f2 -d: | tr -d cyl)
+	echo $ccount
+}
+#======================================
+# partedEndCylinder
+#--------------------------------------
+function partedEndCylinder {
+	# /.../
+	# return end cylinder of given partition, next
+	# partition must start at return value plus 1
+	# ----
+	local part=$(($1 + 3))
+	local IFS=&quot;&quot;
+	local header=$(echo $partedOutput | head -n $part | tail -n 1)
+	local ccount=$(echo $header | cut -f3 -d: | tr -d cyl)
+	echo $ccount
+}
+#======================================
+# partedMBToCylinder
+#--------------------------------------
+function partedMBToCylinder {
+	# /.../
+	# convert size given in MB to cylinder count
+	# ----
+	local sizeKB=$(($1 * 1024))
+	local cylreq=$(($sizeKB / $partedCylKSize))
+	echo $cylreq
+}
+#======================================
+# createPartedInput
+#--------------------------------------
+function createPartedInput {
+	# /.../
+	# evaluate partition instructions and turn them
+	# into a parted command line queue. As soon as the
+	# geometry data would be changed according to the
+	# last partedInit() call the command queue is processed
+	# and the partedInit() will be called afterwards
+	# ----
+	local disk=$1
+	shift
+	local index=0
+	local pcmds
+	local partid
+	local pstart
+	local pstopp
+	local value
+	local cmdq
+	#======================================
+	# create list of commands
+	#--------------------------------------
+	for cmd in $*;do
+		pcmds[$index]=$cmd
+		index=$(($index + 1))
+	done
+	index=0
+	#======================================
+	# process commands
+	#--------------------------------------
+	for cmd in ${pcmds[*]};do
+		case $cmd in
+			#======================================
+			# delete partition
+			#--------------------------------------
+			&quot;d&quot;)
+				partid=${pcmds[$index + 1]}
+				partid=$(($partid / 1))
+				if [ $partid -eq 0 ];then
+					partid=1
+				fi
+				cmdq=&quot;$cmdq rm $partid&quot;
+				;;
+			#======================================
+			# create new partition
+			#--------------------------------------
+			&quot;n&quot;)
+				partid=${pcmds[$index + 2]}
+				partid=$(($partid / 1))
+				if [ $partid -eq 0 ];then
+					partid=1
+				fi
+				pstart=${pcmds[$index + 3]}
+				if [ &quot;$pstart&quot; = &quot;1&quot; ];then
+					pstart=0
+				fi
+				if [ $pstart = &quot;.&quot; ];then
+					# start is next cylinder according to previous partition
+					pstart=$(($partid - 1))
+					if [ $pstart -gt 0 ];then
+						pstart=$(partedEndCylinder $pstart)
+						pstart=$(($pstart + 1))
+					fi
+				fi
+				pstopp=${pcmds[$index + 4]}
+				if [ $pstopp = &quot;.&quot; ];then
+					# use rest of the disk for partition end
+					pstopp=$partedCylCount
+				elif echo $pstopp | grep -qi M;then
+					# calculate stopp cylinder from size
+					pstopp=$(($partid - 1))
+					if [ $pstopp -gt 0 ];then
+						pstopp=$(partedEndCylinder $pstopp)
+					fi
+					value=$(echo ${pcmds[$index + 4]} | cut -f1 -dM | tr -d +)
+					value=$(partedMBToCylinder $value)
+					pstopp=$((1 + $pstopp + $value))
+				fi
+				cmdq=&quot;$cmdq mkpart primary $pstart $pstopp&quot;
+				partedWrite &quot;$disk&quot; &quot;$cmdq&quot;
+				cmdq=&quot;&quot;
+				;;
+			#======================================
+			# change partition ID
+			#--------------------------------------
+			&quot;t&quot;)
+				ptypex=${pcmds[$index + 2]}
+				partid=${pcmds[$index + 1]}
+				cmdq=&quot;$cmdq set $partid type 0x$ptypex&quot;
+				partedWrite &quot;$disk&quot; &quot;$cmdq&quot;
+				cmdq=&quot;&quot;
+				;;
+		esac
+		index=$(($index + 1))
+	done
+}
 #======================================
 # initialize
 #--------------------------------------
@@ -5327,3 +5718,4 @@ function initialize {
 		export UTIMER=$(cat /var/run/utimer.pid)
 	fi
 }
+
diff --git a/system/boot/ix86/netboot/suse-11.0/config.xml b/system/boot/ix86/netboot/suse-11.0/config.xml
index a96181d..1042247 100644
--- a/system/boot/ix86/netboot/suse-11.0/config.xml
+++ b/system/boot/ix86/netboot/suse-11.0/config.xml
@@ -222,7 +222,6 @@
 		&lt;package name=&quot;audit-libs&quot;/&gt;
 		&lt;package name=&quot;blocxx&quot;/&gt;
 		&lt;package name=&quot;cpio&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;db&quot;/&gt;
 		&lt;package name=&quot;diffutils&quot;/&gt;
 		&lt;package name=&quot;expat&quot;/&gt;
@@ -288,7 +287,6 @@
 		&lt;package name=&quot;pciutils&quot;/&gt;
 		&lt;package name=&quot;krb5&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;pam-modules&quot;/&gt;
 		&lt;package name=&quot;pam-config&quot;/&gt;
 		&lt;package name=&quot;PolicyKit&quot;/&gt;
diff --git a/system/boot/ix86/netboot/suse-11.1/config.xml b/system/boot/ix86/netboot/suse-11.1/config.xml
index 086cc6c..fe2b500 100644
--- a/system/boot/ix86/netboot/suse-11.1/config.xml
+++ b/system/boot/ix86/netboot/suse-11.1/config.xml
@@ -227,7 +227,6 @@
 		&lt;package name=&quot;audit-libs&quot;/&gt;
 		&lt;package name=&quot;blocxx&quot;/&gt;
 		&lt;package name=&quot;cpio&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;db&quot;/&gt;
 		&lt;package name=&quot;diffutils&quot;/&gt;
 		&lt;package name=&quot;expat&quot;/&gt;
@@ -292,7 +291,6 @@
 		&lt;package name=&quot;pciutils&quot;/&gt;
 		&lt;package name=&quot;krb5&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;pam-modules&quot;/&gt;
 		&lt;package name=&quot;pam-config&quot;/&gt;
 		&lt;package name=&quot;PolicyKit&quot;/&gt;
diff --git a/system/boot/ix86/netboot/suse-11.2/config.xml b/system/boot/ix86/netboot/suse-11.2/config.xml
index 48265b8..167a74f 100644
--- a/system/boot/ix86/netboot/suse-11.2/config.xml
+++ b/system/boot/ix86/netboot/suse-11.2/config.xml
@@ -227,7 +227,6 @@
 		&lt;package name=&quot;audit-libs&quot;/&gt;
 		&lt;package name=&quot;blocxx&quot;/&gt;
 		&lt;package name=&quot;cpio&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;db&quot;/&gt;
 		&lt;package name=&quot;diffutils&quot;/&gt;
 		&lt;package name=&quot;expat&quot;/&gt;
@@ -285,7 +284,6 @@
 		&lt;package name=&quot;pciutils&quot;/&gt;
 		&lt;package name=&quot;krb5&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;pam-modules&quot;/&gt;
 		&lt;package name=&quot;pam-config&quot;/&gt;
 		&lt;package name=&quot;PolicyKit&quot;/&gt;
diff --git a/system/boot/ix86/netboot/suse-SLED11/config.xml b/system/boot/ix86/netboot/suse-SLED11/config.xml
index 40d5fd3..c6f0cad 100644
--- a/system/boot/ix86/netboot/suse-SLED11/config.xml
+++ b/system/boot/ix86/netboot/suse-SLED11/config.xml
@@ -178,6 +178,7 @@
 		&lt;package name=&quot;bootsplash&quot;/&gt;
 		&lt;package name=&quot;tar&quot;/&gt;
 		&lt;package name=&quot;kiwi-tools&quot;/&gt;
+		&lt;package name=&quot;mdadm&quot;/&gt;
 &lt;!-- PACKAGES END DEFAULT AND XEN --&gt;
 	&lt;/packages&gt;
 	&lt;packages type=&quot;image&quot; profiles=&quot;diskless&quot;&gt;
@@ -216,7 +217,6 @@
 		&lt;package name=&quot;audit-libs&quot;/&gt;
 		&lt;package name=&quot;blocxx&quot;/&gt;
 		&lt;package name=&quot;cpio&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;db&quot;/&gt;
 		&lt;package name=&quot;diffutils&quot;/&gt;
 		&lt;package name=&quot;expat&quot;/&gt;
@@ -236,7 +236,6 @@
 		&lt;package name=&quot;limal&quot;/&gt;
 		&lt;package name=&quot;limal-perl&quot;/&gt;
 		&lt;package name=&quot;logrotate&quot;/&gt;
-		&lt;package name=&quot;mdadm&quot;/&gt;
 		&lt;package name=&quot;mingetty&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
 		&lt;package name=&quot;openslp&quot;/&gt;
@@ -280,7 +279,6 @@
 		&lt;package name=&quot;pciutils&quot;/&gt;
 		&lt;package name=&quot;krb5&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;pam-modules&quot;/&gt;
 		&lt;package name=&quot;pam-config&quot;/&gt;
 		&lt;package name=&quot;PolicyKit&quot;/&gt;
diff --git a/system/boot/ix86/netboot/suse-SLES11/config.xml b/system/boot/ix86/netboot/suse-SLES11/config.xml
index 684238c..d461ca0 100644
--- a/system/boot/ix86/netboot/suse-SLES11/config.xml
+++ b/system/boot/ix86/netboot/suse-SLES11/config.xml
@@ -178,6 +178,7 @@
 		&lt;package name=&quot;bootsplash&quot;/&gt;
 		&lt;package name=&quot;tar&quot;/&gt;
 		&lt;package name=&quot;kiwi-tools&quot;/&gt;
+		&lt;package name=&quot;mdadm&quot;/&gt;
 &lt;!-- PACKAGES END DEFAULT AND XEN --&gt;
 	&lt;/packages&gt;
 	&lt;packages type=&quot;image&quot; profiles=&quot;diskless&quot;&gt;
@@ -215,7 +216,6 @@
 		&lt;package name=&quot;audit-libs&quot;/&gt;
 		&lt;package name=&quot;blocxx&quot;/&gt;
 		&lt;package name=&quot;cpio&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;db&quot;/&gt;
 		&lt;package name=&quot;diffutils&quot;/&gt;
 		&lt;package name=&quot;expat&quot;/&gt;
@@ -235,7 +235,6 @@
 		&lt;package name=&quot;limal&quot;/&gt;
 		&lt;package name=&quot;limal-perl&quot;/&gt;
 		&lt;package name=&quot;logrotate&quot;/&gt;
-		&lt;package name=&quot;mdadm&quot;/&gt;
 		&lt;package name=&quot;mingetty&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
 		&lt;package name=&quot;openslp&quot;/&gt;
@@ -279,7 +278,6 @@
 		&lt;package name=&quot;pciutils&quot;/&gt;
 		&lt;package name=&quot;krb5&quot;/&gt;
 		&lt;package name=&quot;openldap2-client&quot;/&gt;
-		&lt;package name=&quot;cyrus-sasl&quot;/&gt;
 		&lt;package name=&quot;pam-modules&quot;/&gt;
 		&lt;package name=&quot;pam-config&quot;/&gt;
 		&lt;package name=&quot;PolicyKit&quot;/&gt;
diff --git a/system/boot/ix86/netboot/suse-linuxrc b/system/boot/ix86/netboot/suse-linuxrc
index 166525d..dbb5dbf 100755
--- a/system/boot/ix86/netboot/suse-linuxrc
+++ b/system/boot/ix86/netboot/suse-linuxrc
@@ -21,6 +21,7 @@
 #--------------------------------------
 export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
 export IFS_ORIG=$IFS
+export input=/part.input
 export ARCH=`arch`
 export DEBUG=0
 
@@ -381,6 +382,19 @@ then
 				&quot;Disk $DISK doesn't appear... fatal !&quot; \
 			&quot;reboot&quot;
 		fi
+		if [ ! -z &quot;$RAID&quot; ];then
+			field=0
+			IFS=&quot;;&quot; ; for n in $RAID;do
+				case $field in
+					0) raidLevel=$n ; field=1 ;;
+					1) raidFirst=$n ; field=2 ;;
+					2) raidSecond=$n; field=3
+				esac
+			done
+			IFS=$IFS_ORIG
+			mdadm --assemble $imageDevice \
+				$raidFirst $raidSecond
+		fi
 		updateNeeded initialize
 		if linuxPartition $DISK;then
 			if mountSystem $imageDevice;then
@@ -399,6 +413,9 @@ then
 		else
 			systemIntegrity=&quot;clean&quot;
 		fi
+		if [ ! $systemIntegrity = &quot;fine&quot; ] &amp;&amp; [ ! -z &quot;$RAID&quot; ];then
+			mdadm --stop $imageDevice
+		fi
 	}
 	;;
 	*)
@@ -416,12 +433,98 @@ then
 		createSwap
 		createPartition
 		writePartitionTable $DISK
-		IFS=&quot;:&quot; ; for i in $PART_DEV;do
-		if test ! -z &quot;$i&quot;;then
-			createFileSystem $i
+		if [ ! -z &quot;$RAID&quot; ];then
+			#======================================
+			# Setup raid partitions
+			#--------------------------------------
+			field=0
+			IFS=&quot;;&quot; ; for n in $RAID;do
+				case $field in
+					0) raidLevel=$n ; field=1 ;;
+					1) raidFirst=$n ; field=2 ;;
+					2) raidSecond=$n; field=3
+				esac
+			done
+			IFS=$IFS_ORIG
+			raidDiskFirst=$(dn $raidFirst)
+			raidDiskSecond=$(dn $raidSecond)
+			raidIDFirst=$(nd $raidFirst)
+			raidIDSecond=$(nd $raidSecond)
+			#======================================
+			# wait for raid disks to appear
+			#--------------------------------------
+			if ! waitForStorageDevice $raidDiskFirst;then
+				systemException \
+					&quot;Disk $raidDiskFirst doesn't appear... fatal !&quot; \
+				&quot;reboot&quot;
+			fi
+			if ! waitForStorageDevice $raidDiskSecond;then
+				systemException \
+					&quot;Disk $raidDiskSecond doesn't appear... fatal !&quot; \
+				&quot;reboot&quot;
+			fi
+			rm -f $input
+			imageDiskDevice=$raidDiskFirst
+			createPartitionerInput n p $raidIDFirst . . t $raidIDFirst fd w q
+			callPartitioner $input
+			rm -f $input
+			imageDiskDevice=$raidDiskSecond
+			cleanPartitionTable
+			createPartitionerInput n p $raidIDSecond . . t $raidIDSecond fd w q
+			callPartitioner $input
+			rm -f $input
+			#======================================
+			# wait for raid partitions to appear
+			#--------------------------------------
+			if ! waitForStorageDevice $raidFirst;then
+				systemException \
+					&quot;Disk $raidFirst doesn't appear... fatal !&quot; \
+				&quot;reboot&quot;
+			fi
+			if ! waitForStorageDevice $raidSecond;then
+				systemException \
+					&quot;Disk $raidSecond doesn't appear... fatal !&quot; \
+				&quot;reboot&quot;
+			fi
+			imageDiskDevice=$DISK
+			#======================================
+			# Create raid array
+			#--------------------------------------
+			mdadm --zero-superblock $raidFirst
+			mdadm --zero-superblock $raidSecond
+			yes | mdadm --create /dev/md0 \
+				--level=$raidLevel --raid-disks=2 $raidFirst $raidSecond
+			if [ ! $? = 0 ];then
+				systemException \
+					&quot;Failed to create raid array... fatal !&quot; \
+				&quot;reboot&quot;
+			fi
 		fi
+		#======================================
+		# Create fs on part without mount point
+		#--------------------------------------
+		IFS=&quot;:&quot; ; for i in $PART_DEV;do
+			if [ ! -z &quot;$i&quot; ];then
+				createFileSystem $i
+			fi
 		done
-		mkswap ${DISK}1 &gt;/dev/null 2&gt;&amp;1
+		IFS=$IFS_ORIG
+		#======================================
+		# Setup swap space if requested
+		#--------------------------------------
+		export imageSwapDevice=$(pxeSwapDevice)
+		if [ ! -z &quot;$imageSwapDevice&quot; ];then
+			if ! mkswap $imageSwapDevice 1&gt;&amp;2;then
+				systemException &quot;Failed to create swap signature&quot; &quot;reboot&quot;
+			fi
+		fi
+		#======================================
+		# Setup boot space if requested
+		#--------------------------------------
+		export imageBootDevice=$(pxeBootDevice)
+		if [ ! -z &quot;$imageBootDevice&quot; ];then
+			mke2fs -F $imageBootDevice 1&gt;&amp;2
+		fi
 		runHook postpartition
 	fi
 fi
@@ -787,7 +890,17 @@ validateRootTree
 runHook postmount
 
 #======================================
-# 16) Import fixed configuration files
+# 16) Setup boot device contents
+#--------------------------------------
+if [ ! -z &quot;$imageBootDevice&quot; ];then
+	cd /mnt/boot &amp;&amp; tar -czf /tmp/boot.tgz .
+	rm -rf /mnt/boot/* &amp;&amp; mount $imageBootDevice /mnt/boot
+	cd /mnt/boot &amp;&amp; tar -xf /tmp/boot.tgz
+	rm -f /tmp/boot.tgz
+fi
+
+#======================================
+# 17) Import fixed configuration files
 #--------------------------------------
 runHook preconfig
 if [ $LOCAL_BOOT = &quot;no&quot; ];then
@@ -838,7 +951,7 @@ fi
 runHook postconfig
 
 #======================================
-# 17) check filesystem and kernels
+# 18) check filesystem and kernels
 #--------------------------------------
 if [ $LOCAL_BOOT = &quot;no&quot; ];then
 	if test $systemIntegrity = &quot;clean&quot;;then
@@ -848,7 +961,7 @@ if [ $LOCAL_BOOT = &quot;no&quot; ];then
 fi
 
 #======================================
-# 18) make initrd available on unionfs
+# 19) make initrd available on unionfs
 #--------------------------------------
 if \
 	[ $LOCAL_BOOT = &quot;no&quot; ] &amp;&amp; \
@@ -889,7 +1002,7 @@ then
 fi
 
 #======================================
-# 19) Create system dependant files
+# 20) Create system dependant files
 #--------------------------------------
 if [ $LOCAL_BOOT = &quot;no&quot; ];then
 	if test $systemIntegrity = &quot;clean&quot;;then
@@ -913,7 +1026,7 @@ if [ $LOCAL_BOOT = &quot;no&quot; ];then
 fi
 
 #======================================
-# 20) If image is new, notify
+# 21) If image is new, notify
 #--------------------------------------
 runHook prenotify
 if [ $LOCAL_BOOT = &quot;no&quot; ];then
@@ -943,7 +1056,7 @@ fi
 runHook postnotify
 
 #======================================
-# 21) send DHCP_RELEASE, reset cache
+# 22) send DHCP_RELEASE, reset cache
 #--------------------------------------
 if \
 	[ $LOCAL_BOOT = &quot;no&quot; ] &amp;&amp; \
@@ -955,7 +1068,7 @@ then
 fi
 
 #======================================
-# 22) copy system dependant files
+# 23) copy system dependant files
 #--------------------------------------
 if [ $LOCAL_BOOT = &quot;no&quot; ];then
 	if test $systemIntegrity = &quot;clean&quot;;then
@@ -964,18 +1077,18 @@ if [ $LOCAL_BOOT = &quot;no&quot; ];then
 fi
 
 #======================================
-# 23) update system dependant files
+# 24) update system dependant files
 #--------------------------------------
 setupInittab /mnt
 
 echo 256 &gt; /proc/sys/kernel/real-root-dev
 #======================================
-# 24) umount system filesystems
+# 25) umount system filesystems
 #--------------------------------------
 umountSystemFilesystems
 
 #======================================
-# 25) copy initrd files to image
+# 26) copy initrd files to image
 #--------------------------------------
 importBranding
 if canWrite /mnt;then
@@ -984,23 +1097,23 @@ if canWrite /mnt;then
 fi
 
 #======================================
-# 26) check if reboot is required
+# 27) check if reboot is required
 #--------------------------------------
 kernelCheck /mnt
 
 #======================================
-# 27 kill boot shell
+# 28 kill boot shell
 #--------------------------------------
 killShell
 killBlogD
 
 #======================================
-# 28 Activate new root
+# 29 Activate new root
 #--------------------------------------
 runHook preactivate
 activateImage
 
 #======================================
-# 29) Unmount initrd / system init
+# 30) Unmount initrd / system init
 #--------------------------------------
 bootImage $@
diff --git a/system/boot/ix86/oemboot/suse-repart b/system/boot/ix86/oemboot/suse-repart
index ce24089..70715d5 100755
--- a/system/boot/ix86/oemboot/suse-repart
+++ b/system/boot/ix86/oemboot/suse-repart
@@ -910,340 +910,6 @@ function activateBootPartition {
 }
 
 #======================================
-# callPartitioner
-#--------------------------------------
-function callPartitioner {
-	local input=$1
-	if [ $PARTITIONER = &quot;sfdisk&quot; ];then
-		Echo &quot;Repartition the disk according to real geometry [ fdisk ]&quot;
-		local pstart=$(checkFDiskFirstSector $imageDiskDevice)
-		fdisk $imageDiskDevice &lt; $input 1&gt;&amp;2
-		if test $? != 0; then
-			systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
-		fi
-		local pstopp_new=$(checkFDiskEndSector   $imageDiskDevice)
-		local pstart_new=$(checkFDiskFirstSector $imageDiskDevice)
-		if [ $pstart_new -ne $pstart ];then
-			local fixpart=/part.input-fixupStartSector
-			local numpdevs=$(fdisk -ul $imageDiskDevice | grep '^/dev/' | wc -l)
-			echo &quot;d&quot;          &gt; $fixpart
-			if [ $numpdevs -gt 1 ];then
-				echo &quot;1&quot;     &gt;&gt; $fixpart
-			fi
-			echo &quot;n&quot;         &gt;&gt; $fixpart
-			echo &quot;p&quot;         &gt;&gt; $fixpart
-			echo &quot;1&quot;         &gt;&gt; $fixpart
-			echo $pstart     &gt;&gt; $fixpart
-			echo $pstopp_new &gt;&gt; $fixpart
-			echo &quot;w&quot;         &gt;&gt; $fixpart
-			echo &quot;q&quot;         &gt;&gt; $fixpart
-			fdisk -u $imageDiskDevice &lt; $fixpart 1&gt;&amp;2
-			if test $? != 0; then
-				systemException &quot;Failed to fix partition table&quot; &quot;reboot&quot;
-			fi
-		fi
-		if [ ! -z &quot;$OEM_ALIGN&quot; ];then
-			if [ ! -z &quot;$haveLVM&quot; ];then
-				vgchange -an
-			fi
-			fixupFDiskSectors $input $pstart
-		fi
-	else
-		# /.../
-		# nothing to do for parted here as we write
-		# imediately with parted and don't create a
-		# command input file as for fdisk
-		# ----
-		:
-	fi
-}
-
-#======================================
-# createPartitionerInput
-#--------------------------------------
-function createPartitionerInput {
-	if [ $PARTITIONER = &quot;sfdisk&quot; ];then
-		createFDiskInput $@
-	else
-		Echo &quot;Repartition the disk according to real geometry [ parted ]&quot;
-		partedInit $imageDiskDevice
-		createPartedInput $imageDiskDevice $@
-    fi
-}
-
-#======================================
-# checkFDiskFirstSector
-#--------------------------------------
-function checkFDiskFirstSector {
-	# /.../
-	# check number of start sector for first partition
-	# ----
-	local dev=$1
-	local p1=$(ddn $dev 1)
-	fdisk -ul ${dev} | grep '^'$p1 | \
-		sed -e's@'$p1'[ \*]*\([0-9]\+\) .*$@\1@'
-}
-
-#======================================
-# checkFDiskEndSector
-#--------------------------------------
-function checkFDiskEndSector {
-	# /.../
-	# check number of end sector for first partition
-	# ----
-	local dev=$1
-	local p1=$(ddn $dev 1)
-	fdisk -ul ${dev} | grep '^'$p1 | \
-		sed -e's@'$p1'[ \*]*\([0-9]\+\)[ \*]*\([0-9]\+\) .*$@\2@'
-}
-
-#======================================
-# fixupFDiskSectors
-#--------------------------------------
-function fixupFDiskSectors {
-	# /.../
-	# align the first partition start sector using fdisk
-	# ----
-	local input=$1
-	local palign=$2
-	local pstart pend act psize ptype rest
-	case &quot;$palign&quot; in
-		64) palign=8;;
-		2048) palign=2048;;
-		*) return;;
-	esac
-	local numpdevs=$(fdisk -ul $imageDiskDevice | grep '^/dev/' | wc -l)
-	rm -f $input
-	fdisk -ul $imageDiskDevice | grep '^/dev/' | \
-	while read pdev act pstart pend psize ptype rest; do
-		pdev=${pdev#$imageDiskDevice}
-		if [ &quot;$act&quot; != '*' ]; then
-			ptype=&quot;$psize&quot;
-			pend=&quot;$pstart&quot;
-			pstart=&quot;$act&quot;
-		fi
-		local aligned=$(( ( $pstart + $palign - 1 ) / $palign * $palign ))
-		if [ &quot;$aligned&quot; -ne &quot;$pstart&quot; ]; then
-			echo &quot;d&quot; &gt;&gt; $input
-			test $numpdevs -gt 1 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
-			echo &quot;n&quot; &gt;&gt; $input
-			echo &quot;p&quot; &gt;&gt; $input
-			test $numpdevs -lt 4 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
-			echo &quot;$aligned&quot; &gt;&gt; $input
-			echo &quot;$pend&quot; &gt;&gt; $input
-			echo &quot;t&quot; &gt;&gt; $input
-			test $numpdevs -gt 1 &amp;&amp; echo &quot;$pdev&quot; &gt;&gt; $input
-			echo &quot;$ptype&quot; &gt;&gt; $input
-			if [ &quot;$act&quot; = '*' ]; then
-				echo &quot;a&quot; &gt;&gt; $input
-				echo &quot;$pdev&quot; &gt;&gt; $input
-			fi
-		fi
-		# handle only the first partition
-		break
-	done
-	if [ -s $input ]; then
-		echo &quot;w&quot; &gt;&gt; $input
-		echo &quot;q&quot; &gt;&gt; $input
-		fdisk -u $imageDiskDevice &lt; $input 1&gt;&amp;2
-		if test $? != 0; then
-			systemException &quot;Failed to fix up partition table&quot; &quot;reboot&quot;
-		fi
-	fi
-}
-
-#======================================
-# createFDiskInput
-#--------------------------------------
-function createFDiskInput {
-	local input=/part.input
-	rm -f $input
-	for cmd in $*;do
-		if [ $cmd = &quot;.&quot; ];then
-			echo &gt;&gt; $input
-			continue
-		fi
-		echo $cmd &gt;&gt; $input
-	done
-}
-
-#======================================
-# partedInit
-#--------------------------------------
-function partedInit {
-	# /.../
-	# initialize current partition table output
-	# as well as the number of cylinders and the
-	# cyliner size in kB for this disk
-	# ----
-	local device=$1
-	local IFS=&quot;&quot;
-	local parted=$(parted -m $device unit cyl print)
-	local header=$(echo $parted | head -n 3 | tail -n 1)
-	local ccount=$(echo $header | cut -f1 -d:)
-	local cksize=$(echo $header | cut -f4 -d: | cut -f1 -dk)
-	export partedOutput=$parted
-	export partedCylCount=$ccount
-	export partedCylKSize=$cksize
-}
-
-#======================================
-# partedWrite
-#--------------------------------------
-function partedWrite {
-	# /.../
-	# call parted with current command queue.
-	# This will immediately change the partition table
-	# ----
-	local device=$1
-	local cmds=$2
-	if ! parted -m $device unit cyl $cmds;then
-		systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
-	fi
-	partedInit $device
-}
-
-#======================================
-# partedStartCylinder
-#--------------------------------------
-function partedStartCylinder {
-	# /.../
-	# return start cylinder of given partition.
-	# lowest cylinder number is 0
-	# ----
-	local part=$(($1 + 3))
-	local IFS=&quot;&quot;
-	local header=$(echo $partedOutput | head -n $part | tail -n 1)
-	local ccount=$(echo $header | cut -f2 -d: | tr -d cyl)
-	echo $ccount
-}
-
-#======================================
-# partedEndCylinder
-#--------------------------------------
-function partedEndCylinder {
-	# /.../
-	# return end cylinder of given partition, next
-	# partition must start at return value plus 1
-	# ----
-	local part=$(($1 + 3))
-	local IFS=&quot;&quot;
-	local header=$(echo $partedOutput | head -n $part | tail -n 1)
-	local ccount=$(echo $header | cut -f3 -d: | tr -d cyl)
-	echo $ccount
-}
-
-#======================================
-# partedMBToCylinder
-#--------------------------------------
-function partedMBToCylinder {
-	# /.../
-	# convert size given in MB to cylinder count
-	# ----
-	local sizeKB=$(($1 * 1024))
-	local cylreq=$(($sizeKB / $partedCylKSize))
-	echo $cylreq
-}
-
-#======================================
-# createPartedInput
-#--------------------------------------
-function createPartedInput {
-	# /.../
-	# evaluate partition instructions and turn them
-	# into a parted command line queue. As soon as the
-	# geometry data would be changed according to the
-	# last partedInit() call the command queue is processed
-	# and the partedInit() will be called afterwards
-	# ----
-	local disk=$1
-	shift
-	local index=0
-	local pcmds
-	local partid
-	local pstart
-	local pstopp
-	local value
-	local cmdq
-	#======================================
-	# create list of commands
-	#--------------------------------------
-	for cmd in $*;do
-		pcmds[$index]=$cmd
-		index=$(($index + 1))
-	done
-	index=0
-	#======================================
-	# process commands
-	#--------------------------------------
-	for cmd in ${pcmds[*]};do
-		case $cmd in
-			#======================================
-			# delete partition
-			#--------------------------------------
-			&quot;d&quot;)
-				partid=${pcmds[$index + 1]}
-				partid=$(($partid / 1))
-				if [ $partid -eq 0 ];then
-					partid=1
-				fi
-				cmdq=&quot;$cmdq rm $partid&quot;
-				;;
-			#======================================
-			# create new partition
-			#--------------------------------------
-			&quot;n&quot;)
-				partid=${pcmds[$index + 2]}
-				partid=$(($partid / 1))
-				if [ $partid -eq 0 ];then
-					partid=1
-				fi
-				pstart=${pcmds[$index + 3]}
-				if [ &quot;$pstart&quot; = &quot;1&quot; ];then
-					pstart=0
-				fi
-				if [ $pstart = &quot;.&quot; ];then
-					# start is next cylinder according to previous partition
-					pstart=$(($partid - 1))
-					if [ $pstart -gt 0 ];then
-						pstart=$(partedEndCylinder $pstart)
-						pstart=$(($pstart + 1))
-					fi
-				fi
-				pstopp=${pcmds[$index + 4]}
-				if [ $pstopp = &quot;.&quot; ];then
-					# use rest of the disk for partition end
-					pstopp=$partedCylCount
-				elif echo $pstopp | grep -qi M;then
-					# calculate stopp cylinder from size
-					pstopp=$(($partid - 1))
-					if [ $pstopp -gt 0 ];then
-						pstopp=$(partedEndCylinder $pstopp)
-					fi
-					value=$(echo ${pcmds[$index + 4]} | cut -f1 -dM | tr -d +)
-					value=$(partedMBToCylinder $value)
-					pstopp=$((1 + $pstopp + $value))
-				fi
-				cmdq=&quot;$cmdq mkpart primary $pstart $pstopp&quot;
-				partedWrite &quot;$disk&quot; &quot;$cmdq&quot;
-				cmdq=&quot;&quot;
-				;;
-			#======================================
-			# change partition ID
-			#--------------------------------------
-			&quot;t&quot;)
-				ptypex=${pcmds[$index + 2]}
-				partid=${pcmds[$index + 1]}
-				cmdq=&quot;$cmdq set $partid type 0x$ptypex&quot;
-				partedWrite &quot;$disk&quot; &quot;$cmdq&quot;
-				cmdq=&quot;&quot;
-				;;
-		esac
-		index=$(($index + 1))
-	done
-}
-
-#======================================
 # setupDeviceNames
 #--------------------------------------
 function setupDeviceNames {


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002995.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 696f4fee72f6539219d2b6f6028de61641b665a9
</A></li>
	<LI>Next message: <A HREF="002997.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch,	KIWI-374-SuSE-11-1-SLE-SP-Devel,	updated. a20a429596ae7187f93695fc45e041850ebb8391
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2996">[ date ]</a>
              <a href="thread.html#2996">[ thread ]</a>
              <a href="subject.html#2996">[ subject ]</a>
              <a href="author.html#2996">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
