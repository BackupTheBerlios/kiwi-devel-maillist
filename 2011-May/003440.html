<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 3e81b73d71a7234604a5fb63a8cb43b0b75d6caf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%203e81b73d71a7234604a5fb63a8cb43b0b75d6caf&In-Reply-To=%3C20110519100802.E04BD48133A%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003441.html">
   <LINK REL="Next"  HREF="003438.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 3e81b73d71a7234604a5fb63a8cb43b0b75d6caf</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%203e81b73d71a7234604a5fb63a8cb43b0b75d6caf&In-Reply-To=%3C20110519100802.E04BD48133A%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 3e81b73d71a7234604a5fb63a8cb43b0b75d6caf">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Thu May 19 12:08:01 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003441.html">[Kiwi-devel] run tests during package build
</A></li>
        <LI>Next message: <A HREF="003438.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 01353d5fd6fde1562bf0ad20722e4b1a748d282a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3440">[ date ]</a>
              <a href="thread.html#3440">[ thread ]</a>
              <a href="subject.html#3440">[ subject ]</a>
              <a href="author.html#3440">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  3e81b73d71a7234604a5fb63a8cb43b0b75d6caf (commit)
       via  a5c7ab512dfb02dd99044c1db1cbc46ab05bf221 (commit)
      from  ca0c8af50c42676693eb6f4ed6a93a6a6dbd08b2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3e81b73d71a7234604a5fb63a8cb43b0b75d6caf
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Thu May 19 11:45:26 2011 +0200

    - fixed version update script

commit a5c7ab512dfb02dd99044c1db1cbc46ab05bf221
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Thu May 19 11:33:19 2011 +0200

    - cleanup situation around global variables. There is now a
      KIWIGlobals object which contains all global variables and
      functions. There are still some global variables in use
      which references options. Those should be handled by a
      KIWICommandline accessor

-----------------------------------------------------------------------

Summary of changes:
diff --git a/.newversion b/.newversion
index 8a1625d..df6e12a 100755
--- a/.newversion
+++ b/.newversion
@@ -7,9 +7,9 @@ if ! echo $version | grep -q -E &quot;^[0-9]+\.[0-9]+$&quot;;then
 fi
 
 # code version update
-cat kiwi.pl | sed \
-	-e s&quot;@our \$Version       = \&quot;.*\&quot;@our \$Version       = \&quot;$version\&quot;@&quot;\
-&gt; kiwi.pl.new &amp;&amp; mv kiwi.pl.new kiwi.pl &amp;&amp; chmod 755 kiwi.pl
+cat modules/KIWIGlobals.pm | sed \
+	-e s&quot;@\$data{Version}       = \&quot;.*\&quot;@\$data\{Version\}       = \&quot;$version\&quot;@&quot; \
+&gt; modules/KIWIGlobals.pm.new &amp;&amp; mv modules/KIWIGlobals.pm.new modules/KIWIGlobals.pm &amp;&amp; chmod 644 modules/KIWIGlobals.pm
 
 # spec file version update
 cat rpm/kiwi.spec | sed \
diff --git a/kiwi.pl b/kiwi.pl
index 3552349..81f9ffb 100755
--- a/kiwi.pl
+++ b/kiwi.pl
@@ -47,98 +47,20 @@ use KIWIRuntimeChecker;
 use KIWIImageFormat;
 use KIWIXMLInfo;
 use KIWIXMLValidator;
+use KIWIGlobals;
 
 #============================================
-# Globals (Version)
+# Globals (debugging)
 #--------------------------------------------
-our $Version       = &quot;4.88&quot;;
-our $Publisher     = &quot;SUSE LINUX Products GmbH&quot;;
-our $Preparer      = &quot;KIWI - <A HREF="http://kiwi.berlios.de">http://kiwi.berlios.de</A>&quot;;
-our $ConfigFile    = &quot;$ENV{'HOME'}/.kiwirc&quot;;
-our $ConfigName    = &quot;config.xml&quot;;
-our $Partitioner   = &quot;parted&quot;;
 our $TT            = &quot;Trace Level &quot;;
-our $ConfigStatus  = 0;
 our $TL            = 1;
 our $BT;
-#============================================
-# Read $HOME/.kiwirc
-#--------------------------------------------
-if ( -f $ConfigFile) {
-	my $kiwi = new KIWILog(&quot;tiny&quot;);
-	if (! do $ConfigFile) {
-		$kiwi -&gt; warning (&quot;Invalid $ConfigFile file...&quot;);
-		$kiwi -&gt; skipped ();
-	} else {
-		$kiwi -&gt; info (&quot;Using $ConfigFile&quot;);
-		$kiwi -&gt; done ();
-		$ConfigStatus = 1;
-	}
-}
+
 #============================================
 # Globals
 #--------------------------------------------
-our $BasePath;         # configurable base kiwi path
-our $Gzip;             # configurable gzip command
-our $LogServerPort;    # configurable log server port
-our $LuksCipher;       # stored luks passphrase
-our $System;           # configurable baes kiwi image desc. path
-our @UmountStack;      # command list to umount
-if ( ! defined $BasePath ) {
-	$BasePath = &quot;/usr/share/kiwi&quot;;
-}
-if (! defined $Gzip) {
-	$Gzip = &quot;gzip -9&quot;;
-}
-if (! defined $LogServerPort) {
-	$LogServerPort = &quot;off&quot;;
-}
-if ( ! defined $System ) {
-	$System  = $BasePath.&quot;/image&quot;;
-}
-our $Tools    = $BasePath.&quot;/tools&quot;;
-our $Schema   = $BasePath.&quot;/modules/KIWISchema.rng&quot;;
-our $SchemaTST= $BasePath.&quot;/modules/KIWISchemaTest.rng&quot;;
-our $KConfig  = $BasePath.&quot;/modules/KIWIConfig.sh&quot;;
-our $KMigrate = $BasePath.&quot;/modules/KIWIMigrate.txt&quot;;
-our $KRegion  = $BasePath.&quot;/modules/KIWIEC2Region.txt&quot;;
-our $KMigraCSS= $BasePath.&quot;/modules/KIWIMigrate.tgz&quot;;
-our $KSplit   = $BasePath.&quot;/modules/KIWISplit.txt&quot;;
-our $repoURI  = $BasePath.&quot;/modules/KIWIURL.txt&quot;;
-our $Revision = $BasePath.&quot;/.revision&quot;;
-our $TestBase = $BasePath.&quot;/tests&quot;;
-our $SchemaCVT= $BasePath.&quot;/xsl/master.xsl&quot;;
-our $Pretty   = $BasePath.&quot;/xsl/print.xsl&quot;;
-
-#==========================================
-# Globals (Supported filesystem names)
-#------------------------------------------
-our %KnownFS;
+our $global  = new KIWIGlobals();
 our $locator = new KIWILocator();
-$KnownFS{ext4}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext4&quot;);
-$KnownFS{ext3}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext3&quot;);
-$KnownFS{ext2}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext2&quot;);
-$KnownFS{squashfs}{tool}  = $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
-$KnownFS{clicfs}{tool}    = $locator -&gt; getExecPath(&quot;mkclicfs&quot;);
-$KnownFS{clic}{tool}      = $locator -&gt; getExecPath(&quot;mkclicfs&quot;);
-$KnownFS{unified}{tool}   = $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
-$KnownFS{compressed}{tool}= $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
-$KnownFS{reiserfs}{tool}  = $locator -&gt; getExecPath(&quot;mkreiserfs&quot;);
-$KnownFS{btrfs}{tool}     = $locator -&gt; getExecPath(&quot;mkfs.btrfs&quot;);
-$KnownFS{xfs}{tool}       = $locator -&gt; getExecPath(&quot;mkfs.xfs&quot;);
-$KnownFS{cpio}{tool}      = $locator -&gt; getExecPath(&quot;cpio&quot;);
-$KnownFS{ext3}{ro}        = 0;
-$KnownFS{ext4}{ro}        = 0;
-$KnownFS{ext2}{ro}        = 0;
-$KnownFS{squashfs}{ro}    = 1;
-$KnownFS{clicfs}{ro}      = 1;
-$KnownFS{clic}{ro}        = 1;
-$KnownFS{unified}{ro}     = 1;
-$KnownFS{compressed}{ro}  = 1;
-$KnownFS{reiserfs}{ro}    = 0;
-$KnownFS{btrfs}{ro}       = 0;
-$KnownFS{xfs}{ro}         = 0;
-$KnownFS{cpio}{ro}        = 0;
 
 #============================================
 # Globals
@@ -222,40 +144,13 @@ our $MBRID;                 # custom mbrid value
 our $ListXMLInfo;           # list XML information
 our $kic;                   # global Image Creator object
 our $icache;                # global Image Cache object
+our $Partitioner = &quot;parted&quot;;# default partitioner
 
 #============================================
 # Globals
 #--------------------------------------------
 my $migrate;    # KIWIMigrate object for system to image migration
 
-#============================================
-# createDirInteractive
-#--------------------------------------------
-sub createDirInteractive {
-	my $kiwi = shift;
-	my $targetDir = shift;
-	if (! -d $targetDir) {
-		my $prefix = $kiwi -&gt; getPrefix (1);
-		my $answer = (defined $defaultAnswer) ? &quot;yes&quot; : &quot;unknown&quot;;
-		$kiwi -&gt; info (&quot;Destination: $Destination doesn't exist\n&quot;);
-		while ($answer !~ /^yes$|^no$/) {
-			print STDERR $prefix,
-				&quot;Would you like kiwi to create it [yes/no] ? &quot;;
-			chomp ($answer = &lt;&gt;);
-		}
-		if ($answer eq &quot;yes&quot;) {
-			qxx (&quot;mkdir -p $Destination&quot;);
-			return 1;
-		}
-	} else {
-		# Directory exists
-		return 1;
-	}
-	# Directory does not exist and user did
-	# not request dir creation.
-	return undef;
-}
-
 #==========================================
 # main
 #------------------------------------------
@@ -267,6 +162,7 @@ sub main {
 	# of a XML control file. Once prepared KIWI can create several
 	# OS image types.
 	# ---
+	my $gdata = $global -&gt; getGlobals();
 	#==========================================
 	# Initialize and check options
 	#------------------------------------------
@@ -275,7 +171,7 @@ sub main {
 	# Create logger object
 	#------------------------------------------
 	if (! defined $kiwi) {
-		$kiwi = new KIWILog();
+		$kiwi = new KIWILog ($gdata-&gt;{LogServerPort});
 	}
 	#==========================================
 	# remove pre-defined smart channels
@@ -308,7 +204,9 @@ sub main {
 		#==========================================
 		# Create destdir if needed
 		#------------------------------------------
-		my $dirCreated = createDirInteractive($kiwi, $Destination);
+		my $dirCreated = $global -&gt; createDirInteractive(
+			$Destination, $defaultAnswer
+		);
 		if (! defined $dirCreated) {
 			my $code = kiwiExit (1); return $code;
 		}
@@ -328,9 +226,6 @@ sub main {
 		# Setup create 
 		#------------------------------------------
 		$ImageDescription = $rootTarget;
-		if ((! -d $rootTarget) &amp;&amp; (open FD,&quot;$rootTarget/image/main::Prepare&quot;)) {
-			$ImageDescription = &lt;FD&gt;; close FD;
-		}
 		$cmdL -&gt; setImagetargetDir ($Destination);
 		$cmdL -&gt; setConfigDir ($ImageDescription);
 		$cmdL -&gt; setForceNewRoot (0);
@@ -338,6 +233,7 @@ sub main {
 		if (! $kic -&gt; createImage ($kiwi,$cmdL)) {
 			my $code = kiwiExit (1); return $code;
 		}
+		kiwiExit (0);
 	}
 
 	#========================================
@@ -366,7 +262,7 @@ sub main {
 			$cdir = $locator -&gt; getDefaultCacheDir();
 		}
 		$icache = new KIWICache (
-			$kiwi,$xml,$cdir,$BasePath,\@Profiles,$InitCache
+			$kiwi,$xml,$cdir,$gdata-&gt;{BasePath},\@Profiles,$InitCache
 		);
 		if (! $icache) {
 			my $code = kiwiExit (1); return $code;
@@ -721,6 +617,7 @@ sub init {
 	$SIG{&quot;HUP&quot;}      = \&quit;
 	$SIG{&quot;TERM&quot;}     = \&quit;
 	$SIG{&quot;INT&quot;}      = \&quit;
+	my $gdata = $global -&gt; getGlobals();
 	my $Help;
 	my @ListXMLInfoSelection;  # info selection for listXMLInfo
 	my $PackageManager;
@@ -812,6 +709,25 @@ sub init {
 		&quot;yes|y&quot;                 =&gt; \$defaultAnswer,
 	);
 	#========================================
+	# set list of filesystem options
+	#----------------------------------------
+	$cmdL -&gt; setFilesystemOptions (
+		$FSBlockSize,$FSInodeSize,$FSInodeRatio,$FSJournalSize,
+		$FSMaxMountCount,$FSCheckInterval
+	);
+	#========================================
+	# check if MBRID is specified
+	#----------------------------------------
+	if (defined $MBRID) {
+		$cmdL -&gt; setMBRID ($MBRID);
+	}
+	#========================================
+	# check if default answer is specified
+	#----------------------------------------
+	if (defined $defaultAnswer) {
+		$cmdL -&gt; setDefaultAnswer ($defaultAnswer);
+	}
+	#========================================
 	# check if initrd needs to be stored
 	#----------------------------------------
 	if (defined $SetupSplash) {
@@ -992,13 +908,13 @@ sub init {
 	}
 	if (defined $Prepare) {
 		if (($Prepare !~ /^\//) &amp;&amp; (! -d $Prepare)) {
-			$Prepare = $System.&quot;/&quot;.$Prepare;
+			$Prepare = $gdata-&gt;{System}.&quot;/&quot;.$Prepare;
 		}
 		$Prepare =~ s/\/$//;
 	}
 	if (defined $Create) {
 		if (($Create !~ /^\//) &amp;&amp; (! -d $Create)) {
-			$Create = $System.&quot;/&quot;.$Create;
+			$Create = $gdata-&gt;{System}.&quot;/&quot;.$Create;
 		}
 		$Create =~ s/\/$//;
 	}
@@ -1015,9 +931,6 @@ sub init {
 	}
 	if (defined $Create) {
 		$ImageDescription = $Create;
-		if ((! -d $Create) &amp;&amp; (open FD,&quot;$Create/image/main::Prepare&quot;)) {
-			$ImageDescription = &lt;FD&gt;; close FD;
-		}
 		$cmdL -&gt; setConfigDir ($ImageDescription);
 	}
 	#========================================
@@ -1141,12 +1054,12 @@ sub init {
 	}
 	if (defined $LogPort) {
 		$kiwi -&gt; info (&quot;Setting log server port to: $LogPort&quot;);
-		$LogServerPort = $LogPort;
+		$global -&gt; setGlobals (&quot;LogServerPort&quot;, $LogPort);
 		$kiwi -&gt; done ();
 	}
 	if (defined $GzipCmd) {
 		$kiwi -&gt; info (&quot;Setting gzip command to: $GzipCmd&quot;);
-		$Gzip = $GzipCmd;
+		$global -&gt; setGlobals (&quot;Gzip&quot;, $GzipCmd);
 		$kiwi -&gt; done ();
 	}
 	if ((defined $BootVMDisk) &amp;&amp; (! defined $BootVMSystem)) {
@@ -1440,26 +1353,28 @@ sub listImage {
 	# ...
 	# list known image descriptions and exit
 	# ---
-	my $kiwi = new KIWILog(&quot;tiny&quot;);
-	opendir (FD,$System);
+	my $kiwi   = new KIWILog(&quot;tiny&quot;);
+	my $gdata  = $global -&gt; getGlobals();
+	my $system = $gdata-&gt;{System};
+	opendir (FD,$system);
 	my @images = readdir (FD); closedir (FD);
 	foreach my $image (@images) {
 		if ($image =~ /^\./) {
 			next;
 		}
-		if (-l &quot;$System/$image&quot;) {
+		if (-l &quot;$system/$image&quot;) {
 			next;
 		}
 		if ($image =~ /(iso|net|oem|vmx)boot/) {
 			next;
 		}
 		my $controlFile = $locator -&gt; getControlFile (
-			&quot;$System/$image&quot;
+			&quot;$system/$image&quot;
 		);
 		if ($controlFile) {
 			$kiwi -&gt; info ($image);
 			my $xml = new KIWIXML (
-				$kiwi,$System.&quot;/&quot;.$image,undef,undef
+				$kiwi,$system.&quot;/&quot;.$image,undef,undef
 			);
 			if (! $xml) {
 				next;
@@ -1479,7 +1394,8 @@ sub checkConfig {
 	# ...
 	# Check the specified configuration file
 	# ---
-	my $kiwi = new KIWILog(&quot;tiny&quot;);
+	my $kiwi  = new KIWILog(&quot;tiny&quot;);
+	my $gdata = $global -&gt; getGlobals();
 	if (! -f $CheckConfig) {
 		$kiwi -&gt; error (
 			&quot;Could not access specified file to check: $CheckConfig&quot;
@@ -1488,7 +1404,8 @@ sub checkConfig {
 		exit 1;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$CheckConfig,$Revision,$Schema,$SchemaCVT
+		$kiwi,$CheckConfig,$gdata-&gt;{Revision},
+		$gdata-&gt;{Schema},$gdata-&gt;{SchemaCVT}
 	);
 	if (! $validator) {
 		exit 1;
@@ -1514,7 +1431,10 @@ sub cloneImage {
 	# existing checksum will be removed as we assume
 	# that the clone will be changed
 	# ----
-	my $answer = &quot;unknown&quot;;
+	my $answer     = &quot;unknown&quot;;
+	my $gdata      = $global -&gt; getGlobals();
+	my $configName = $gdata-&gt;{ConfigName};
+	my $system     = $gdata-&gt;{System};
 	#==========================================
 	# Check destination definition
 	#------------------------------------------
@@ -1530,9 +1450,9 @@ sub cloneImage {
 	# Evaluate image path or name 
 	#------------------------------------------
 	if (($Clone !~ /^\//) &amp;&amp; (! -d $Clone)) {
-		$Clone = $main::System.&quot;/&quot;.$Clone;
+		$Clone = $system.&quot;/&quot;.$Clone;
 	}
-	my $cfg = $Clone.&quot;/&quot;.$main::ConfigName;
+	my $cfg = $Clone.&quot;/&quot;.$configName;
 	my $md5 = $Destination.&quot;/.checksum.md5&quot;;
 	if (! -f $cfg) {
 		my @globsearch = glob ($Clone.&quot;/*.kiwi&quot;);
@@ -1600,11 +1520,12 @@ sub kiwiExit {
 	# private Exit function, exit safely
 	# ---
 	my $code = $_[0];
+	my $gdata= $global -&gt; getGlobals();
 	#==========================================
 	# Write temporary XML changes to logfile
 	#------------------------------------------
 	if (defined $kiwi) {
-		$kiwi -&gt; writeXML();
+		$kiwi -&gt; writeXML ($gdata-&gt;{Pretty});
 	}
 	#==========================================
 	# Create log object if we don't have one...
@@ -1686,7 +1607,8 @@ sub version {
 	# ...
 	# Version information
 	# ---
-	my $exit = shift;
+	my $exit  = shift;
+	my $gdata = $global -&gt; getGlobals();
 	if (! defined $exit) {
 		$exit = 0;
 	}
@@ -1694,10 +1616,10 @@ sub version {
 		$kiwi = new KIWILog(&quot;tiny&quot;);
 	}
 	my $rev  = &quot;unknown&quot;;
-	if (open FD,$Revision) {
+	if (open FD,$gdata-&gt;{Revision}) {
 		$rev = &lt;FD&gt;; close FD;
 	}
-	$kiwi -&gt; info (&quot;kiwi version v$Version\nGIT Commit: $rev\n&quot;);
+	$kiwi -&gt; info (&quot;kiwi version v$gdata-&gt;{Version}\nGIT Commit: $rev\n&quot;);
 	$kiwi -&gt; cleanSweep();
 	exit ($exit);
 }
@@ -1750,6 +1672,7 @@ sub createPassword {
 	$kiwi -&gt; info (&quot;Your password:\n\t$encrypted\n&quot;);
 	my $code = kiwiExit (0); return $code;
 }
+
 #==========================================
 # createHash
 #------------------------------------------
@@ -1789,265 +1712,6 @@ sub createHash {
 }
 
 #==========================================
-# checkFSOptions
-#------------------------------------------
-sub checkFSOptions {
-	# /.../
-	# checks the $FS* option values and build an option
-	# string for the relevant filesystems
-	# ---
-	my %result = ();
-	my $fs_maxmountcount;
-	my $fs_checkinterval;
-	foreach my $fs (keys %KnownFS) {
-		my $blocksize;   # block size in bytes
-		my $journalsize; # journal size in MB (ext) or blocks (reiser)
-		my $inodesize;   # inode size in bytes (ext only)
-		my $inoderatio;  # bytes/inode ratio
-		my $fsfeature;   # filesystem features (ext only)
-		SWITCH: for ($fs) {
-			#==========================================
-			# EXT2-4
-			#------------------------------------------
-			/ext[432]/   &amp;&amp; do {
-				if ($FSBlockSize)   {$blocksize   = &quot;-b $FSBlockSize&quot;}
-				if (($FSInodeSize) &amp;&amp; ($FSInodeSize != 256)) {
-					$inodesize = &quot;-I $FSInodeSize&quot;
-				}
-				if ($FSInodeRatio)  {$inoderatio  = &quot;-i $FSInodeRatio&quot;}
-				if ($FSJournalSize) {$journalsize = &quot;-J size=$FSJournalSize&quot;}
-				if ($FSMaxMountCount) {
-					$fs_maxmountcount = &quot; -c $FSMaxMountCount&quot;;
-				}
-				if ($FSCheckInterval) {
-					$fs_checkinterval = &quot; -i $FSCheckInterval&quot;;
-				}
-				$fsfeature = &quot;-F -O resize_inode&quot;;
-				last SWITCH;
-			};
-			#==========================================
-			# reiserfs
-			#------------------------------------------
-			/reiserfs/  &amp;&amp; do {
-				if ($FSBlockSize)   {$blocksize   = &quot;-b $FSBlockSize&quot;}
-				if ($FSJournalSize) {$journalsize = &quot;-s $FSJournalSize&quot;}
-				last SWITCH;
-			};
-			# no options for this filesystem...
-		};
-		if (defined $inodesize) {
-			$result{$fs} .= $inodesize.&quot; &quot;;
-		}
-		if (defined $inoderatio) {
-			$result{$fs} .= $inoderatio.&quot; &quot;;
-		}
-		if (defined $blocksize) {
-			$result{$fs} .= $blocksize.&quot; &quot;;
-		}
-		if (defined $journalsize) {
-			$result{$fs} .= $journalsize.&quot; &quot;;
-		}
-		if (defined $fsfeature) {
-			$result{$fs} .= $fsfeature.&quot; &quot;;
-		}
-	}
-	if ($fs_maxmountcount || $fs_checkinterval) {
-		$result{extfstune} = &quot;$fs_maxmountcount$fs_checkinterval&quot;;
-	}
-	return %result;
-}
-
-#==========================================
-# mount
-#------------------------------------------
-sub mount {
-	# /.../
-	# implements a generic mount function for all supported
-	# file system types
-	# ---
-	my $source= shift;
-	my $dest  = shift;
-	my $salt  = int (rand(20));
-	my %fsattr = main::checkFileSystem ($source);
-	my $type   = $fsattr{type};
-	my $cipher = $main::LuksCipher;
-	my $status;
-	my $result;
-	#==========================================
-	# Check result of filesystem detection
-	#------------------------------------------
-	if (! %fsattr) {
-		$kiwi -&gt; error  (&quot;Couldn't detect filesystem on: $source&quot;);
-		$kiwi -&gt; failed ();
-		return undef;
-	}
-	#==========================================
-	# Check for DISK file
-	#------------------------------------------
-	if (-f $source) {
-		my $boot = &quot;'boot sector'&quot;;
-		my $null = &quot;/dev/null&quot;;
-		$status= qxx (
-			&quot;dd if=$source bs=512 count=1 2&gt;$null|file - | grep -q $boot&quot;
-		);
-		$result= $? &gt;&gt; 8;
-		if ($result == 0) {			
-			$status = qxx (&quot;/sbin/losetup -s -f $source 2&gt;&amp;1&quot;); chomp $status;
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				$kiwi -&gt; error  (
-					&quot;Couldn't loop bind disk file: $status&quot;
-				);
-				$kiwi -&gt; failed (); umount();
-				return undef;
-			}
-			my $loop = $status;
-			push @UmountStack,&quot;losetup -d $loop&quot;;
-			$status = qxx (&quot;kpartx -a $loop 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				$kiwi -&gt; error (
-					&quot;Couldn't loop bind disk partition(s): $status&quot;
-				);
-				$kiwi -&gt; failed (); umount();
-				return undef;
-			}
-			push @UmountStack,&quot;kpartx -d $loop&quot;;
-			$loop =~ s/\/dev\///;
-			$source = &quot;/dev/mapper/&quot;.$loop.&quot;p1&quot;;
-			if (! -b $source) {
-				$kiwi -&gt; error (&quot;No such block device $source&quot;);
-				$kiwi -&gt; failed (); umount();
-				return undef;
-			}
-		}
-	}
-	#==========================================
-	# Check for LUKS extension
-	#------------------------------------------
-	if ($type eq &quot;luks&quot;) {
-		if (-f $source) {
-			$status = qxx (&quot;/sbin/losetup -s -f $source 2&gt;&amp;1&quot;); chomp $status;
-			$result = $? &gt;&gt; 8;
-			if ($result != 0) {
-				$kiwi -&gt; error  (&quot;Couldn't loop bind logical extend: $status&quot;);
-				$kiwi -&gt; failed (); umount();
-				return undef;
-			}
-			$source = $status;
-			push @UmountStack,&quot;losetup -d $source&quot;;
-		}
-		if ($cipher) {
-			$status = qxx (
-				&quot;echo $cipher | cryptsetup luksOpen $source luks-$salt 2&gt;&amp;1&quot;
-			);
-		} else {
-			$status = qxx (&quot;cryptsetup luksOpen $source luks-$salt 2&gt;&amp;1&quot;);
-		}
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; error  (&quot;Couldn't open luks device: $status&quot;);
-			$kiwi -&gt; failed (); umount();
-			return undef;
-		}
-		$source = &quot;/dev/mapper/luks-&quot;.$salt;
-		push @UmountStack,&quot;cryptsetup luksClose luks-$salt&quot;;
-	}
-	#==========================================
-	# Mount device or loop mount file
-	#------------------------------------------
-	if ((-f $source) &amp;&amp; ($type ne &quot;clicfs&quot;)) {
-		$status = qxx (&quot;mount -o loop $source $dest 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; error (&quot;Failed to loop mount $source to: $dest: $status&quot;);
-			$kiwi -&gt; failed (); umount();
-			return undef;
-		}
-	} else {
-		if ($type eq &quot;clicfs&quot;) {
-			$status = qxx (&quot;clicfs -m 512 $source $dest 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-			if ($result == 0) {
-				$status = qxx (&quot;resize2fs $dest/fsdata.ext3 2&gt;&amp;1&quot;);
-				$result = $? &gt;&gt; 8;
-			}
-		} else {
-			$status = qxx (&quot;mount $source $dest 2&gt;&amp;1&quot;);
-			$result = $? &gt;&gt; 8;
-		}
-		if ($result != 0) {
-			$kiwi -&gt; error (&quot;Failed to mount $source to: $dest: $status&quot;);
-			$kiwi -&gt; failed (); umount();
-			return undef;
-		}
-	}
-	push @UmountStack,&quot;umount $dest&quot;;
-	#==========================================
-	# Post mount actions
-	#------------------------------------------
-	if (-f $dest.&quot;/fsdata.ext3&quot;) {
-		$source = $dest.&quot;/fsdata.ext3&quot;;
-		$status = qxx (&quot;mount -o loop $source $dest 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; error (&quot;Failed to loop mount $source to: $dest: $status&quot;);
-			$kiwi -&gt; failed (); umount();
-			return undef;
-		}
-		push @UmountStack,&quot;umount $dest&quot;;
-	}
-	return $dest;
-}
-
-#==========================================
-# umount
-#------------------------------------------
-sub umount {
-	# /.../
-	# implements an umount function for filesystems mounted
-	# via main::mount(). The function walks through the
-	# contents of the UmountStack list
-	# ---
-	my $status;
-	my $result;
-	qxx (&quot;sync&quot;);
-	foreach my $cmd (reverse @UmountStack) {
-		$status = qxx (&quot;$cmd 2&gt;&amp;1&quot;);
-		$result = $? &gt;&gt; 8;
-		if ($result != 0) {
-			$kiwi -&gt; warning (&quot;UmountStack failed: $cmd: $status\n&quot;);
-		}
-	}
-	@UmountStack = ();
-}
-
-#==========================================
-# isize
-#------------------------------------------
-sub isize {
-	# /.../
-	# implements a size function like the -s operator
-	# but also works for block specials using blockdev
-	# ---
-	my $target = shift;
-	if (! defined $target) {
-		return 0;
-	}
-	if (-b $target) {
-		my $size = qxx (&quot;blockdev --getsize64 $target 2&gt;&amp;1&quot;);
-		my $code = $? &gt;&gt; 8;
-		if ($code == 0) {
-			chomp  $size;
-			return $size;
-		}
-	} elsif (-f $target) {
-		return -s $target;
-	}
-	return 0;
-}
-
-#==========================================
 # createInstSource
 #------------------------------------------
 sub createInstSource {
@@ -2117,132 +1781,6 @@ sub createInstSource {
 	kiwiExit (0);
 }
 
-#==========================================
-# getMBRDiskLabel
-#------------------------------------------
-sub getMBRDiskLabel {
-	# ...
-	# set the mbrid to either the value given at the
-	# commandline or a random 4byte MBR disk label ID
-	# ---
-	my $this  = shift;
-	my $range = 0xfe;
-	if (defined $main::MBRID) {
-		return $main::MBRID;
-	} else {
-		my @bytes;
-		for (my $i=0;$i&lt;4;$i++) {
-			$bytes[$i] = 1 + int(rand($range));
-			redo if $bytes[0] &lt;= 0xf;
-		}
-		my $nid = sprintf (&quot;0x%02x%02x%02x%02x&quot;,
-			$bytes[0],$bytes[1],$bytes[2],$bytes[3]
-		);
-		return $nid;
-	}
-}
-
-#==========================================
-# checkFileSystem
-#------------------------------------------
-sub checkFileSystem {
-	# /.../
-	# checks attributes of the given filesystem(s) and returns
-	# a summary hash containing the following information
-	# ---
-	# $filesystem{hastool}  --&gt; has the tool to create the filesystem
-	# $filesystem{readonly} --&gt; is a readonly filesystem
-	# $filesystem{type}     --&gt; what filesystem type is this
-	# ---
-	my $fs     = shift;
-	my %result = ();
-	if (defined $main::KnownFS{$fs}) {
-		#==========================================
-		# got a known filesystem type
-		#------------------------------------------
-		$result{type}     = $fs;
-		$result{readonly} = $main::KnownFS{$fs}{ro};
-		$result{hastool}  = 0;
-		if (($main::KnownFS{$fs}{tool}) &amp;&amp; (-x $main::KnownFS{$fs}{tool})) {
-			$result{hastool} = 1;
-		}
-	} else {
-		#==========================================
-		# got a file, block special or something
-		#------------------------------------------
-		if (-e $fs) {
-			my $data = qxx (&quot;dd if=$fs bs=128k count=1 2&gt;/dev/null | file -&quot;);
-			my $code = $? &gt;&gt; 8;
-			my $type;
-			if ($code != 0) {
-				if ($main::kiwi -&gt; trace()) {
-					$main::BT.=eval { Carp::longmess ($main::TT.$main::TL++) };
-				}
-				return undef;
-			}
-			SWITCH: for ($data) {
-				/ext4/      &amp;&amp; do {
-					$type = &quot;ext4&quot;;
-					last SWITCH;
-				};
-				/ext3/      &amp;&amp; do {
-					$type = &quot;ext3&quot;;
-					last SWITCH;
-				};
-				/ext2/      &amp;&amp; do {
-					$type = &quot;ext2&quot;;
-					last SWITCH;
-				};
-				/ReiserFS/  &amp;&amp; do {
-					$type = &quot;reiserfs&quot;;
-					last SWITCH;
-				};
-				/BTRFS/     &amp;&amp; do {
-					$type = &quot;btrfs&quot;;
-					last SWITCH;
-				};
-				/Squashfs/  &amp;&amp; do {
-					$type = &quot;squashfs&quot;;
-					last SWITCH;
-				};
-				/LUKS/      &amp;&amp; do {
-					$type = &quot;luks&quot;;
-					last SWITCH;
-				};
-				/XFS/     &amp;&amp; do {
-					$type = &quot;xfs&quot;;
-					last SWITCH;
-				};
-				# unknown filesystem type check clicfs...
-				$data = qxx (
-					&quot;dd if=$fs bs=128k count=1 2&gt;/dev/null | grep -q CLIC&quot;
-				);
-				$code = $? &gt;&gt; 8;
-				if ($code == 0) {
-					$type = &quot;clicfs&quot;;
-					last SWITCH;
-				}
-				# unknown filesystem type use auto...
-				$type = &quot;auto&quot;;
-			};
-			$result{type}     = $type;
-			$result{readonly} = $main::KnownFS{$type}{ro};
-			$result{hastool}  = 0;
-			if (defined $main::KnownFS{$type}{tool}) {
-				if (-x $main::KnownFS{$type}{tool}) {
-					$result{hastool} = 1;
-				}
-			}
-		} else {
-			if ($main::kiwi -&gt; trace()) {
-				$main::BT.=eval { Carp::longmess ($main::TT.$main::TL++) };
-			}
-			return ();
-		}
-	}
-	return %result;
-}
-
 main();
 
 # vim: set noexpandtab:
diff --git a/modules/KIWIBoot.pm b/modules/KIWIBoot.pm
index ea586b6..ba368aa 100644
--- a/modules/KIWIBoot.pm
+++ b/modules/KIWIBoot.pm
@@ -54,6 +54,7 @@ sub new {
 	#------------------------------------------
 	my $kiwi   = shift;
 	my $initrd = shift;
+	my $cmdL   = shift;
 	my $system = shift;
 	my $vmsize = shift;
 	my $device = shift;
@@ -117,9 +118,9 @@ sub new {
 	#------------------------------------------
 	if (defined $system) {
 		if ((-f $system) || (-b $system)) {
-			my %fsattr = main::checkFileSystem ($system);
+			my %fsattr = $main::global -&gt; checkFileSystem ($system);
 			if ($fsattr{readonly}) {
-				$syszip = main::isize ($system);
+				$syszip = $main::global -&gt; isize ($system);
 			} else {
 				$syszip = 0;
 			}
@@ -209,6 +210,7 @@ sub new {
 	#==========================================
 	# Store object data (1)
 	#------------------------------------------
+	$this-&gt;{gdata}    = $main::global -&gt; getGlobals();
 	$this-&gt;{tmpdir}   = $tmpdir;
 	$this-&gt;{loopdir}  = $loopdir;
 	$this-&gt;{lvmgroup} = $vgroup;
@@ -224,8 +226,10 @@ sub new {
 			my $locator = new KIWILocator($kiwi);
 			my $controlFile = $locator -&gt; getControlFile ($system.&quot;/image&quot;);
 			my $validator = new KIWIXMLValidator (
-				$kiwi,$controlFile,$main::Revision,
-				$main::Schema,$main::SchemaCVT
+				$kiwi,$controlFile,
+				$this-&gt;{gdata}-&gt;{Revision},
+				$this-&gt;{gdata}-&gt;{Schema},
+				$this-&gt;{gdata}-&gt;{SchemaCVT}
 			);
 			my $isValid = $validator ? $validator -&gt; validate() : undef;
 			if (! $isValid) {
@@ -235,7 +239,7 @@ sub new {
 				$kiwi,$system.&quot;/image&quot;,$main::SetImageType,$profile
 			);
 		} else {
-			my %fsattr = main::checkFileSystem ($system);
+			my %fsattr = $main::global -&gt; checkFileSystem ($system);
 			if ((! $fsattr{type}) || ($fsattr{type} eq &quot;auto&quot;)) {
 				#==========================================
 				# bind $system to loop device
@@ -267,7 +271,7 @@ sub new {
 				#==========================================
 				# perform mount call
 				#------------------------------------------
-				if (! main::mount($sdev, $tmpdir)) {
+				if (! $main::global -&gt; mount($sdev, $tmpdir)) {
 					$kiwi -&gt; error (&quot;System image mount failed: $status&quot;);
 					$kiwi -&gt; failed ();
 					$this -&gt; cleanLoop ();
@@ -279,8 +283,10 @@ sub new {
 				my $locator = new KIWILocator($kiwi);
 				my $controlFile = $locator -&gt; getControlFile ($tmpdir.&quot;/image&quot;);
 				my $validator = new KIWIXMLValidator (
-					$kiwi,$controlFile,$main::Revision,
-					$main::Schema,$main::SchemaCVT
+					$kiwi,$controlFile,
+					$this-&gt;{gdata}-&gt;{Revision},
+					$this-&gt;{gdata}-&gt;{Schema},
+					$this-&gt;{gdata}-&gt;{SchemaCVT}
 				);
 				my $isValid = $validator ? $validator -&gt; validate() : undef;
 				if (! $isValid) {
@@ -298,7 +304,7 @@ sub new {
 				#==========================================
 				# loop mount system image
 				#------------------------------------------
-				if (! main::mount ($system,$tmpdir)) {
+				if (! $main::global -&gt; mount ($system,$tmpdir)) {
 					return undef;
 				}
 				#==========================================
@@ -314,12 +320,14 @@ sub new {
 				my $locator = new KIWILocator($kiwi);
 				my $controlFile = $locator -&gt; getControlFile ($tmpdir.&quot;/image&quot;);
 				my $validator = new KIWIXMLValidator (
-					$kiwi,$controlFile,$main::Revision,
-					$main::Schema,$main::SchemaCVT
+					$kiwi,$controlFile,
+					$this-&gt;{gdata}-&gt;{Revision},
+					$this-&gt;{gdata}-&gt;{Schema},
+					$this-&gt;{gdata}-&gt;{SchemaCVT}
 				);
 				my $isValid = $validator ? $validator -&gt; validate() : undef;
 				if (! $isValid) {
-					main::umount();
+					$main::global -&gt; umount();
 					return undef;
 				}
 				$xml = new KIWIXML (
@@ -328,7 +336,7 @@ sub new {
 				#==========================================
 				# clean up
 				#------------------------------------------
-				main::umount();
+				$main::global -&gt; umount();
 			}
 		}
 		if (! defined $xml) {
@@ -371,7 +379,7 @@ sub new {
 			$sizeBytes+= $journal;
 		} else {
 			# system is specified as a file...
-			$sizeBytes = main::isize ($system);
+			$sizeBytes = $main::global -&gt; isize ($system);
 			$sizeBytes*= 1.1;
 		}
 		#==========================================
@@ -407,8 +415,8 @@ sub new {
 			# if system is a split system the vmsize will be
 			# adapted within the image creation function accordingly
 			# ----
-			my $kernelSize = main::isize ($kernel);
-			my $initrdSize = main::isize ($initrd);
+			my $kernelSize = $main::global -&gt; isize ($kernel);
+			my $initrdSize = $main::global -&gt; isize ($initrd);
 			$vmsize = $kernelSize + ($initrdSize * 1.5) + $sizeBytes;
 		}
 		#==========================================
@@ -446,7 +454,9 @@ sub new {
 	#==========================================
 	# Store a disk label ID for this object
 	#------------------------------------------
-	$this-&gt;{mbrid} = main::getMBRDiskLabel();
+	$this-&gt;{mbrid} = $main::global -&gt; getMBRDiskLabel (
+		$cmdL -&gt; getMBRID()
+	);
 	#==========================================
 	# find system architecture
 	#------------------------------------------
@@ -460,7 +470,7 @@ sub new {
 			$vga = $type{vga};
 		}
 		if ($type{luks}) {
-			$main::LuksCipher = $type{luks};
+			$main::global -&gt; setGlobals (&quot;LuksCipher&quot;,$type{luks});
 		}
 	}
 	#==========================================
@@ -481,6 +491,7 @@ sub new {
 	$this-&gt;{chainload} = $main::GrubChainload;
 	$this-&gt;{vga}       = $vga;
 	$this-&gt;{xml}       = $xml;
+	$this-&gt;{cmdL}      = $cmdL;
 	$this-&gt;{xendomain} = $xendomain;
 	$this-&gt;{profile}   = $profile;
 	$this-&gt;{haveSplit} = $haveSplit;
@@ -505,6 +516,7 @@ sub createBootStructure {
 	my $lname  = &quot;linux&quot;;
 	my $iname  = &quot;initrd&quot;;
 	my $xname  = &quot;xen.gz&quot;;
+	my $zipper = $this-&gt;{gdata}-&gt;{Gzip};
 	my $status;
 	my $result;
 	if (defined $loc) {
@@ -530,11 +542,11 @@ sub createBootStructure {
 			# deflate/inflate initrd to make xen happy
 			my $irdunc = $initrd;
 			$irdunc =~ s/\.gz//;
-			qxx (&quot;$main::Gzip -d $initrd &amp;&amp; $main::Gzip $irdunc&quot;);
+			qxx (&quot;$zipper -d $initrd &amp;&amp; $zipper $irdunc&quot;);
 		}
 		$status = qxx ( &quot;cp $initrd $tmpdir/boot/$iname 2&gt;&amp;1&quot; );
 	} else {
-		$status = qxx ( &quot;cat $initrd | $main::Gzip &gt; $tmpdir/boot/$iname&quot; );
+		$status = qxx ( &quot;cat $initrd | $zipper &gt; $tmpdir/boot/$iname&quot; );
 	}
 	$result = $? &gt;&gt; 8;
 	if ($result != 0) {
@@ -754,7 +766,7 @@ sub setupInstallCD {
 		#==========================================
 		# perform mount call
 		#------------------------------------------
-		if (! main::mount ($sdev, $tmpdir)) {
+		if (! $main::global -&gt; mount ($sdev, $tmpdir)) {
 			$kiwi -&gt; error (&quot;Failed to mount system partition: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
@@ -996,7 +1008,8 @@ sub setupInstallStick {
 	my $zipped    = $this-&gt;{zipped};
 	my $isxen     = $this-&gt;{isxen};
 	my $xml       = $this-&gt;{xml};
-	my $irdsize   = main::isize ($initrd);
+	my $cmdL      = $this-&gt;{cmdL};
+	my $irdsize   = $main::global -&gt; isize ($initrd);
 	my $diskname  = $system.&quot;.install.raw&quot;;
 	my $md5name   = $system;
 	my $destdir   = dirname ($initrd);
@@ -1113,7 +1126,7 @@ sub setupInstallStick {
 		#==========================================
 		# perform mount call
 		#------------------------------------------
-		if (! main::mount ($sdev, $tmpdir)) {
+		if (! $main::global -&gt; mount ($sdev, $tmpdir)) {
 			$kiwi -&gt; error  (&quot;Failed to mount system partition: $status&quot;);
 			$kiwi -&gt; failed ();
 			$this -&gt; cleanLoop ();
@@ -1159,7 +1172,7 @@ sub setupInstallStick {
 	#------------------------------------------
 	$irdsize= ($irdsize / 1e6) + 20;
 	$irdsize= sprintf (&quot;%.0f&quot;, $irdsize);
-	$vmsize = main::isize ($system);
+	$vmsize = $main::global -&gt; isize ($system);
 	$vmsize = ($vmsize / 1e6) * 1.3 + $irdsize;
 	$vmsize = sprintf (&quot;%.0f&quot;, $vmsize);
 	$vmsize = $vmsize.&quot;M&quot;;
@@ -1320,7 +1333,9 @@ sub setupInstallStick {
 	foreach my $root ($boot,$data) {
 		next if ! defined $root;
 		$kiwi -&gt; info (&quot;Creating ext3 filesystem on $root partition&quot;);
-		my %FSopts = main::checkFSOptions();
+		my %FSopts = $main::global -&gt; checkFSOptions(
+			@{$cmdL -&gt; getFilesystemOptions()}
+		);
 		my $fsopts = $FSopts{ext3};
 		my $fstool = &quot;mkfs.ext3&quot;;
 		if (($root eq $data) &amp;&amp; ($this-&gt;{inodes})) {
@@ -1341,7 +1356,7 @@ sub setupInstallStick {
 	# Copy boot data on first partition
 	#------------------------------------------
 	$kiwi -&gt; info (&quot;Installing boot data to disk&quot;);
-	if (! main::mount ($boot, $loopdir)) {
+	if (! $main::global -&gt; mount ($boot, $loopdir)) {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Couldn't mount boot partition: $status&quot;);
 		$kiwi -&gt; failed ();
@@ -1357,7 +1372,7 @@ sub setupInstallStick {
 		$this -&gt; cleanLoop ();
 		return undef;
 	}
-	main::umount();
+	$main::global -&gt; umount();
 	$kiwi -&gt; done();
 	#==========================================
 	# Check for optional config-cdroot archive
@@ -1410,7 +1425,7 @@ sub setupInstallStick {
 	#------------------------------------------
 	if ($gotsys) {
 		$kiwi -&gt; info (&quot;Installing image data to disk&quot;);
-		if (! main::mount($data, $loopdir)) {
+		if (! $main::global -&gt; mount($data, $loopdir)) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Couldn't mount data partition: $status&quot;);
 			$kiwi -&gt; failed ();
@@ -1435,7 +1450,7 @@ sub setupInstallStick {
 		}
 		print FD &quot;IMAGE=$nameusb\n&quot;;
 		close FD;
-		main::umount();
+		$main::global -&gt; umount();
 		$kiwi -&gt; done();
 	}
 	#==========================================
@@ -1481,6 +1496,7 @@ sub setupBootDisk {
 	my $profile   = $this-&gt;{profile};
 	my $xendomain = $this-&gt;{xendomain};
 	my $xml       = $this-&gt;{xml};
+	my $cmdL      = $this-&gt;{cmdL};
 	my $haveTree  = $this-&gt;{haveTree};
 	my $imgtype   = $this-&gt;{imgtype};
 	my $haveSplit = $this-&gt;{haveSplit};
@@ -1701,7 +1717,8 @@ sub setupBootDisk {
 	# increase vmsize if image split portion
 	#------------------------------------------
 	if (($imgtype eq &quot;split&quot;) &amp;&amp; (-f $splitfile)) {
-		my $splitsize = main::isize ($splitfile); $splitsize /= 1048576;
+		my $splitsize = $main::global -&gt; isize ($splitfile);
+		$splitsize /= 1048576;
 		$vmsize = $this-&gt;{vmmbyte} + ($splitsize * 1.5) + $lvmbootMB;
 		$vmsize = sprintf (&quot;%.0f&quot;, $vmsize);
 		$this-&gt;{vmmbyte} = $vmsize;
@@ -1729,7 +1746,7 @@ sub setupBootDisk {
 		$FSTypeRO = $FSTypeRW;
 	}
 	if ($haveSplit) {
-		my %fsattr = main::checkFileSystem ($FSTypeRW);
+		my %fsattr = $main::global -&gt; checkFileSystem ($FSTypeRW);
 		if ($fsattr{readonly}) {
 			$kiwi -&gt; error (&quot;Can't copy data into requested RO filesystem&quot;);
 			$kiwi -&gt; failed ();
@@ -2018,7 +2035,8 @@ sub setupBootDisk {
 		if ($syszip &gt; 0) {
 			my $sizeOK = 1;
 			my $systemPSize = $this-&gt;getStorageSize ($deviceMap{1});
-			my $systemISize = main::isize ($system); $systemISize /= 1024;
+			my $systemISize = $main::global -&gt; isize ($system);
+			$systemISize /= 1024;
 			chomp $systemPSize;
 			#print &quot;_______A $systemPSize : $systemISize\n&quot;;
 			if ($systemPSize &lt; $systemISize) {
@@ -2065,14 +2083,14 @@ sub setupBootDisk {
 		$kiwi -&gt; done();
 		$result = 0;
 		my $mapper = $root;
-		my %fsattr = main::checkFileSystem ($root);
+		my %fsattr = $main::global -&gt; checkFileSystem ($root);
 		if ($fsattr{type} eq &quot;luks&quot;) {
 			$mapper = $this -&gt; luksResize ($root,&quot;luks-resize&quot;);
 			if (! $mapper) {
 				$this -&gt; luksClose();
 				return undef;
 			}
-			%fsattr= main::checkFileSystem ($mapper);
+			%fsattr= $main::global -&gt; checkFileSystem ($mapper);
 		}
 		my $expanded = $this -&gt; __expandFS (
 			$fsattr{type},'system', $mapper
@@ -2095,14 +2113,14 @@ sub setupBootDisk {
 			$kiwi -&gt; done();
 			$result = 0;
 			$mapper = $root;
-			my %fsattr = main::checkFileSystem ($root);
+			my %fsattr = $main::global -&gt; checkFileSystem ($root);
 			if ($fsattr{type} eq &quot;luks&quot;) {
 				$mapper = $this -&gt; luksResize ($root,&quot;luks-resize&quot;);
 				if (! $mapper) {
 					$this -&gt; luksClose();
 					return undef;
 				}
-				%fsattr= main::checkFileSystem ($mapper);
+				%fsattr= $main::global -&gt; checkFileSystem ($mapper);
 			}
 			my $expanded = $this -&gt; __expandFS (
 				$fsattr{type},'split', $mapper
@@ -2121,7 +2139,7 @@ sub setupBootDisk {
 		#==========================================
 		# Mount system image partition
 		#------------------------------------------
-		if (! main::mount ($root, $loopdir)) {
+		if (! $main::global -&gt; mount ($root, $loopdir)) {
 			$this -&gt; cleanLoop ();
 			return undef;
 		}
@@ -2144,7 +2162,7 @@ sub setupBootDisk {
 					$this -&gt; cleanLoop ();
 					return undef;
 				}
-				if (! main::mount ($device, &quot;$loopdir/$pname&quot;)) {
+				if (! $main::global -&gt; mount ($device, &quot;$loopdir/$pname&quot;)) {
 					$this -&gt; cleanLoop ();
 					return undef;
 				}
@@ -2174,7 +2192,7 @@ sub setupBootDisk {
 		#==========================================
 		# Umount system image partition
 		#------------------------------------------
-		main::umount();
+		$main::global -&gt; umount();
 	}
 	#==========================================
 	# create read/write filesystem if needed
@@ -2206,7 +2224,9 @@ sub setupBootDisk {
 		} else {
 			$kiwi -&gt; info (&quot;Creating ext3 read-write filesystem&quot;);
 		}
-		my %FSopts = main::checkFSOptions();
+		my %FSopts = $main::global -&gt; checkFSOptions(
+			@{$cmdL -&gt; getFilesystemOptions()}
+		);
 		my $fsopts = $FSopts{ext3};
 		my $fstool = &quot;mkfs.ext3&quot;;
 		$status = qxx (&quot;$fstool $fsopts $root 2&gt;&amp;1&quot;);
@@ -2269,7 +2289,9 @@ sub setupBootDisk {
 		if ($bootloader eq &quot;extlinux&quot;) {
 			$root = $deviceMap{extlinux};
 		}
-		my %FSopts = main::checkFSOptions();
+		my %FSopts = $main::global -&gt; checkFSOptions(
+			@{$cmdL -&gt; getFilesystemOptions()}
+		);
 		my $fsopts = $FSopts{ext2};
 		my $fstool = &quot;mkfs.ext2&quot;;
 		$status = qxx (&quot;$fstool $fsopts $root 2&gt;&amp;1&quot;);
@@ -2316,7 +2338,7 @@ sub setupBootDisk {
 	} else {
 		$root = $deviceMap{1};
 	}
-	if (! main::mount ($root, $loopdir)) {
+	if (! $main::global -&gt; mount ($root, $loopdir)) {
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;Couldn't mount image: $root&quot;);
 		$kiwi -&gt; failed ();
@@ -2326,7 +2348,7 @@ sub setupBootDisk {
 	if (($arch =~/ppc|ppc64/) &amp;&amp; ($lvm)) {
 		$status = qxx (&quot;mkdir -p $loopdir/vfat&quot;);
 		$boot = $deviceMap{fat};
-		if (! main::mount ($boot, $loopdir.&quot;/vfat&quot;)) {
+		if (! $main::global -&gt; mount ($boot, $loopdir.&quot;/vfat&quot;)) {
 			$kiwi -&gt; failed ();
 			$kiwi -&gt; error  (&quot;Couldn't mount image: $boot&quot;);
 			$kiwi -&gt; failed ();
@@ -2360,7 +2382,7 @@ sub setupBootDisk {
 			$result = $? &gt;&gt; 8;
 			$status = qxx (&quot;cp -a $tmpdir/ppc $loopdir/vfat/&quot;);
 			$result = $? &gt;&gt; 8;
-			main::umount($boot);
+			$main::global -&gt; umount($boot);
 			$status = qxx (&quot;rm -rf $loopdir/vfat&quot;);
 			$result = $? &gt;&gt; 8;
 		}
@@ -2372,7 +2394,7 @@ sub setupBootDisk {
 		$this -&gt; cleanLoop ();
 		return undef;
 	}
-	main::umount();
+	$main::global -&gt; umount();
 	$kiwi -&gt; done();
 	#==========================================
 	# Install boot loader on disk
@@ -2513,6 +2535,7 @@ sub setupInstallFlags {
 	my $system = $this-&gt;{system};
 	my $irddir = $initrd.&quot;_&quot;.$$.&quot;.vmxsystem&quot;;
 	my $xml    = $this-&gt;{xml};
+	my $zipper = $this-&gt;{gdata}-&gt;{Gzip};
 	my $newird;
 	if (! mkdir $irddir) {
 		$kiwi -&gt; error  (&quot;Failed to create vmxsystem directory&quot;);
@@ -2522,7 +2545,7 @@ sub setupInstallFlags {
 	#==========================================
 	# unpack initrd files
 	#------------------------------------------
-	my $unzip  = &quot;$main::Gzip -cd $initrd 2&gt;&amp;1&quot;;
+	my $unzip  = &quot;$this-&gt;{gdata}-&gt;{Gzip} -cd $initrd 2&gt;&amp;1&quot;;
 	my $status = qxx (&quot;$unzip | (cd $irddir &amp;&amp; cpio -di 2&gt;&amp;1)&quot;);
 	my $result = $? &gt;&gt; 8;
 	if ($result != 0) {
@@ -2566,7 +2589,7 @@ sub setupInstallFlags {
 	$newird = $initrd;
 	$newird =~ s/\.gz/\.install\.gz/;
 	$status = qxx (
-		&quot;(cd $irddir &amp;&amp; find|cpio --quiet -oH newc | $main::Gzip) &gt; $newird&quot;
+		&quot;(cd $irddir &amp;&amp; find|cpio --quiet -oH newc | $zipper) &gt; $newird&quot;
 	);
 	$result = $? &gt;&gt; 8;
 	if ($result != 0) {
@@ -2630,7 +2653,7 @@ sub setupSplash {
 	# unpack initrd files
 	#------------------------------------------
 	mkdir $irddir;
-	my $unzip  = &quot;$main::Gzip -cd $initrd 2&gt;&amp;1&quot;;
+	my $unzip  = &quot;$this-&gt;{gdata}-&gt;{Gzip} -cd $initrd 2&gt;&amp;1&quot;;
 	if ($zipped) {
 		$status = qxx (&quot;$unzip | (cd $irddir &amp;&amp; cpio -di 2&gt;&amp;1)&quot;);
 	} else {
@@ -2690,7 +2713,7 @@ sub setupSplashLink {
 	my $status;
 	my $result;
 	if ($initrd !~ /.gz$/) {
-		$status = qxx (&quot;$main::Gzip -f $initrd 2&gt;&amp;1&quot;);
+		$status = qxx (&quot;$this-&gt;{gdata}-&gt;{Gzip} -f $initrd 2&gt;&amp;1&quot;);
 		$result = $? &gt;&gt; 8;
 		if ($result != 0) {
 			return (&quot;Failed to compress initrd: $status&quot;);
@@ -2739,6 +2762,7 @@ sub setupSplashForGrub {
 	my $newird = shift;
 	my $newspl = &quot;$spldir/splash&quot;;
 	my $irddir = &quot;$spldir/initrd&quot;;
+	my $zipper = $this-&gt;{gdata}-&gt;{Gzip};
 	my $status;
 	my $result;
 	#==========================================
@@ -2755,7 +2779,7 @@ sub setupSplashForGrub {
 	#------------------------------------------
 	while (my $splash = glob(&quot;$newspl/*.spl&quot;)) {
 		mkdir &quot;$splash.dir&quot;;
-		qxx (&quot;$main::Gzip -cd $splash &gt; $splash.bob&quot;);
+		qxx (&quot;$zipper -cd $splash &gt; $splash.bob&quot;);
 		my $count = $this -&gt; extractCPIO ( $splash.&quot;.bob&quot; );
 		for (my $id=1; $id &lt;= $count; $id++) {
 			qxx (&quot;cat $splash.bob.$id |(cd $splash.dir &amp;&amp; cpio -i 2&gt;&amp;1)&quot;);
@@ -2776,11 +2800,11 @@ sub setupSplashForGrub {
 	}
 	qxx (
 		&quot;(cd $newspl &amp;&amp; \
-		find|cpio --quiet -oH newc | $main::Gzip) &gt; $spldir/all.spl&quot;
+		find|cpio --quiet -oH newc | $zipper) &gt; $spldir/all.spl&quot;
 	);
 	qxx (
 		&quot;rm -f $newird &amp;&amp; \
-		(cd $irddir &amp;&amp; find | cpio --quiet -oH newc | $main::Gzip) &gt; $newird&quot;
+		(cd $irddir &amp;&amp; find | cpio --quiet -oH newc | $zipper) &gt; $newird&quot;
 	);
 	#==========================================
 	# create splash initrd
@@ -2798,7 +2822,7 @@ sub cleanLoop {
 	my $loop   = $this-&gt;{loop};
 	my $lvm    = $this-&gt;{lvm};
 	my $loopdir= $this-&gt;{loopdir};
-	main::umount();
+	$main::global -&gt; umount();
 	if ((defined $loop) &amp;&amp; ($loop =~ /loop/)) {
 		if (defined $lvm) {
 			qxx (&quot;vgchange -an $this-&gt;{lvmgroup} 2&gt;&amp;1&quot;);
@@ -2838,7 +2862,7 @@ sub buildMD5Sum {
 	my $outf = shift;
 	my $kiwi = $this-&gt;{kiwi};
 	$kiwi -&gt; info (&quot;Creating image MD5 sum...&quot;);
-	my $size = main::isize ($file);
+	my $size = $main::global -&gt; isize ($file);
 	my $primes = qxx (&quot;factor $size&quot;); $primes =~ s/^.*: //;
 	my $blocksize = 1;
 	for my $factor (split /\s/,$primes) {
@@ -2909,6 +2933,7 @@ sub setupBootLoaderStages {
 	my $tmpdir = $this-&gt;{tmpdir};
 	my $initrd = $this-&gt;{initrd};
 	my $zipped = $this-&gt;{zipped};
+	my $zipper = $this-&gt;{gdata}-&gt;{Gzip};
 	my $status = 0;
 	my $result = 0;
 	#==========================================
@@ -2918,7 +2943,7 @@ sub setupBootLoaderStages {
 		my $stages = &quot;'usr/lib/grub/*'&quot;;
 		my $message= &quot;'image/loader/message'&quot;;
 		my $gbinary= &quot;'usr/sbin/grub'&quot;;
-		my $unzip  = &quot;$main::Gzip -cd $initrd 2&gt;&amp;1&quot;;
+		my $unzip  = &quot;$zipper -cd $initrd 2&gt;&amp;1&quot;;
 		$status = qxx ( &quot;mkdir -p $tmpdir/boot/grub 2&gt;&amp;1&quot; );
 		$result = $? &gt;&gt; 8;
 		if ($result != 0) {
@@ -3010,7 +3035,7 @@ sub setupBootLoaderStages {
 	#------------------------------------------
 	if ($loader =~ /(sys|ext)linux/) {
 		my $message= &quot;'image/loader/*'&quot;;
-		my $unzip  = &quot;$main::Gzip -cd $initrd 2&gt;&amp;1&quot;;
+		my $unzip  = &quot;$zipper -cd $initrd 2&gt;&amp;1&quot;;
 		#==========================================
 		# Create syslinux boot data directory
 		#------------------------------------------
@@ -4141,7 +4166,7 @@ sub checkLVMbind {
 	#==========================================
 	# activate volume groups
 	#------------------------------------------
-	open (my $SCAN,&quot;vgscan|&quot;);
+	open (my $SCAN,&quot;vgscan 2&gt;/dev/null |&quot;);
 	while (my $line = &lt;$SCAN&gt;) {
 		if ($line =~ /\&quot;(.*)\&quot;/) {
 			push (@groups,$1);
@@ -4771,7 +4796,7 @@ sub luksResize {
 	my $source = shift;
 	my $name   = shift;
 	my $kiwi   = $this-&gt;{kiwi};
-	my $cipher = $main::LuksCipher;
+	my $cipher = $this-&gt;{gdata}-&gt;{LuksCipher};
 	my $status;
 	my $result;
 	my $hald;
@@ -4869,8 +4894,11 @@ sub setupFilesystem {
 	my $inodes = $this-&gt;{deviceinodes};
 	my $kiwi   = $this-&gt;{kiwi};
 	my $xml    = $this-&gt;{xml};
+	my $cmdL   = $this-&gt;{cmdL};
 	my %type   = %{$xml-&gt;getImageTypeAndAttributes()};
-	my %FSopts = main::checkFSOptions();
+	my %FSopts = $main::global -&gt; checkFSOptions(
+		@{$cmdL -&gt; getFilesystemOptions()}
+	);
 	my $iorig  = $this-&gt;{inodes};
 	my $result;
 	my $status;
diff --git a/modules/KIWICache.pm b/modules/KIWICache.pm
index cd2540d..81b9937 100644
--- a/modules/KIWICache.pm
+++ b/modules/KIWICache.pm
@@ -115,6 +115,7 @@ sub new {
 	$this-&gt;{base}     = $base;
 	$this-&gt;{profiles} = $prof;
 	$this-&gt;{config}   = $conf;
+	$this-&gt;{gdata}    = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -318,7 +319,7 @@ sub createCache {
 		#==========================================
 		# write XML changes to logfile...
 		#------------------------------------------
-		$kiwi -&gt; writeXML();
+		$kiwi -&gt; writeXML ($this-&gt;{gdata}-&gt;{Pretty});
 		#==========================================
 		# Reformat log file for human readers...
 		#------------------------------------------
diff --git a/modules/KIWICollect.pm b/modules/KIWICollect.pm
index e9612cd..b85a324 100644
--- a/modules/KIWICollect.pm
+++ b/modules/KIWICollect.pm
@@ -114,6 +114,8 @@ sub new {
     m_rmlists	    =&gt; undef,
   };
 
+  $this-&gt;{gdata} = $main::global -&gt; getGlobals();
+
   bless $this, $class;
 
   #==========================================
@@ -636,8 +638,8 @@ sub mainTask
       $attr .= &quot; -f&quot;; # follow symlinks - really necessary?
       $attr .= &quot; -J&quot;; # Joilet extensions - only useful for i586/x86_64, I think
       $attr .= &quot; -joliet-long&quot;; # longer filenames for joilet filenames
-      $attr .= &quot; -p \&quot;$main::Preparer\&quot;&quot;;
-      $attr .= &quot; -publisher \&quot;$main::Publisher\&quot;&quot;;
+      $attr .= &quot; -p \&quot;$this-&gt;{gdata}-&gt;{Preparer}\&quot;&quot;;
+      $attr .= &quot; -publisher \&quot;$this-&gt;{gdata}-&gt;{Publisher}\&quot;&quot;;
       $attr .= &quot; -A \&quot;$name\&quot;&quot;;
       $attr .= &quot; -V \&quot;$vid\&quot;&quot;;
 
diff --git a/modules/KIWICommandLine.pm b/modules/KIWICommandLine.pm
index 73a6995..317279a 100644
--- a/modules/KIWICommandLine.pm
+++ b/modules/KIWICommandLine.pm
@@ -988,4 +988,76 @@ sub getImageFormat {
 	return $this-&gt;{format};
 }
 
+#==========================================
+# setDefaultAnswer
+#------------------------------------------
+sub setDefaultAnswer {
+	# ...
+	# Store the value of the format option
+	# ---
+	my $this   = shift;
+	my $answer = shift;
+	$this-&gt;{defaultAnswer} = $answer;
+	return 1;
+}
+
+#==========================================
+# getDefaultAnswer
+#------------------------------------------
+sub getDefaultAnswer {
+	my $this = shift;
+	return $this-&gt;{defaultAnswer};
+}
+
+#==========================================
+# setFilesystemOptions
+#------------------------------------------
+sub setFilesystemOptions {
+	# ...
+	# Store the list of filesystem specific options
+	# ---
+	my $this   = shift;
+	my $FSBlockSize     = shift;
+	my $FSInodeSize     = shift;
+	my $FSInodeRatio    = shift;
+	my $FSJournalSize   = shift;
+	my $FSMaxMountCount = shift;
+	my $FSCheckInterval = shift;
+	my @result;
+	push @result,$FSBlockSize;
+	push @result,$FSInodeSize;
+	push @result,$FSInodeRatio;
+	push @result,$FSJournalSize;
+	push @result,$FSMaxMountCount;
+	push @result,$FSCheckInterval;
+	$this-&gt;{fsoptions} = \@result;
+	return 1;
+}
+
+#==========================================
+# getFilesystemOptions
+#------------------------------------------
+sub getFilesystemOptions {
+	my $this = shift;
+	return $this-&gt;{fsoptions};
+}
+
+#==========================================
+# setMBRID
+#------------------------------------------
+sub setMBRID {
+	my $this  = shift;
+	my $mbrid = shift;
+	$this-&gt;{mbrid} = $mbrid;
+	return 1;
+}
+
+#==========================================
+# getMBRID
+#------------------------------------------
+sub getMBRID {
+	my $this = shift;
+	return $this-&gt;{mbrid};
+}
+
 1;
diff --git a/modules/KIWIConfigure.pm b/modules/KIWIConfigure.pm
index cbf19dd..9b3c245 100644
--- a/modules/KIWIConfigure.pm
+++ b/modules/KIWIConfigure.pm
@@ -74,6 +74,7 @@ sub new {
 	$this-&gt;{imageDest} = $imageDest;
 	$this-&gt;{xml}       = $xml;
 	$this-&gt;{root}      = $root;
+	$this-&gt;{gdata}     = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -141,7 +142,7 @@ sub setupRecoveryArchive {
 	# Compress archive into .tar.gz
 	#------------------------------------------
 	$status = qxx (
-		&quot;$main::Gzip $root/recovery.tar 2&gt;&amp;1&quot;
+		&quot;$this-&gt;{gdata}-&gt;{Gzip} $root/recovery.tar 2&gt;&amp;1&quot;
 	);
 	$code = $? &gt;&gt; 8;
 	if ($code != 0) {
diff --git a/modules/KIWIGlobals.pm b/modules/KIWIGlobals.pm
new file mode 100644
index 0000000..efcb92e
--- /dev/null
+++ b/modules/KIWIGlobals.pm
@@ -0,0 +1,606 @@
+#================
+# FILE          : KIWIGlobals.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : This module is used to store variables and
+#               : functions which needs to be available globally
+#               :
+# STATUS        : Development
+#----------------
+package KIWIGlobals;
+#==========================================
+# Modules
+#------------------------------------------
+use strict;
+use KIWILocator;
+use KIWILog;
+use KIWIQX;
+
+#==========================================
+# Constructor
+#------------------------------------------
+sub new { 
+	# ...
+	# Create a new KIWIGlobals object which is used to
+	# store global values
+	# ---
+	#==========================================
+	# Object setup
+	#------------------------------------------
+	my $this  = {};
+	my $class = shift;
+	bless $this,$class;
+	#==========================================
+	# Variable setup
+	#------------------------------------------
+	my %data;
+	$data{Version}       = &quot;4.88&quot;;
+	$data{Publisher}     = &quot;SUSE LINUX Products GmbH&quot;;
+	$data{Preparer}      = &quot;KIWI - <A HREF="http://kiwi.berlios.de">http://kiwi.berlios.de</A>&quot;;
+	$data{ConfigFile}    = &quot;$ENV{'HOME'}/.kiwirc&quot;;
+	$data{ConfigName}    = &quot;config.xml&quot;;
+	#============================================
+	# Read $HOME/.kiwirc
+	#--------------------------------------------
+	my $kiwi = new KIWILog(&quot;tiny&quot;);
+	if ( -f $data{ConfigFile}) {
+		if (! do $data{ConfigFile}) {
+			$kiwi -&gt; warning (&quot;Invalid $data{ConfigFile} file...&quot;);
+			$kiwi -&gt; skipped ();
+		} else {
+			$kiwi -&gt; info (&quot;Using $data{ConfigFile}&quot;);
+			$kiwi -&gt; done ();
+		}
+	}
+	no strict 'vars';
+	$data{BasePath}      = $BasePath;      # configurable base kiwi path
+	$data{Gzip}          = $Gzip;          # configurable gzip command
+	$data{LogServerPort} = $LogServerPort; # configurable log server port
+	$data{LuksCipher}    = $LuksCipher;    # stored luks passphrase
+	$data{System}        = $System;        # configurable base image desc. path
+	if ( ! defined $BasePath ) {
+		$data{BasePath} = &quot;/usr/share/kiwi&quot;;
+	}
+	if (! defined $Gzip) {
+		$data{Gzip} = &quot;gzip -9&quot;;
+	}
+	if (! defined $LogServerPort) {
+		$data{LogServerPort} = &quot;off&quot;;
+	}
+	if (! defined $System) {
+		$data{System} = $data{BasePath}.&quot;/image&quot;;
+	}
+	if (! defined $LuksCipher) {
+		# empty
+	}
+	use strict 'vars';
+	my $BasePath = $data{BasePath};
+	$data{Tools}     = $BasePath.&quot;/tools&quot;;
+	$data{Schema}    = $BasePath.&quot;/modules/KIWISchema.rng&quot;;
+	$data{SchemaTST} = $BasePath.&quot;/modules/KIWISchemaTest.rng&quot;;
+	$data{KConfig}   = $BasePath.&quot;/modules/KIWIConfig.sh&quot;;
+	$data{KMigrate}  = $BasePath.&quot;/modules/KIWIMigrate.txt&quot;;
+	$data{KRegion}   = $BasePath.&quot;/modules/KIWIEC2Region.txt&quot;;
+	$data{KMigraCSS} = $BasePath.&quot;/modules/KIWIMigrate.tgz&quot;;
+	$data{KSplit}    = $BasePath.&quot;/modules/KIWISplit.txt&quot;;
+	$data{repoURI}   = $BasePath.&quot;/modules/KIWIURL.txt&quot;;
+	$data{Revision}  = $BasePath.&quot;/.revision&quot;;
+	$data{TestBase}  = $BasePath.&quot;/tests&quot;;
+	$data{SchemaCVT} = $BasePath.&quot;/xsl/master.xsl&quot;;
+	$data{Pretty}    = $BasePath.&quot;/xsl/print.xsl&quot;;
+	#==========================================
+	# Globals (Supported filesystem names)
+	#------------------------------------------
+	my %KnownFS;
+	my $locator = new KIWILocator();
+	$KnownFS{ext4}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext4&quot;);
+	$KnownFS{ext3}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext3&quot;);
+	$KnownFS{ext2}{tool}      = $locator -&gt; getExecPath(&quot;mkfs.ext2&quot;);
+	$KnownFS{squashfs}{tool}  = $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
+	$KnownFS{clicfs}{tool}    = $locator -&gt; getExecPath(&quot;mkclicfs&quot;);
+	$KnownFS{clic}{tool}      = $locator -&gt; getExecPath(&quot;mkclicfs&quot;);
+	$KnownFS{unified}{tool}   = $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
+	$KnownFS{compressed}{tool}= $locator -&gt; getExecPath(&quot;mksquashfs&quot;);
+	$KnownFS{reiserfs}{tool}  = $locator -&gt; getExecPath(&quot;mkreiserfs&quot;);
+	$KnownFS{btrfs}{tool}     = $locator -&gt; getExecPath(&quot;mkfs.btrfs&quot;);
+	$KnownFS{xfs}{tool}       = $locator -&gt; getExecPath(&quot;mkfs.xfs&quot;);
+	$KnownFS{cpio}{tool}      = $locator -&gt; getExecPath(&quot;cpio&quot;);
+	$KnownFS{ext3}{ro}        = 0;
+	$KnownFS{ext4}{ro}        = 0;
+	$KnownFS{ext2}{ro}        = 0;
+	$KnownFS{squashfs}{ro}    = 1;
+	$KnownFS{clicfs}{ro}      = 1;
+	$KnownFS{clic}{ro}        = 1;
+	$KnownFS{unified}{ro}     = 1;
+	$KnownFS{compressed}{ro}  = 1;
+	$KnownFS{reiserfs}{ro}    = 0;
+	$KnownFS{btrfs}{ro}       = 0;
+	$KnownFS{xfs}{ro}         = 0;
+	$KnownFS{cpio}{ro}        = 0;
+	$data{KnownFS} = \%KnownFS;
+	#==========================================
+	# Store object data
+	#------------------------------------------
+	$this-&gt;{data} = \%data;
+	$this-&gt;{kiwi} = $kiwi;
+	return $this;
+}
+
+#==========================================
+# getGlobals
+#------------------------------------------
+sub getGlobals {
+	my $this = shift;
+	return $this-&gt;{data};
+}
+
+#==========================================
+# setGlobals
+#------------------------------------------
+sub setGlobals {
+	my $this = shift;
+	my $key  = shift;
+	my $val  = shift;
+	$this-&gt;{data}-&gt;{$key} = $val;
+	return $this;
+}
+
+#============================================
+# createDirInteractive
+#--------------------------------------------
+sub createDirInteractive {
+	my $this      = shift;
+	my $targetDir = shift;
+	my $defaultAnswer = shift;
+	my $kiwi = $this-&gt;{kiwi};
+	if (! -d $targetDir) {
+		my $prefix = $kiwi -&gt; getPrefix (1);
+		my $answer = (defined $defaultAnswer) ? &quot;yes&quot; : &quot;unknown&quot;;
+		$kiwi -&gt; info (&quot;Destination: $targetDir doesn't exist\n&quot;);
+		while ($answer !~ /^yes$|^no$/) {
+			print STDERR $prefix,
+				&quot;Would you like kiwi to create it [yes/no] ? &quot;;
+			chomp ($answer = &lt;&gt;);
+		}
+		if ($answer eq &quot;yes&quot;) {
+			qxx (&quot;mkdir -p $targetDir&quot;);
+			return 1;
+		}
+	} else {
+		# Directory exists
+		return 1;
+	}
+	# Directory does not exist and user did
+	# not request dir creation.
+	return undef;
+}
+
+#==========================================
+# checkFSOptions
+#------------------------------------------
+sub checkFSOptions {
+	# /.../
+	# checks the $FS* option values and build an option
+	# string for the relevant filesystems
+	# ---
+	my $this            = shift;
+	my $FSBlockSize     = shift;
+	my $FSInodeSize     = shift;
+	my $FSInodeRatio    = shift;
+	my $FSJournalSize   = shift;
+	my $FSMaxMountCount = shift;
+	my $FSCheckInterval = shift;
+	my $kiwi            = $this-&gt;{kiwi};
+	my %KnownFS         = %{$this-&gt;{data}-&gt;{KnownFS}};
+	my %result          = ();
+	my $fs_maxmountcount;
+	my $fs_checkinterval;
+	foreach my $fs (keys %KnownFS) {
+		my $blocksize;   # block size in bytes
+		my $journalsize; # journal size in MB (ext) or blocks (reiser)
+		my $inodesize;   # inode size in bytes (ext only)
+		my $inoderatio;  # bytes/inode ratio
+		my $fsfeature;   # filesystem features (ext only)
+		SWITCH: for ($fs) {
+			#==========================================
+			# EXT2-4
+			#------------------------------------------
+			/ext[432]/   &amp;&amp; do {
+				if ($FSBlockSize)   {$blocksize   = &quot;-b $FSBlockSize&quot;}
+				if (($FSInodeSize) &amp;&amp; ($FSInodeSize != 256)) {
+					$inodesize = &quot;-I $FSInodeSize&quot;
+				}
+				if ($FSInodeRatio)  {$inoderatio  = &quot;-i $FSInodeRatio&quot;}
+				if ($FSJournalSize) {$journalsize = &quot;-J size=$FSJournalSize&quot;}
+				if ($FSMaxMountCount) {
+					$fs_maxmountcount = &quot; -c $FSMaxMountCount&quot;;
+				}
+				if ($FSCheckInterval) {
+					$fs_checkinterval = &quot; -i $FSCheckInterval&quot;;
+				}
+				$fsfeature = &quot;-F -O resize_inode&quot;;
+				last SWITCH;
+			};
+			#==========================================
+			# reiserfs
+			#------------------------------------------
+			/reiserfs/  &amp;&amp; do {
+				if ($FSBlockSize)   {$blocksize   = &quot;-b $FSBlockSize&quot;}
+				if ($FSJournalSize) {$journalsize = &quot;-s $FSJournalSize&quot;}
+				last SWITCH;
+			};
+			# no options for this filesystem...
+		};
+		if (defined $inodesize) {
+			$result{$fs} .= $inodesize.&quot; &quot;;
+		}
+		if (defined $inoderatio) {
+			$result{$fs} .= $inoderatio.&quot; &quot;;
+		}
+		if (defined $blocksize) {
+			$result{$fs} .= $blocksize.&quot; &quot;;
+		}
+		if (defined $journalsize) {
+			$result{$fs} .= $journalsize.&quot; &quot;;
+		}
+		if (defined $fsfeature) {
+			$result{$fs} .= $fsfeature.&quot; &quot;;
+		}
+	}
+	if ($fs_maxmountcount || $fs_checkinterval) {
+		$result{extfstune} = &quot;$fs_maxmountcount$fs_checkinterval&quot;;
+	}
+	return %result;
+}
+
+#==========================================
+# mount
+#------------------------------------------
+sub mount {
+	# /.../
+	# implements a generic mount function for all supported
+	# file system types
+	# ---
+	my $this   = shift;
+	my $kiwi   = $this-&gt;{kiwi};
+	my $source = shift;
+	my $dest   = shift;
+	my $salt   = int (rand(20));
+	my %fsattr = $this -&gt; checkFileSystem ($source);
+	my $type   = $fsattr{type};
+	my $cipher = $this-&gt;{data}-&gt;{LuksCipher};
+	my $status;
+	my $result;
+	my @UmountStack;
+	#==========================================
+	# Check result of filesystem detection
+	#------------------------------------------
+	if (! %fsattr) {
+		$kiwi -&gt; error  (&quot;Couldn't detect filesystem on: $source&quot;);
+		$kiwi -&gt; failed ();
+		return undef;
+	}
+	#==========================================
+	# Check for DISK file
+	#------------------------------------------
+	if (-f $source) {
+		my $boot = &quot;'boot sector'&quot;;
+		my $null = &quot;/dev/null&quot;;
+		$status= qxx (
+			&quot;dd if=$source bs=512 count=1 2&gt;$null|file - | grep -q $boot&quot;
+		);
+		$result= $? &gt;&gt; 8;
+		if ($result == 0) {			
+			$status = qxx (&quot;/sbin/losetup -s -f $source 2&gt;&amp;1&quot;); chomp $status;
+			$result = $? &gt;&gt; 8;
+			if ($result != 0) {
+				$kiwi -&gt; error  (
+					&quot;Couldn't loop bind disk file: $status&quot;
+				);
+				$kiwi -&gt; failed ();
+				$this -&gt; umount();
+				return undef;
+			}
+			my $loop = $status;
+			push @UmountStack,&quot;losetup -d $loop&quot;;
+			$this-&gt;{UmountStack} = \@UmountStack;
+			$status = qxx (&quot;kpartx -a $loop 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+			if ($result != 0) {
+				$kiwi -&gt; error (
+					&quot;Couldn't loop bind disk partition(s): $status&quot;
+				);
+				$kiwi -&gt; failed (); umount();
+				return undef;
+			}
+			push @UmountStack,&quot;kpartx -d $loop&quot;;
+			$this-&gt;{UmountStack} = \@UmountStack;
+			$loop =~ s/\/dev\///;
+			$source = &quot;/dev/mapper/&quot;.$loop.&quot;p1&quot;;
+			if (! -b $source) {
+				$kiwi -&gt; error (&quot;No such block device $source&quot;);
+				$kiwi -&gt; failed (); umount();
+				return undef;
+			}
+		}
+	}
+	#==========================================
+	# Check for LUKS extension
+	#------------------------------------------
+	if ($type eq &quot;luks&quot;) {
+		if (-f $source) {
+			$status = qxx (&quot;/sbin/losetup -s -f $source 2&gt;&amp;1&quot;); chomp $status;
+			$result = $? &gt;&gt; 8;
+			if ($result != 0) {
+				$kiwi -&gt; error  (&quot;Couldn't loop bind logical extend: $status&quot;);
+				$kiwi -&gt; failed ();
+				$this -&gt; umount();
+				return undef;
+			}
+			$source = $status;
+			push @UmountStack,&quot;losetup -d $source&quot;;
+			$this-&gt;{UmountStack} = \@UmountStack;
+		}
+		if ($cipher) {
+			$status = qxx (
+				&quot;echo $cipher | cryptsetup luksOpen $source luks-$salt 2&gt;&amp;1&quot;
+			);
+		} else {
+			$status = qxx (&quot;cryptsetup luksOpen $source luks-$salt 2&gt;&amp;1&quot;);
+		}
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; error  (&quot;Couldn't open luks device: $status&quot;);
+			$kiwi -&gt; failed ();
+			$this -&gt; umount();
+			return undef;
+		}
+		$source = &quot;/dev/mapper/luks-&quot;.$salt;
+		push @UmountStack,&quot;cryptsetup luksClose luks-$salt&quot;;
+		$this-&gt;{UmountStack} = \@UmountStack;
+	}
+	#==========================================
+	# Mount device or loop mount file
+	#------------------------------------------
+	if ((-f $source) &amp;&amp; ($type ne &quot;clicfs&quot;)) {
+		$status = qxx (&quot;mount -o loop $source $dest 2&gt;&amp;1&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; error (&quot;Failed to loop mount $source to: $dest: $status&quot;);
+			$kiwi -&gt; failed ();
+			$this -&gt; umount();
+			return undef;
+		}
+	} else {
+		if ($type eq &quot;clicfs&quot;) {
+			$status = qxx (&quot;clicfs -m 512 $source $dest 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+			if ($result == 0) {
+				$status = qxx (&quot;resize2fs $dest/fsdata.ext3 2&gt;&amp;1&quot;);
+				$result = $? &gt;&gt; 8;
+			}
+		} else {
+			$status = qxx (&quot;mount $source $dest 2&gt;&amp;1&quot;);
+			$result = $? &gt;&gt; 8;
+		}
+		if ($result != 0) {
+			$kiwi -&gt; error (&quot;Failed to mount $source to: $dest: $status&quot;);
+			$kiwi -&gt; failed ();
+			$this -&gt; umount();
+			return undef;
+		}
+	}
+	push @UmountStack,&quot;umount $dest&quot;;
+	$this-&gt;{UmountStack} = \@UmountStack;
+	#==========================================
+	# Post mount actions
+	#------------------------------------------
+	if (-f $dest.&quot;/fsdata.ext3&quot;) {
+		$source = $dest.&quot;/fsdata.ext3&quot;;
+		$status = qxx (&quot;mount -o loop $source $dest 2&gt;&amp;1&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; error (&quot;Failed to loop mount $source to: $dest: $status&quot;);
+			$kiwi -&gt; failed ();
+			$this -&gt; umount();
+			return undef;
+		}
+		push @UmountStack,&quot;umount $dest&quot;;
+		$this-&gt;{UmountStack} = \@UmountStack;
+	}
+	return $dest;
+}
+
+#==========================================
+# umount
+#------------------------------------------
+sub umount {
+	# /.../
+	# implements an umount function for filesystems mounted
+	# via main::mount(). The function walks through the
+	# contents of the UmountStack list
+	# ---
+	my $this  = shift;
+	my $kiwi  = $this-&gt;{kiwi};
+	my $stack = $this-&gt;{UmountStack};
+	my $status;
+	my $result;
+	if (! $stack) {
+		return;
+	}
+	qxx (&quot;sync&quot;);
+	my @UmountStack = @{$stack};
+	foreach my $cmd (reverse @UmountStack) {
+		$status = qxx (&quot;$cmd 2&gt;&amp;1&quot;);
+		$result = $? &gt;&gt; 8;
+		if ($result != 0) {
+			$kiwi -&gt; warning (&quot;UmountStack failed: $cmd: $status\n&quot;);
+		}
+	}
+	$this-&gt;{UmountStack} = ();
+}
+
+#==========================================
+# isize
+#------------------------------------------
+sub isize {
+	# /.../
+	# implements a size function like the -s operator
+	# but also works for block specials using blockdev
+	# ---
+	my $this   = shift;
+	my $target = shift;
+	my $kiwi   = $this-&gt;{kiwi};
+	if (! defined $target) {
+		return 0;
+	}
+	if (-b $target) {
+		my $size = qxx (&quot;blockdev --getsize64 $target 2&gt;&amp;1&quot;);
+		my $code = $? &gt;&gt; 8;
+		if ($code == 0) {
+			chomp  $size;
+			return $size;
+		}
+	} elsif (-f $target) {
+		return -s $target;
+	}
+	return 0;
+}
+
+#==========================================
+# getMBRDiskLabel
+#------------------------------------------
+sub getMBRDiskLabel {
+	# ...
+	# set the mbrid to either the value given at the
+	# commandline or a random 4byte MBR disk label ID
+	# ---
+	my $this  = shift;
+	my $MBRID = shift;
+	my $range = 0xfe;
+	if (defined $MBRID) {
+		return $MBRID;
+	} else {
+		my @bytes;
+		for (my $i=0;$i&lt;4;$i++) {
+			$bytes[$i] = 1 + int(rand($range));
+			redo if $bytes[0] &lt;= 0xf;
+		}
+		my $nid = sprintf (&quot;0x%02x%02x%02x%02x&quot;,
+			$bytes[0],$bytes[1],$bytes[2],$bytes[3]
+		);
+		return $nid;
+	}
+}
+
+#==========================================
+# checkFileSystem
+#------------------------------------------
+sub checkFileSystem {
+	# /.../
+	# checks attributes of the given filesystem(s) and returns
+	# a summary hash containing the following information
+	# ---
+	# $filesystem{hastool}  --&gt; has the tool to create the filesystem
+	# $filesystem{readonly} --&gt; is a readonly filesystem
+	# $filesystem{type}     --&gt; what filesystem type is this
+	# ---
+	my $this    = shift;
+	my $fs      = shift;
+	my $kiwi    = $this-&gt;{kiwi};
+	my %KnownFS = %{$this-&gt;{data}-&gt;{KnownFS}};
+	my %result  = ();
+	if (defined $KnownFS{$fs}) {
+		#==========================================
+		# got a known filesystem type
+		#------------------------------------------
+		$result{type}     = $fs;
+		$result{readonly} = $KnownFS{$fs}{ro};
+		$result{hastool}  = 0;
+		if (($KnownFS{$fs}{tool}) &amp;&amp; (-x $KnownFS{$fs}{tool})) {
+			$result{hastool} = 1;
+		}
+	} else {
+		#==========================================
+		# got a file, block special or something
+		#------------------------------------------
+		if (-e $fs) {
+			my $data = qxx (&quot;dd if=$fs bs=128k count=1 2&gt;/dev/null | file -&quot;);
+			my $code = $? &gt;&gt; 8;
+			my $type;
+			if ($code != 0) {
+				if ($main::kiwi -&gt; trace()) {
+					$main::BT.=eval { Carp::longmess ($main::TT.$main::TL++) };
+				}
+				return undef;
+			}
+			SWITCH: for ($data) {
+				/ext4/      &amp;&amp; do {
+					$type = &quot;ext4&quot;;
+					last SWITCH;
+				};
+				/ext3/      &amp;&amp; do {
+					$type = &quot;ext3&quot;;
+					last SWITCH;
+				};
+				/ext2/      &amp;&amp; do {
+					$type = &quot;ext2&quot;;
+					last SWITCH;
+				};
+				/ReiserFS/  &amp;&amp; do {
+					$type = &quot;reiserfs&quot;;
+					last SWITCH;
+				};
+				/BTRFS/     &amp;&amp; do {
+					$type = &quot;btrfs&quot;;
+					last SWITCH;
+				};
+				/Squashfs/  &amp;&amp; do {
+					$type = &quot;squashfs&quot;;
+					last SWITCH;
+				};
+				/LUKS/      &amp;&amp; do {
+					$type = &quot;luks&quot;;
+					last SWITCH;
+				};
+				/XFS/     &amp;&amp; do {
+					$type = &quot;xfs&quot;;
+					last SWITCH;
+				};
+				# unknown filesystem type check clicfs...
+				$data = qxx (
+					&quot;dd if=$fs bs=128k count=1 2&gt;/dev/null | grep -q CLIC&quot;
+				);
+				$code = $? &gt;&gt; 8;
+				if ($code == 0) {
+					$type = &quot;clicfs&quot;;
+					last SWITCH;
+				}
+				# unknown filesystem type use auto...
+				$type = &quot;auto&quot;;
+			};
+			$result{type}     = $type;
+			$result{readonly} = $KnownFS{$type}{ro};
+			$result{hastool}  = 0;
+			if (defined $KnownFS{$type}{tool}) {
+				if (-x $KnownFS{$type}{tool}) {
+					$result{hastool} = 1;
+				}
+			}
+		} else {
+			if ($main::kiwi -&gt; trace()) {
+				$main::BT.=eval { Carp::longmess ($main::TT.$main::TL++) };
+			}
+			return ();
+		}
+	}
+	return %result;
+}
+
+1;
diff --git a/modules/KIWIImage.pm b/modules/KIWIImage.pm
index eb77777..b541e54 100644
--- a/modules/KIWIImage.pm
+++ b/modules/KIWIImage.pm
@@ -131,6 +131,7 @@ sub new {
 	$this-&gt;{imageStrip} = $imageStrip;
 	$this-&gt;{baseSystem} = $baseSystem;
 	$this-&gt;{arch}       = $arch;
+	$this-&gt;{gdata}      = $main::global -&gt; getGlobals();
 	#==========================================
 	# Mount overlay tree if required...
 	#------------------------------------------
@@ -138,7 +139,9 @@ sub new {
 	#==========================================
 	# Store a disk label ID for this object
 	#------------------------------------------
-	$this-&gt;{mbrid} = main::getMBRDiskLabel();
+	$this-&gt;{mbrid} = $main::global -&gt; getMBRDiskLabel (
+		$cmdL -&gt; getMBRID()
+	);
 	#==========================================
 	# Clean kernel mounts if any
 	#------------------------------------------
@@ -283,7 +286,7 @@ sub checkAndSetupPrebuiltBootImage {
 	my $ok   = 0;
 	my $bootpath = $boot;
 	if (($boot !~ /^\//) &amp;&amp; (! -d $boot)) {
-		$bootpath = $main::System.&quot;/&quot;.$boot;
+		$bootpath = $this-&gt;{gdata}-&gt;{System}.&quot;/&quot;.$boot;
 	}
 	#==========================================
 	# open boot image XML object
@@ -294,8 +297,10 @@ sub checkAndSetupPrebuiltBootImage {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,
-		$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {
@@ -808,6 +813,7 @@ sub createImageCPIO {
 	my $kiwi = $this-&gt;{kiwi};
 	my $xml  = $this-&gt;{xml};
 	my $imageTree = $this-&gt;{imageTree};
+	my $zipper    = $this-&gt;{gdata}-&gt;{Gzip};
 	my $compress  = 1;
 	#==========================================
 	# PRE filesystem setup
@@ -838,7 +844,7 @@ sub createImageCPIO {
 	}
 	if ($compress) {
 		$data = qxx (
-			&quot;cd $imageTree &amp;&amp; find . | cpio @cpio | $main::Gzip -f &gt; $dest&quot;
+			&quot;cd $imageTree &amp;&amp; find . | cpio @cpio | $zipper -f &gt; $dest&quot;
 		);
 	} else {
 		$data = qxx (&quot;rm -f $dest &amp;&amp; rm -f $dest.gz&quot;);
@@ -1004,7 +1010,7 @@ sub createImageRootAndBoot {
 		#------------------------------------------
 		my $configDir;
 		if (($stype{boot} !~ /^\//) &amp;&amp; (! -d $stype{boot})) {
-			$configDir = $main::System.&quot;/&quot;.$stype{boot};
+			$configDir = $this-&gt;{gdata}-&gt;{System}.&quot;/&quot;.$stype{boot};
 		} else {
 			$configDir = $stype{boot};
 		}
@@ -1056,7 +1062,7 @@ sub createImageRootAndBoot {
 	#==========================================
 	# Include splash screen to initrd
 	#------------------------------------------
-	my $kboot  = new KIWIBoot ($kiwi,$initrd);
+	my $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);
 	if (! defined $kboot) {
 		return undef;
 	}
@@ -1486,7 +1492,7 @@ sub createImageLiveCD {
 		#------------------------------------------
 		my $configDir;
 		if (($stype{boot} !~ /^\//) &amp;&amp; (! -d $stype{boot})) {
-			$configDir = $main::System.&quot;/&quot;.$stype{boot};
+			$configDir = $this-&gt;{gdata}-&gt;{System}.&quot;/&quot;.$stype{boot};
 		} else {
 			$configDir = $stype{boot};
 		}
@@ -1674,7 +1680,8 @@ sub createImageLiveCD {
 	}
 	chomp $tmpdir;
 	push @{$this-&gt;{tmpdirs}},$tmpdir;
-	$data = qxx (&quot;$main::Gzip -cd $pinitrd | (cd $tmpdir &amp;&amp; cpio -di 2&gt;&amp;1)&quot;);
+	my $zipper = $this-&gt;{gdata}-&gt;{Gzip};
+	$data = qxx (&quot;$zipper -cd $pinitrd | (cd $tmpdir &amp;&amp; cpio -di 2&gt;&amp;1)&quot;);
 	$code = $? &gt;&gt; 8;
 	if ($code != 0) {
 		$kiwi -&gt; failed();
@@ -1862,7 +1869,8 @@ sub createImageLiveCD {
 	if (! defined $gzip) {
 		$attr = &quot;-R -J -pad -joliet-long&quot;;
 	}
-	$attr .= &quot; -p \&quot;$main::Preparer\&quot; -publisher \&quot;$main::Publisher\&quot;&quot;;
+	$attr .= ' -p &quot;'.$this-&gt;{gdata}-&gt;{Preparer}.'&quot;';
+	$attr .= ' -publisher &quot;'.$this-&gt;{gdata}-&gt;{Publisher}.'&quot;';
 	if (! defined $gzip) {
 		$attr .= &quot; -iso-level 4&quot;; 
 	}
@@ -2391,7 +2399,7 @@ sub createImageSplit {
 		if (! -d $source) {
 			next;
 		}
-		my %fsattr = main::checkFileSystem ($type);
+		my %fsattr = $main::global -&gt; checkFileSystem ($type);
 		if (! $fsattr{readonly}) {
 			#==========================================
 			# mount logical extend for data transfer
@@ -2527,7 +2535,7 @@ sub createImageSplit {
 		#------------------------------------------
 		my $configDir;
 		if (($type{boot} !~ /^\//) &amp;&amp; (! -d $type{boot})) {
-			$configDir = $main::System.&quot;/&quot;.$type{boot};
+			$configDir = $this-&gt;{gdata}-&gt;{System}.&quot;/&quot;.$type{boot};
 		} else {
 			$configDir = $type{boot};
 		}
@@ -2579,7 +2587,7 @@ sub createImageSplit {
 	#==========================================
 	# Include splash screen to initrd
 	#------------------------------------------
-	my $kboot  = new KIWIBoot ($kiwi,$initrd);
+	my $kboot  = new KIWIBoot ($kiwi,$initrd,$cmdL);
 	if (! defined $kboot) {
 		return undef;
 	}
@@ -2764,7 +2772,9 @@ sub writeImageConfig {
 					$targetPartitionNext = $targetPartition + 1;
 				}
 				if ($href -&gt; {size} eq &quot;image&quot;) {
-					my $size = main::isize (&quot;$this-&gt;{imageDest}/$name&quot;);
+					my $size = $main::global -&gt; isize (
+						&quot;$this-&gt;{imageDest}/$name&quot;
+					);
 					print FD int (($size/1024/1024)+1);
 				} else {
 					print FD $href -&gt; {size};
@@ -3037,7 +3047,7 @@ sub buildLogicalExtend {
 	if ($type{luks}) {
 		$encode = 1;
 		$cipher = &quot;$type{luks}&quot;;
-		$main::LuksCipher = $cipher;
+		$main::global -&gt; setGlobals (&quot;LuksCipher&quot;,$cipher);
 	}
 	#==========================================
 	# Calculate block size and number of blocks
@@ -3451,12 +3461,15 @@ sub setupEXT2 {
 	my $name    = shift;
 	my $journal = shift;
 	my $device  = shift;
+	my $cmdL    = $this-&gt;{cmdL};
 	my $kiwi    = $this-&gt;{kiwi};
-	my $xml  = $this-&gt;{xml};
-	my %type = %{$xml-&gt;getImageTypeAndAttributes()};
+	my $xml     = $this-&gt;{xml};
+	my %type    = %{$xml-&gt;getImageTypeAndAttributes()};
 	my $fsopts;
 	my $tuneopts;
-	my %FSopts = main::checkFSOptions();
+	my %FSopts = $main::global -&gt; checkFSOptions(
+		@{$cmdL-&gt;getFilesystemOptions()}
+	);
 	my $fstool;
 	my $target = &quot;$this-&gt;{imageDest}/$name&quot;;
 	if ((defined $journal) &amp;&amp; ($journal eq &quot;journaled-ext3&quot;)) {
@@ -3512,8 +3525,11 @@ sub setupBTRFS {
 	my $this   = shift;
 	my $name   = shift;
 	my $device = shift;
+	my $cmdL   = $this-&gt;{cmdL};
 	my $kiwi   = $this-&gt;{kiwi};
-	my %FSopts = main::checkFSOptions();
+	my %FSopts = $main::global -&gt; checkFSOptions(
+		@{$cmdL-&gt;getFilesystemOptions()}
+	);
 	my $fsopts = $FSopts{btrfs};
 	my $target = &quot;$this-&gt;{imageDest}/$name&quot;;
 	if ($device) {
@@ -3546,8 +3562,11 @@ sub setupReiser {
 	my $this   = shift;
 	my $name   = shift;
 	my $device = shift;
-	my $kiwi = $this-&gt;{kiwi};
-	my %FSopts = main::checkFSOptions();
+	my $cmdL   = $this-&gt;{cmdL};
+	my $kiwi   = $this-&gt;{kiwi};
+	my %FSopts = $main::global -&gt; checkFSOptions(
+		@{$cmdL-&gt;getFilesystemOptions()}
+	);
 	my $fsopts = $FSopts{reiserfs};
 	my $target = &quot;$this-&gt;{imageDest}/$name&quot;;
 	if ($device) {
@@ -3615,10 +3634,13 @@ sub setupSquashFS {
 # setupXFS
 #------------------------------------------
 sub setupXFS {
-	my $this = shift;
-	my $name = shift;
-	my $kiwi = $this-&gt;{kiwi};
-	my %FSopts = main::checkFSOptions();
+	my $this   = shift;
+	my $name   = shift;
+	my $cmdL   = $this-&gt;{cmdL};
+	my $kiwi   = $this-&gt;{kiwi};
+	my %FSopts = $main::global -&gt; checkFSOptions(
+		@{$cmdL-&gt;getFilesystemOptions()}
+	);
 	my $fsopts = $FSopts{xfs};
 	my $data = qxx (
 		&quot;/sbin/mkfs.xfs $fsopts $this-&gt;{imageDest}/$name 2&gt;&amp;1&quot;
@@ -3658,7 +3680,7 @@ sub buildMD5Sum {
 	# Create image md5sum
 	#------------------------------------------
 	$kiwi -&gt; info (&quot;Creating image MD5 sum...&quot;);
-	my $size = main::isize (&quot;$this-&gt;{imageDest}/$name&quot;);
+	my $size = $main::global -&gt; isize (&quot;$this-&gt;{imageDest}/$name&quot;);
 	my $primes = qxx (&quot;factor $size&quot;); $primes =~ s/^.*: //;
 	my $blocksize = 1;
 	for my $factor (split /\s/,$primes) {
@@ -3735,7 +3757,7 @@ sub compressImage {
 	# Compress image using gzip
 	#------------------------------------------
 	$kiwi -&gt; info (&quot;Compressing image...&quot;);
-	my $data = qxx (&quot;$main::Gzip -f $this-&gt;{imageDest}/$name&quot;);
+	my $data = qxx (&quot;$this-&gt;{gdata}-&gt;{Gzip} -f $this-&gt;{imageDest}/$name&quot;);
 	my $code = $? &gt;&gt; 8;
 	if ($code != 0) {
 		$kiwi -&gt; failed ();
@@ -3767,7 +3789,7 @@ sub updateMD5File {
 			return undef;
 		}
 		my $line = &lt;FD&gt;; close FD; chomp $line;
-		my $size = main::isize ($image);
+		my $size = $main::global -&gt; isize ($image);
 		my $primes = qxx (&quot;factor $size&quot;); $primes =~ s/^.*: //;
 		my $blocksize = 1;
 		for my $factor (split /\s/,$primes) {
@@ -3888,6 +3910,7 @@ sub checkKernel {
 	my $name    = shift;
 	my $kiwi    = $this-&gt;{kiwi};
 	my $arch    = $this-&gt;{arch};
+	my $zipper  = $this-&gt;{gdata}-&gt;{Gzip};
 	my %sysk    = ();
 	my %bootk   = ();
 	my $status;
@@ -3913,7 +3936,7 @@ sub checkKernel {
 	my $cmd = &quot;cat $initrd&quot;;
 	my $zip = 0;
 	if ($initrd =~ /\.gz$/) {
-		$cmd = &quot;$main::Gzip -cd $initrd&quot;;
+		$cmd = &quot;$zipper -cd $initrd&quot;;
 		$zip = 1;
 	}
 	my @status = qxx (&quot;$cmd|cpio -it --quiet 'lib/modules/*'|cut -f1-3 -d/&quot;);
@@ -4001,7 +4024,9 @@ sub checkKernel {
 	qxx (&quot;cp -a  $systree/boot $tmpdir&quot;);
 	qxx (&quot;rm -rf $tmpdir/lib/modules&quot;);
 	qxx (&quot;cp -a  $systree/lib/modules $tmpdir/lib&quot;);
-	qxx (&quot;cp $main::BasePath/modules/KIWIConfig.sh $tmpdir/.kconfig&quot;);
+	qxx (
+		&quot;cp $this-&gt;{gdata}-&gt;{BasePath}/modules/KIWIConfig.sh $tmpdir/.kconfig&quot;
+	);
 	qxx (&quot;chmod u+x $tmpdir/images.sh&quot;);
 	#==========================================
 	# 4) call images.sh script...
@@ -4033,7 +4058,7 @@ sub checkKernel {
 	$status = qxx ( &quot;cd $tmpdir &amp;&amp; find . | cpio @cpio &gt; $dest/$name&quot;);
 	if ($zip) {
 		$status = qxx (
-			&quot;cd $tmpdir &amp;&amp; cat $dest/$name | $main::Gzip -f &gt; $initrd&quot;
+			&quot;cd $tmpdir &amp;&amp; cat $dest/$name | $zipper -f &gt; $initrd&quot;
 		);
 	} 
 	#==========================================
diff --git a/modules/KIWIImageCreator.pm b/modules/KIWIImageCreator.pm
index f84b2c7..d81e0ee 100644
--- a/modules/KIWIImageCreator.pm
+++ b/modules/KIWIImageCreator.pm
@@ -76,8 +76,9 @@ sub new {
 	#==========================================
 	# Store object data
 	#------------------------------------------
-	$this-&gt;{kiwi}             = $kiwi;
-	$this-&gt;{cmdL}             = $cmdL;
+	$this-&gt;{kiwi}  = $kiwi;
+	$this-&gt;{cmdL}  = $cmdL;
+	$this-&gt;{gdata} = $main::global -&gt; getGlobals();
 	#==========================================
 	# Store object data
 	#------------------------------------------
@@ -189,7 +190,10 @@ sub upgradeImage {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {
@@ -277,7 +281,10 @@ sub prepareImage {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {
@@ -379,7 +386,10 @@ sub createBootImage {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {
@@ -422,8 +432,8 @@ sub createBootImage {
 	#==========================================
 	# Create destdir if needed
 	#------------------------------------------
-	my $dirCreated = $this -&gt; createDirInteractive(
-		$destination
+	my $dirCreated = $main::global -&gt; createDirInteractive(
+		$destination,$cmdL -&gt; getDefaultAnswer()
 	);
 	if (! defined $dirCreated) {
 		return undef;
@@ -483,7 +493,10 @@ sub createImage {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {
@@ -559,8 +572,8 @@ sub createImage {
 	#==========================================
 	# Create destdir if needed
 	#------------------------------------------
-	my $dirCreated = $this -&gt; createDirInteractive(
-		$destination
+	my $dirCreated = $main::global -&gt; createDirInteractive(
+		$destination,$cmdL -&gt; getDefaultAnswer()
 	);
 	if (! defined $dirCreated) {
 		return undef;
@@ -786,7 +799,9 @@ sub createImage {
 		if (($checkFormat) &amp;&amp; ($attr{format})) {
 			my $haveFormat = $attr{format};
 			my $imgfile= $destination.&quot;/&quot;.$image -&gt; buildImageName();
-			my $format = new KIWIImageFormat ($kiwi,$imgfile,$haveFormat);
+			my $format = new KIWIImageFormat (
+				$kiwi,$imgfile,$cmdL,$haveFormat
+			);
 			if (! $format) {
 				return undef;
 			}
@@ -812,7 +827,8 @@ sub createSplash {
 	my $this = shift;
 	my $kiwi = $this-&gt;{kiwi};
 	my $ird  = $this-&gt;{initrd};
-	my $boot = new KIWIBoot ($kiwi,$ird);
+	my $cmdL = $this-&gt;{cmdL};
+	my $boot = new KIWIBoot ($kiwi,$ird,$cmdL);
 	if (! defined $boot) {
 		return undef;
 	}
@@ -834,8 +850,9 @@ sub createImageBootUSB {
 	my $this = shift;
 	my $kiwi = $this-&gt;{kiwi};
 	my $ird  = $this-&gt;{initrd};
+	my $cmdL = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;Creating boot USB stick from: $ird...\n&quot;);
-	my $boot = new KIWIBoot ($kiwi,$ird);
+	my $boot = new KIWIBoot ($kiwi,$ird,$cmdL);
 	if (! defined $boot) {
 		return undef;
 	}
@@ -860,8 +877,9 @@ sub createImageBootCD {
 	my $this = shift;
 	my $kiwi = $this-&gt;{kiwi};
 	my $ird  = $this-&gt;{initrd};
+	my $cmdL = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;Creating boot ISO from: $ird...\n&quot;);
-	my $boot = new KIWIBoot ($kiwi,$ird);
+	my $boot = new KIWIBoot ($kiwi,$ird,$cmdL);
 	if (! defined $boot) {
 		return undef;
 	}
@@ -885,13 +903,14 @@ sub createImageInstallCD {
 	my $kiwi = $this-&gt;{kiwi};
 	my $ird  = $this-&gt;{initrd};
 	my $sys  = $this-&gt;{sysloc};
+	my $cmdL = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;Creating install ISO from: $ird...\n&quot;);
 	if (! defined $sys) {
 		$kiwi -&gt; error  (&quot;No Install system image specified&quot;);
 		$kiwi -&gt; failed ();
 		return undef;
 	}
-	my $boot = new KIWIBoot ($kiwi,$ird,$sys);
+	my $boot = new KIWIBoot ($kiwi,$ird,$cmdL,$sys);
 	if (! defined $boot) {
 		return undef;
 	}
@@ -915,13 +934,14 @@ sub createImageInstallStick {
 	my $kiwi = $this-&gt;{kiwi};
 	my $ird  = $this-&gt;{initrd};
 	my $sys  = $this-&gt;{sysloc};
+	my $cmdL = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;Creating install Stick from: $ird...\n&quot;);
 	if (! defined $sys) {
 		$kiwi -&gt; error  (&quot;No Install system image specified&quot;);
 		$kiwi -&gt; failed ();
 		return undef;
 	}
-	my $boot = new KIWIBoot ($kiwi,$ird,$sys);
+	my $boot = new KIWIBoot ($kiwi,$ird,$cmdL,$sys);
 	if (! defined $boot) {
 		return undef;
 	}
@@ -945,6 +965,7 @@ sub createImageDisk {
 	my $size = $this-&gt;{disksize};
 	my $tdev = $this-&gt;{targetdevice};
 	my $prof = $this-&gt;{buildProfiles};
+	my $cmdL = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;--&gt; Creating boot VM disk from: $ird...\n&quot;);
 	if (! defined $sys) {
 		$kiwi -&gt; error  (&quot;No VM system image specified&quot;);
@@ -960,7 +981,7 @@ sub createImageDisk {
 		return undef;
 	}
 	my $boot = new KIWIBoot (
-		$kiwi,$ird,$sys,$size,undef,$prof
+		$kiwi,$ird,$cmdL,$sys,$size,undef,$prof
 	);
 	if (! defined $boot) {
 		return undef;
@@ -982,8 +1003,11 @@ sub createImageFormat {
 	my $kiwi   = $this-&gt;{kiwi};
 	my $format = $this-&gt;{format};
 	my $sys    = $this-&gt;{sysloc};
+	my $cmdL   = $this-&gt;{cmdL};
 	$kiwi -&gt; info (&quot;--&gt; Starting image format conversion...\n&quot;);
-	my $imageformat = new KIWIImageFormat ($kiwi,$sys,$format);
+	my $imageformat = new KIWIImageFormat (
+		$kiwi,$sys,$cmdL,$format
+	);
 	if (! $imageformat) {
 		return undef;
 	}
@@ -1085,7 +1109,7 @@ sub __selectCache {
 		return undef;
 	}
 	my $icache = new KIWICache (
-		$kiwi,$xml,$this-&gt;{cacheDir},$main::BasePath,
+		$kiwi,$xml,$this-&gt;{cacheDir},$this-&gt;{gdata}-&gt;{BasePath},
 		$this-&gt;{buildProfiles},$configDir
 	);
 	if (! $icache) {
@@ -1194,35 +1218,6 @@ sub __prepareTree {
 	return 1;
 }
 
-#============================================
-# createDirInteractive
-#--------------------------------------------
-sub createDirInteractive {
-	my $this      = shift;
-	my $targetDir = shift;
-	my $kiwi      = $this-&gt;{kiwi};
-	if (! -d $targetDir) {
-		my $prefix = $kiwi -&gt; getPrefix (1);
-		my $answer = (defined $main::defaultAnswer) ? &quot;yes&quot; : &quot;unknown&quot;;
-		$kiwi -&gt; info (&quot;Destination: $targetDir doesn't exist\n&quot;);
-		while ($answer !~ /^yes$|^no$/) {
-			print STDERR $prefix,
-				&quot;Would you like kiwi to create it [yes/no] ? &quot;;
-			chomp ($answer = &lt;&gt;);
-		}
-		if ($answer eq &quot;yes&quot;) {
-			qxx (&quot;mkdir -p $targetDir&quot;);
-			return 1;
-		}
-	} else {
-		# Directory exists
-		return 1;
-	}
-	# Directory does not exist and user did
-	# not request dir creation.
-	return undef;
-}
-
 #==========================================
 # checkType
 #------------------------------------------
@@ -1268,7 +1263,7 @@ sub checkType {
 			@fs = split (/,/,$type{filesystem});
 		}
 		foreach my $fs (@fs) {
-			my %result = main::checkFileSystem ($fs);
+			my %result = $main::global -&gt; checkFileSystem ($fs);
 			if (%result) {
 				if (! $result{hastool}) {
 					$kiwi -&gt; error (
diff --git a/modules/KIWIImageFormat.pm b/modules/KIWIImageFormat.pm
index 995d7ef..4ed92ee 100644
--- a/modules/KIWIImageFormat.pm
+++ b/modules/KIWIImageFormat.pm
@@ -46,6 +46,7 @@ sub new {
 	#------------------------------------------
 	my $kiwi   = shift;
 	my $image  = shift;
+	my $cmdL   = shift;
 	#==========================================
 	# Module Parameters [ optional ]
 	#------------------------------------------
@@ -72,7 +73,7 @@ sub new {
 	#------------------------------------------
 	if (! defined $xml) {
 		my $boot = new KIWIBoot (
-			$kiwi,undef,$image,undef,undef,\@main::ProfilesOrig
+			$kiwi,undef,$cmdL,$image,undef,undef,\@main::ProfilesOrig
 		);
 		if ($boot) {
 			$xml = $boot-&gt;{xml};
@@ -109,6 +110,7 @@ sub new {
 	$this-&gt;{image}   = $image;
 	$this-&gt;{type}    = $type;
 	$this-&gt;{imgtype} = $type-&gt;{type};
+	$this-&gt;{gdata}   = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -349,7 +351,7 @@ sub createEC2 {
 	# Import AWS region kernel map
 	#------------------------------------------
 	my %ec2RegionKernelMap;
-	if (! open ($FD,$main::KRegion)) {
+	if (! open ($FD,$this-&gt;{gdata}-&gt;{KRegion})) {
 		return undef;
 	}
 	while (my $line = &lt;$FD&gt;) {
diff --git a/modules/KIWIIsoLinux.pm b/modules/KIWIIsoLinux.pm
index bf04012..93247e9 100644
--- a/modules/KIWIIsoLinux.pm
+++ b/modules/KIWIIsoLinux.pm
@@ -198,6 +198,7 @@ sub new {
 	$this -&gt; {catalog}= \@catalog;
 	$this -&gt; {tool}   = $tool;
 	$this -&gt; {check}  = $mediacheck;
+	$this -&gt; {gdata}  = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -343,7 +344,8 @@ sub ppc64_default {
 	$para.= &quot; -hfs-volid FIXME&quot;; # FIXME should be same as value of -A
 	$para.= &quot; -l&quot;;
 	$para.= &quot; --macbin&quot;;
-	$para.= &quot; -map $main::BasePath/modules/KIWIIsoLinux-AppleFileMapping.txt&quot;;
+	$para.= &quot; -map $this-&gt;{gdata}-&gt;{BasePath}&quot;;
+	$para.= &quot;/modules/KIWIIsoLinux-AppleFileMapping.txt&quot;;
 	$para.= &quot; --netatalk&quot;;
 	$para.= &quot; -part&quot;;
 	$para.= &quot; -T&quot;;
diff --git a/modules/KIWILog.pm b/modules/KIWILog.pm
index 9a7bfba..26e6bd5 100644
--- a/modules/KIWILog.pm
+++ b/modules/KIWILog.pm
@@ -49,7 +49,7 @@ sub new {
 	#==========================================
 	# Module Parameters
 	#------------------------------------------
-	my $tiny  = shift;
+	my $port = shift;
 	#==========================================
 	# Store object data
 	#------------------------------------------
@@ -63,7 +63,7 @@ sub new {
 	#==========================================
 	# Check for tiny object
 	#------------------------------------------
-	if (defined $tiny) {
+	if ((defined $port) &amp;&amp; (int $port == 0)) {
 		return $this;
 	}
 	#==========================================
@@ -79,15 +79,7 @@ sub new {
 	#==========================================
 	# Create Log Server on $LogServerPort
 	#------------------------------------------
-	my $logPort = $main::LogServerPort;
-	if ($logPort ne &quot;off&quot;) {
-		if ($logPort =~ m/\D/) {
-			$this -&gt; warning (&quot;Non numerical port number specified&quot;);
-			$this -&gt; skipped ();
-			return $this;
-		}
-		$this -&gt; setLogServer();
-	}
+	$this -&gt; setLogServer ($port);
 	return $this;
 }
 
@@ -858,6 +850,7 @@ sub setLogServer {
 	# query is a XML formated information
 	# ---
 	my $this  = shift;
+	my $port  = shift;
 	my $child = fork();
 	if (! defined $child) {
 		$this -&gt; warning (&quot;Can't fork logserver process: $!&quot;);
@@ -881,10 +874,10 @@ sub setLogServer {
 		#------------------------------------------
 		our @logChilds = ();
 		our %logChilds = ();
-		our $logServer = new KIWISocket ( $this,$main::LogServerPort );
+		our $logServer = new KIWISocket ($this,$port);
 		our $sharedMem = $this-&gt;{smem};
 		if (! defined $logServer) {
-			$this -&gt; warning (&quot;Can't open log port: $main::LogServerPort\n&quot;);
+			$this -&gt; warning (&quot;Can't open log port: $port\n&quot;);
 			$sharedMem -&gt; closeSegment();
 			undef $this-&gt; {smem};
 			exit 1;
@@ -1003,10 +996,11 @@ sub storeXML {
 # writeXML
 #------------------------------------------
 sub writeXML {
-	my $this = shift;
-	my $data = $this-&gt;{xmlString};
-	my $cmpf = $this-&gt;{xmlOrigFile};
-	my $cache= $this-&gt;{xmlCache};
+	my $this   = shift;
+	my $pretty = shift;
+	my $data   = $this-&gt;{xmlString};
+	my $cmpf   = $this-&gt;{xmlOrigFile};
+	my $cache  = $this-&gt;{xmlCache};
 	my @NC;
 	my $FX;
 	if ((! $data) || (! -f $cmpf)) {
@@ -1033,9 +1027,9 @@ sub writeXML {
 	}
 	binmode $FX;
 	print $FX $data; close $FX;
-	qxx (&quot;xsltproc -o $used.new $main::Pretty $used&quot;);
+	qxx (&quot;xsltproc -o $used.new $pretty $used&quot;);
 	qxx (&quot;mv $used.new $used&quot;);
-	qxx (&quot;xsltproc -o $orig.new $main::Pretty $orig&quot;);
+	qxx (&quot;xsltproc -o $orig.new $pretty $orig&quot;);
 	qxx (&quot;mv $orig.new $orig&quot;);
 	my $diff  = qxx (&quot;diff -uwB $orig $used | grep -v -E '^[-+]{3}' 2&gt;&amp;1&quot;);
 	if (! $diff) {
diff --git a/modules/KIWIMigrate.pm b/modules/KIWIMigrate.pm
index 2829935..fd131a8 100644
--- a/modules/KIWIMigrate.pm
+++ b/modules/KIWIMigrate.pm
@@ -218,7 +218,7 @@ sub new {
 	$this-&gt;{product} = $product;
 	$this-&gt;{mount}   = [];
 	$this-&gt;{autoyastCloneList} = \@autoyastCloneList;
-
+	$this-&gt;{gdata}   = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -244,7 +244,7 @@ sub createReport {
 	# Beautify report...
 	#------------------------------------------
 	mkdir &quot;$dest/.report&quot;;
-	qxx (&quot;tar -C $dest/.report -xf $main::KMigraCSS 2&gt;&amp;1&quot;);
+	qxx (&quot;tar -C $dest/.report -xf $this-&gt;{gdata}-&gt;{KMigraCSS} 2&gt;&amp;1&quot;);
 	#==========================================
 	# Start report
 	#------------------------------------------
@@ -797,7 +797,7 @@ sub setTemplate {
 	#==========================================
 	# create xml description
 	#------------------------------------------
-	if (! open (FD,&quot;&gt;$dest/$main::ConfigName&quot;)) {
+	if (! open (FD,&quot;&gt;$dest/$this-&gt;{gdata}-&gt;{ConfigName}&quot;)) {
 		return undef;
 	}
 	#==========================================
@@ -898,7 +898,7 @@ sub getOperatingSystemVersion {
 		}
 	}
 	close FD;
-	if (! open (FD,$main::KMigrate)) {
+	if (! open (FD,$this-&gt;{gdata}-&gt;{KMigrate})) {
 		return undef;
 	}
 	while (my $line = &lt;FD&gt;) {
@@ -1242,7 +1242,7 @@ sub setSystemOverlayFiles {
 			$kiwi -&gt; warning (&quot;=&gt; Cache doesn't provide version&quot;);
 			$kiwi -&gt; skipped ();
 			undef $cache;
-		} elsif ($cdata-&gt;{version} ne $main::Version) {
+		} elsif ($cdata-&gt;{version} ne $this-&gt;{gdata}-&gt;{Version}) {
 			$kiwi -&gt; warning (&quot;=&gt; Cache version doesn't match&quot;);
 			$kiwi -&gt; skipped ();
 			undef $cache;
@@ -1417,7 +1417,7 @@ sub setSystemOverlayFiles {
 	# Write cache if required
 	#------------------------------------------
 	if (! $cache) {
-		$cdata-&gt;{version} = $main::Version;
+		$cdata-&gt;{version} = $this-&gt;{gdata}-&gt;{Version};
 		store ($cdata,$dest.&quot;.cache&quot;);
 	}
 	#==========================================
diff --git a/modules/KIWIOverlay.pm b/modules/KIWIOverlay.pm
index e449b54..8b182a4 100644
--- a/modules/KIWIOverlay.pm
+++ b/modules/KIWIOverlay.pm
@@ -104,7 +104,7 @@ sub unionOverlay {
 	my $kiwi   = $this-&gt;{kiwi};
 	my $baseRO = $this-&gt;{baseRO};
 	my $rootRW = $this-&gt;{rootRW};
-	my %fsattr = main::checkFileSystem ($baseRO);
+	my %fsattr = $main::global -&gt; checkFileSystem ($baseRO);
 	my $type   = $fsattr{type};
 	my @mount  = ();
 	my $haveCow= 0;
diff --git a/modules/KIWIRoot.pm b/modules/KIWIRoot.pm
index 1e146aa..f36ce2e 100644
--- a/modules/KIWIRoot.pm
+++ b/modules/KIWIRoot.pm
@@ -69,7 +69,7 @@ sub new {
 		$kiwi = new KIWILog(&quot;tiny&quot;);
 	}
 	if (($imageDesc !~ /^\//) &amp;&amp; (! -d $imageDesc)) {
-		$imageDesc = $main::System.&quot;/&quot;.$imageDesc;
+		$imageDesc = $this-&gt;{gdata}-&gt;{System}.&quot;/&quot;.$imageDesc;
 	}
 	if (! defined $baseSystem) {
 		$kiwi -&gt; error (&quot;No base system path specified&quot;);
@@ -180,6 +180,7 @@ sub new {
 	$this-&gt;{addPacks}      = $addPacks;
 	$this-&gt;{delPacks}      = $delPacks;
 	$this-&gt;{cacheRoot}     = $cacheRoot;
+	$this-&gt;{gdata}         = $main::global -&gt; getGlobals();
 	#==========================================
 	# check channel count
 	#------------------------------------------
@@ -335,7 +336,7 @@ sub init {
 	#==================================
 	# Copy helper scripts to new root
 	#----------------------------------
-	qxx (&quot;cp $main::KConfig $root/.kconfig 2&gt;&amp;1&quot;);
+	qxx (&quot;cp $this-&gt;{gdata}-&gt;{KConfig} $root/.kconfig 2&gt;&amp;1&quot;);
 	#==================================
 	# Return early if existing root
 	#----------------------------------
diff --git a/modules/KIWIURL.pm b/modules/KIWIURL.pm
index bfee88c..0d17b29 100644
--- a/modules/KIWIURL.pm
+++ b/modules/KIWIURL.pm
@@ -60,6 +60,7 @@ sub new {
 	$this-&gt;{user} = $user;
 	$this-&gt;{pwd}  = $pwd;
 	$this-&gt;{type} = &quot;unknown&quot;;
+	$this-&gt;{gdata}= $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -228,7 +229,7 @@ sub systemPath {
 	#---
 	my $this   = shift;
 	my $module = shift;
-	my $prefix = $main::System;
+	my $prefix = $this-&gt;{gdata}-&gt;{System};
 	my $kiwi   = $this-&gt;{kiwi};
 	my $path    = undef;
 	#==========================================
@@ -528,7 +529,7 @@ sub openSUSEpath {
 	my $quiet    = shift;
 	my $kiwi     = $this-&gt;{kiwi};
 	my $browser  = LWP::UserAgent-&gt;new;
-	my $uriTable = $main::repoURI;
+	my $uriTable = $this-&gt;{gdata}-&gt;{repoURI};
 	my $origurl  = $module;
 	my %matches  = ();
 	my $FD;
diff --git a/modules/KIWIXML.pm b/modules/KIWIXML.pm
index 393c9e7..240fdf4 100644
--- a/modules/KIWIXML.pm
+++ b/modules/KIWIXML.pm
@@ -107,6 +107,7 @@ sub new {
 	#------------------------------------------
 	$this-&gt;{kiwi} = $kiwi;
 	$this-&gt;{arch} = $arch;
+	$this-&gt;{gdata}= $main::global -&gt; getGlobals();
 	#==========================================
 	# Lookup XML configuration file
 	#------------------------------------------
@@ -123,7 +124,10 @@ sub new {
 	# Read and Validate XML information
 	#------------------------------------------
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $systemTree = $validator -&gt; getDOM();
 	#==========================================
@@ -2119,7 +2123,7 @@ sub getImageConfig {
 	# revision information
 	#------------------------------------------
 	my $rev  = &quot;unknown&quot;;
-	if (open (my $FD,$main::Revision)) {
+	if (open (my $FD,$this-&gt;{gdata}-&gt;{Revision})) {
 		$rev = &lt;$FD&gt;; close $FD;
 		$rev =~ s/\n//g;
 	}
@@ -4056,11 +4060,13 @@ sub __addDefaultSplitNode {
 	my $splitXML = new XML::LibXML;
 	eval {
 		$splitTree = $splitXML
-			-&gt; parse_file ( $main::KSplit );
+			-&gt; parse_file ( $this-&gt;{gdata}-&gt;{KSplit} );
 	};
 	if ($@) {
 		my $evaldata=$@;
-		$kiwi -&gt; error  (&quot;Problem reading split file: $main::KSplit&quot;);
+		$kiwi -&gt; error  (
+			&quot;Problem reading split file: $this-&gt;{gdata}-&gt;{KSplit}&quot;
+		);
 		$kiwi -&gt; failed ();
 		$kiwi -&gt; error  (&quot;$evaldata\n&quot;);
 		return undef;
diff --git a/modules/KIWIXMLInfo.pm b/modules/KIWIXMLInfo.pm
index 00053cf..5ed33d9 100644
--- a/modules/KIWIXMLInfo.pm
+++ b/modules/KIWIXMLInfo.pm
@@ -98,7 +98,7 @@ sub new {
 	$this-&gt;{kiwi}           = $kiwi;
 	$this-&gt;{packageManager} = $cmdL -&gt; getPackageManager();
 	$this-&gt;{replRepo}       = $cmdL -&gt; getReplacementRepo();
-
+	$this-&gt;{gdata}          = $main::global -&gt; getGlobals();
 	return $this;
 }
 
@@ -136,7 +136,7 @@ sub printXMLInfo {
 	if (! $infoTree) {
 		return undef;
 	}
-	open (my $F, &quot;|xsltproc $main::Pretty -&quot;);
+	open (my $F, &quot;|xsltproc $this-&gt;{gdata}-&gt;{Pretty} -&quot;);
 	print $F $infoTree -&gt; toString();
 	close $F;
 	return 1;
@@ -513,8 +513,10 @@ sub __xmlSetup {
 		return undef;
 	}
 	my $validator = new KIWIXMLValidator (
-		$kiwi,$controlFile,$main::Revision,
-		$main::Schema,$main::SchemaCVT
+		$kiwi,$controlFile,
+		$this-&gt;{gdata}-&gt;{Revision},
+		$this-&gt;{gdata}-&gt;{Schema},
+		$this-&gt;{gdata}-&gt;{SchemaCVT}
 	);
 	my $isValid = $validator ? $validator -&gt; validate() : undef;
 	if (! $isValid) {


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003441.html">[Kiwi-devel] run tests during package build
</A></li>
	<LI>Next message: <A HREF="003438.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 01353d5fd6fde1562bf0ad20722e4b1a748d282a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3440">[ date ]</a>
              <a href="thread.html#3440">[ thread ]</a>
              <a href="subject.html#3440">[ subject ]</a>
              <a href="author.html#3440">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
