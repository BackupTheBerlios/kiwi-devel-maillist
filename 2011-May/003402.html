<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 9918d1480fc21e25339dc1a6ace55fbcc51c4848
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%209918d1480fc21e25339dc1a6ace55fbcc51c4848&In-Reply-To=%3C20110511144405.205CE481227%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003400.html">
   <LINK REL="Next"  HREF="003403.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 9918d1480fc21e25339dc1a6ace55fbcc51c4848</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%209918d1480fc21e25339dc1a6ace55fbcc51c4848&In-Reply-To=%3C20110511144405.205CE481227%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 9918d1480fc21e25339dc1a6ace55fbcc51c4848">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Wed May 11 16:44:04 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003400.html">[Kiwi-devel] style clean up, eliminate a bare word
</A></li>
        <LI>Next message: <A HREF="003403.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. c9c797b47cb4f785174dec004853d21d511fd090
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3402">[ date ]</a>
              <a href="thread.html#3402">[ thread ]</a>
              <a href="subject.html#3402">[ subject ]</a>
              <a href="author.html#3402">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  9918d1480fc21e25339dc1a6ace55fbcc51c4848 (commit)
       via  4c980fdda42cadcf1a10c88cf8baa31020f3432c (commit)
       via  6e477f94467f0f27ba5ed6ad13c5c0d88ee7f763 (commit)
       via  de1cf292c1101166e61eb0e5100f825c357496d0 (commit)
       via  30f787215626a98e63692be008eafe5711ebefb5 (commit)
       via  79521cbf2e9c6cd9524d2fc1e8431f10eb784c0e (commit)
      from  15f625e3f2103c2a9eed9324587c726483776644 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9918d1480fc21e25339dc1a6ace55fbcc51c4848
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:40:37 2011 +0200

    - fixed use of glob-type for filehandle in KIWIRoot.pm

commit 4c980fdda42cadcf1a10c88cf8baa31020f3432c
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:37:14 2011 +0200

    - DB: fixed some typos in schema inline documentation

commit 6e477f94467f0f27ba5ed6ad13c5c0d88ee7f763
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:26:44 2011 +0200

    - expand command line object to handle more options. Also expand
      the unit tests for this options. This happened in preparation to
      the new KIWIImageCreator object which will encapsulate the kiwi
      build, prepare and create modes

commit de1cf292c1101166e61eb0e5100f825c357496d0
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:14:29 2011 +0200

    - move knowledge about the default cache directory path
      into the KIWILocator module: getDefaultCacheDir()

commit 30f787215626a98e63692be008eafe5711ebefb5
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:10:13 2011 +0200

    - update unit test infrastructure in preparation for the new
      KIWIImageCreator object which will encapsulate the kiwi
      build, prepare and create modes

commit 79521cbf2e9c6cd9524d2fc1e8431f10eb784c0e
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Wed May 11 16:08:03 2011 +0200

    - remove outdated undocumented prechrootcall option

-----------------------------------------------------------------------

Summary of changes:
diff --git a/kiwi.pl b/kiwi.pl
index 7ec5471..c49dd0c 100755
--- a/kiwi.pl
+++ b/kiwi.pl
@@ -108,7 +108,6 @@ our $Revision = $BasePath.&quot;/.revision&quot;;
 our $TestBase = $BasePath.&quot;/tests&quot;;
 our $SchemaCVT= $BasePath.&quot;/xsl/master.xsl&quot;;
 our $Pretty   = $BasePath.&quot;/xsl/print.xsl&quot;;
-our $InitCDir = &quot;/var/cache/kiwi/image&quot;;
 
 #==========================================
 # Globals (Supported filesystem names)
@@ -194,7 +193,6 @@ our $NoColor;               # do not used colored output (done/failed messages)
 our $LogPort;               # specify alternative log server port
 our $GzipCmd;               # command to run to gzip things
 our $PrebuiltBootImage;     # directory where a prepared boot image may be found
-our $PreChrootCall;         # program name called before chroot switch
 our $CreatePassword;        # create crypted password
 our $ISOCheck;              # create checkmedia boot entry
 our $FSBlockSize;           # filesystem block size
@@ -367,7 +365,7 @@ sub main {
 		# Create cache(s)...
 		#------------------------------------------
 		if (! defined $ImageCache) {
-			$ImageCache = $main::InitCDir;
+			$ImageCache = $locator -&gt; getDefaultCacheDir();
 		}
 		my $cacheInit = initializeCache($xml,\%type,$InitCache);
 		if (! createCache ($xml,$cacheInit)) {
@@ -511,26 +509,6 @@ sub main {
 			my $code = kiwiExit (1); return $code;
 		}
 		#==========================================
-		# Check for pre chroot call
-		#------------------------------------------
-		if (defined $PreChrootCall) {
-			$kiwi -&gt; info (&quot;Calling pre-chroot program: $PreChrootCall&quot;);
-			my $path = $root -&gt; getRootPath();
-			my $data = qxx (&quot;$PreChrootCall $path 2&gt;&amp;1&quot;);
-			my $code = $? &gt;&gt; 8;
-			if ($code != 0) {
-				$kiwi -&gt; failed ();
-				$kiwi -&gt; info   ($data);
-				$kiwi -&gt; failed ();
-				$root -&gt; copyBroken();
-				undef $root;
-				my $code = kiwiExit (1); return $code;
-			} else {
-				$kiwi -&gt; loginfo (&quot;$PreChrootCall: $data&quot;);
-			}
-			$kiwi -&gt; done ();
-		}
-		#==========================================
 		# Install root system
 		#------------------------------------------
 		if (! $root -&gt; install ()) {
@@ -1367,7 +1345,6 @@ sub init {
 		&quot;package-manager=s&quot;     =&gt; \$PackageManager,
 		&quot;partitioner=s&quot;         =&gt; \$Partitioner,
 		&quot;prebuiltbootimage=s&quot;   =&gt; \$PrebuiltBootImage,
-		&quot;prechroot-call=s&quot;      =&gt; \$PreChrootCall,
 		&quot;prepare|p=s&quot;           =&gt; \$Prepare,
 		&quot;recycle-root&quot;          =&gt; \$RecycleRoot,
 		&quot;root|r=s&quot;              =&gt; \$RootTree,
@@ -1404,12 +1381,24 @@ sub init {
 		}
 	}
 	#========================================
+	# check if prepare &amp; create
+	#----------------------------------------
+	if (defined $Build) {
+		$cmdL -&gt; setConfigDir ($Build);
+	}
+	#========================================
 	# check if repositories are to be ignored
 	#----------------------------------------
 	if (defined $IgnoreRepos) {
 		$cmdL -&gt; setIgnoreRepos(1);
 	}
 	#========================================
+	# check for specified cache location
+	#----------------------------------------
+	if (defined $ImageCache) {
+		$cmdL -&gt; setCacheDir($ImageCache)
+	}
+	#========================================
 	# check if we are doing caching
 	#----------------------------------------
 	if (defined $InitCache) {
@@ -1463,6 +1452,7 @@ sub init {
 	#----------------------------------------
 	if (defined $RecycleRoot) {
 		$RecycleRoot = $RootTree;
+		$cmdL -&gt; enableRootRecycle();
 	}
 	#========================================
 	# check replacement repo information
@@ -1479,6 +1469,12 @@ sub init {
 		}
 	}
 	#============================================
+	# check if a target arch is defined
+	#--------------------------------------------
+	if (defined $TargetArch) {
+		$cmdL -&gt; setImageArchitecture($TargetArch);
+	}
+	#============================================
 	# check Partitioner according to device
 	#--------------------------------------------
 	if (($targetDevice) &amp;&amp; ($targetDevice =~ /\/dev\/dasd/)) {
@@ -1643,6 +1639,7 @@ sub init {
 	if ((defined $RootTree) &amp;&amp; ($RootTree !~ /^\//)) {
 		my $workingDir = qxx ( &quot;pwd&quot; ); chomp $workingDir;
 		$RootTree = $workingDir.&quot;/&quot;.$RootTree;
+		$cmdL -&gt; setRootTargetDir($RootTree);
 	}
 	if (defined $LogPort) {
 		$kiwi -&gt; info (&quot;Setting log server port to: $LogPort&quot;);
@@ -1654,13 +1651,6 @@ sub init {
 		$Gzip = $GzipCmd;
 		$kiwi -&gt; done ();
 	}
-	if ((defined $PreChrootCall) &amp;&amp; (! -x $PreChrootCall)) {
-		$kiwi -&gt; error (&quot;pre-chroot program: $PreChrootCall&quot;);
-		$kiwi -&gt; failed ();
-		$kiwi -&gt; error (&quot;--&gt; 1) no such file or directory\n&quot;);
-		$kiwi -&gt; error (&quot;--&gt; 2) and/or not in executable format\n&quot;);
-		my $code = kiwiExit (1); return $code;
-	}
 	if ((defined $BootVMDisk) &amp;&amp; (! defined $BootVMSystem)) {
 		$kiwi -&gt; error (&quot;Virtual Disk setup must specify a bootvm-system&quot;);
 		$kiwi -&gt; failed ();
diff --git a/modules/KIWICommandLine.pm b/modules/KIWICommandLine.pm
index 6308f42..8e425cc 100644
--- a/modules/KIWICommandLine.pm
+++ b/modules/KIWICommandLine.pm
@@ -21,7 +21,9 @@ use strict;
 use warnings;
 require Exporter;
 use File::Spec;
+use KIWILocator;
 use KIWILog;
+use KIWIQX;
 
 #==========================================
 # Exports
@@ -60,25 +62,51 @@ sub new {
 	#==========================================
 	# Object initialize object member data
 	#------------------------------------------
-	$this-&gt;{addPackages}        = ''; # Holds array ref
-	$this-&gt;{addPatterns}        = ''; # Holds array ref
 	$this-&gt;{imageTgtDir}        = '';
 	$this-&gt;{kiwi}               = $kiwi;
-	$this-&gt;{rootTgtDir}         = '';
 	$this-&gt;{supportedRepoTypes} = \@supportedRepos;
 	return $this;
 }
 
 #==========================================
+# enableRootRecycle
+#------------------------------------------
+sub enableRootRecycle {
+	# ...
+	# Set the recycle root directory if root dir is set, else set a flag
+	# for delayed setting.
+	# ---
+	my $this = shift;
+	if ($this -&gt; {rootTgtDir}) {
+		$this -&gt; {recycleRootDir} = $this -&gt; {rootTgtDir};
+	} else {
+		$this -&gt; {setRecycleRoot} = 1;
+	}
+	return 1;
+}
+
+#==========================================
 # getAdditionalPackages
 #------------------------------------------
 sub getAdditionalPackages {
+	# ...
+	# Return information about additional packages set by the user
+	# on the command line.
+	# ---
+	my $this = shift;
+	return $this -&gt; {addPackages};
 }
 
 #==========================================
 # getAdditionalPatterns
 #------------------------------------------
 sub getAdditionalPatterns {
+	# ...
+	# Return information about additional patterns set by the user
+	# on the command line.
+	# ---
+	my $this = shift;
+	return $this-&gt;{addPatterns};
 }
 
 #==========================================
@@ -116,6 +144,17 @@ sub getBuildProfiles {
 }
 
 #==========================================
+# getCacheDir
+#------------------------------------------
+sub getCacheDir {
+	# ...
+	# Return location of the directory containing the caches
+	# ---
+	my $this = shift;
+	return $this -&gt; {cacheDir};
+}
+
+#==========================================
 # getConfigDir
 #------------------------------------------
 sub getConfigDir {
@@ -138,6 +177,17 @@ sub getIgnoreRepos {
 }
 
 #==========================================
+# getImageArchitecture
+#------------------------------------------
+sub getImageArchitecture {
+	# ...
+	# Return the architecture for this image
+	# ---
+	my $this = shift;
+	return $this -&gt; {imageArch};
+}
+
+#==========================================
 # getImageTargetDir
 #------------------------------------------
 sub getImageTargetDir {
@@ -171,6 +221,28 @@ sub getPackageManager {
 }
 
 #==========================================
+# getPackagesToRemove
+#------------------------------------------
+sub getPackagesToRemove {
+	# ...
+	# Return the list of packages to remove set on the command line as a ref
+	# ---
+	my $this = shift;
+	return $this -&gt; {removePackages};
+}
+
+#==========================================
+# getRecycleRootDir
+#------------------------------------------
+sub getRecycleRootDir {
+	# ...
+	# Return the root target directory to be recycled
+	# ---
+	my $this = shift;
+	return $this -&gt; {recycleRootDir};
+}
+
+#==========================================
 # getReplacementRepo
 #------------------------------------------
 sub getReplacementRepo {
@@ -197,12 +269,56 @@ sub getRootTargetDir {
 # setAdditionalPackages
 #------------------------------------------
 sub setAdditionalPackages {
+	# ...
+	# Set package names for packages specified on the command line
+	# ---
+	my $this     = shift;
+	my $packages = shift;
+	my $kiwi = $this-&gt;{kiwi};
+	if (! $packages) {
+		my $msg = 'setAdditionalPackages method called without specifying '
+		. 'packages';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	if (! ref $packages) {
+		my $msg = 'setAdditionalPackages method expecting ARRAY_REF as '
+			. 'first argument.';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	$this -&gt; {addPackages} = $packages;
+	return 1;
 }
 
 #==========================================
 # setAdditionalPatterns
 #------------------------------------------
 sub setAdditionalPatterns {
+	# ...
+	# Set pattern names for patterns specified on the command line
+	# ---
+	my $this     = shift;
+	my $patterns = shift;
+	my $kiwi = $this-&gt;{kiwi};
+	if (! $patterns) {
+		my $msg = 'setAdditionalPatterns method called without specifying '
+		. 'packages';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	if (! ref $patterns) {
+		my $msg = 'setAdditionalPatterns method expecting ARRAY_REF as '
+			. 'first argument.';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	$this-&gt;{addPatterns} = $patterns;
+	return 1;
 }
 
 #==========================================
@@ -311,7 +427,6 @@ sub setAdditionalRepos {
 	$repoInfo{repositoryPriorities} = $repoPrios;
 	$repoInfo{repositoryTypes}      = $repoTypes;
 	$this -&gt; {additionalRepos} = \%repoInfo;
-
 	return 1;
 }
 
@@ -355,6 +470,41 @@ sub setBuildProfiles {
 }
 
 #==========================================
+# setCacheDir
+#------------------------------------------
+sub setCacheDir {
+	# ...
+	# Set the location of the directory containing the caches
+	# ---
+	my $this = shift;
+	my $dir  = shift;
+	if (! $dir) {
+		my $msg = 'setCacheDir method called without specifying a '
+			. 'cache directory.';
+		$this -&gt; {kiwi} -&gt; error ($msg);
+		$this -&gt; {kiwi} -&gt; failed();
+		return undef;
+	}
+	if ((-d $dir) &amp;&amp; (! -w $dir)) {
+		my $msg = 'No write access to specified cache directory &quot;'
+			. &quot;$dir&quot;
+			. '&quot;.';
+		$this -&gt; {kiwi} -&gt; error ($msg);
+		$this -&gt; {kiwi} -&gt; failed();
+		return undef;
+	}
+	if ( $dir !~ /^\//) {
+		my $locator = new KIWILocator($this -&gt; {kiwi});
+		$dir = $locator -&gt; getDefaultCacheDir() . '/' . $dir;
+		my $msg = 'Specified relative path as cache location; moving cache to '
+		. &quot;$dir\n&quot;;
+		$this -&gt; {kiwi} -&gt; info ($msg);
+	}
+	$this -&gt; {cacheDir} = $dir;
+	return 1;
+}
+
+#==========================================
 # setConfigDir
 #------------------------------------------
 sub setConfigDir {
@@ -411,6 +561,34 @@ sub setIgnoreRepos {
 }
 
 #==========================================
+# setImageArchitecture
+#------------------------------------------
+sub setImageArchitecture {
+	# ...
+	# Set the architecture for this image
+	# ---
+	my $this = shift;
+	my $arch = shift;
+	my @supportedArch = qw (i586 ppc ppc64 s390  s390x  x86_64);
+	if (! $arch) {
+		my $msg = 'setImageArchitecture method called without specifying '
+			. 'an architecture.';
+		$this -&gt; {kiwi} -&gt; error ($msg);
+		$this -&gt; {kiwi} -&gt; failed();
+		return undef;
+	}
+	if (! grep /^$arch/, @supportedArch) {
+		my $msg = 'Improper architecture setting, expecting on of: '
+			. &quot;@supportedArch&quot;;
+		$this -&gt; {kiwi} -&gt; error ($msg);
+		$this -&gt; {kiwi} -&gt; failed();
+		return undef;
+	}
+	$this -&gt; {imageArch} = $arch;
+	return 1;
+}
+
+#==========================================
 # setImagetargetDir
 #------------------------------------------
 sub setImagetargetDir {
@@ -482,6 +660,34 @@ sub setPackageManager {
 }
 
 #==========================================
+# getPackagesToRemove
+#------------------------------------------
+sub setPackagesToRemove {
+	# ...
+	# Set the list of packages to remove
+	# ---
+	my $this     = shift;
+	my $packages = shift;
+	my $kiwi = $this-&gt;{kiwi};
+	if (! $packages) {
+		my $msg = 'setPackagesToRemove method called without specifying '
+		. 'packages';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	if (! ref $packages) {
+		my $msg = 'setPackagesToRemove method expecting ARRAY_REF as '
+			. 'first argument.';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	$this -&gt; {removePackages} = $packages;
+	return 1;
+}
+
+#==========================================
 # setReplacementRepo
 #------------------------------------------
 sub setReplacementRepo {
@@ -542,8 +748,29 @@ sub setRootTargetDir {
 	# ...
 	# Set the target directory for the unpacked root tree
 	# ---
-	my $this = shift;
-	$this -&gt; {rootTgtDir} = shift;
+	my $this    = shift;
+	my $rootTgt = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	if (! $rootTgt) {
+		my $msg = 'setRootTargetDir method called without specifying '
+			. 'a target directory';
+		$kiwi -&gt; error ($msg);
+		$kiwi -&gt; failed();
+		return undef;
+	}
+	if ($rootTgt !~ /^\//) {
+		my $workingDir = qxx ('pwd');
+		chomp $workingDir;
+		$rootTgt = $workingDir . '/' . $rootTgt;
+		my $msg = 'Specified relative path for target directory; target is '
+			. &quot;$rootTgt\n&quot;;
+		$kiwi -&gt; info ($msg);
+	}
+	if ($this -&gt; {setRecycleRoot}) {
+		$this -&gt; {recycleRootDir} = $rootTgt;
+		$this -&gt; {setRecycleRoot} = 0;
+	}
+	$this -&gt; {rootTgtDir} = $rootTgt;
 	return 1;
 }
 
diff --git a/modules/KIWILocator.pm b/modules/KIWILocator.pm
index 0d4083f..260733d 100644
--- a/modules/KIWILocator.pm
+++ b/modules/KIWILocator.pm
@@ -55,8 +55,9 @@ sub new {
 	#==========================================
 	# Store object data
 	#------------------------------------------
-	$this-&gt;{configName} = 'config.xml';
-	$this-&gt;{kiwi}       = $kiwi;
+	$this-&gt;{configName}  = 'config.xml';
+	$this-&gt;{defCacheDir} = '/var/cache/kiwi/image';
+	$this-&gt;{kiwi}        = $kiwi;
 	return $this;
 }
 
@@ -158,6 +159,17 @@ sub getControlFile {
 }
 
 #============================================
+# getDefaultCacheDir
+#--------------------------------------------
+sub getDefaultCacheDir {
+	# ...
+	# Return the path of the default cache directory Kiwi uses
+	# ---
+	my $this = shift;
+	return $this -&gt; {defCacheDir};
+}
+
+#============================================
 # getExecPath
 #--------------------------------------------
 sub getExecPath {
diff --git a/modules/KIWIRoot.pm b/modules/KIWIRoot.pm
index e898ea8..e2b6e5e 100644
--- a/modules/KIWIRoot.pm
+++ b/modules/KIWIRoot.pm
@@ -318,6 +318,7 @@ sub init {
 	my $root = $this-&gt;{root};
 	my $manager    = $this-&gt;{manager};
 	my $baseSystem = $this-&gt;{baseSystem};
+	my $FD;
 	#==================================
 	# Create /etc/ImageVersion file
 	#----------------------------------
@@ -325,12 +326,13 @@ sub init {
 	my $imageVersion = $xml -&gt; getImageVersion();
 	my $imageName    = $xml -&gt; getImageName();
 	qxx (&quot;mkdir -p $root/etc&quot;);
-	if ( ! open (FD,&quot;&gt;$imageVersionFile&quot;)) {
+	if ( ! open ($FD, &quot;&gt;$imageVersionFile&quot;)) {
 		$kiwi -&gt; error (&quot;Failed to create version file: $!&quot;);
 		$kiwi -&gt; failed ();
 		return undef;
 	}
-	print FD $imageName.&quot;-&quot;.$imageVersion; close FD;
+	print $FD $imageName.&quot;-&quot;.$imageVersion;
+	close $FD;
 	#==================================
 	# Copy helper scripts to new root
 	#----------------------------------
diff --git a/modules/KIWISchema.rnc b/modules/KIWISchema.rnc
index 56997b1..6c46370 100644
--- a/modules/KIWISchema.rnc
+++ b/modules/KIWISchema.rnc
@@ -1581,7 +1581,7 @@ div {
 	k.volume.freespace.attribute =
 		## free space to be added to this volume. The value is
 		## used as MB by default but you can add &quot;M&quot; and/or &quot;G&quot; as
-		## prefix
+		## postfix
 		attribute freespace { volume-size-type }
 	k.volume.name.attribute =
 		## volume name. The name specifies a path which has to
@@ -1591,7 +1591,7 @@ div {
 		## absolute size of the volume. If the size value
 		## is too small to store all data it will be ignored.
 		## The value is used as MB by default but you can
-		## add &quot;M&quot; and/or &quot;G&quot; as prefix
+		## add &quot;M&quot; and/or &quot;G&quot; as postfix
 		attribute size { volume-size-type }
 	k.volume.attlist =
 		k.volume.freespace.attribute? &amp;
@@ -1599,11 +1599,11 @@ div {
 		k.volume.size.attribute?
 	k.volume =
 		## Specify which parts of the filesystem should be
-		## on a extra volume.
+		## on an extra volume.
 		[
 		db:para [
-			&quot;Specify which parts of the filesystem should be onextra\x{a}&quot;
-			&quot;a extra volume.&quot;
+			&quot;Specify which parts of the filesystem should be on\x{a}&quot;
+			&quot;an extra volume.&quot;
 		]
 		]
 		element volume {
diff --git a/modules/KIWISchema.rng b/modules/KIWISchema.rng
index 89fe0bf..31434e4 100644
--- a/modules/KIWISchema.rng
+++ b/modules/KIWISchema.rng
@@ -2234,7 +2234,7 @@ into the master block. There is space for 32 characters.&lt;/a:documentation&gt;
       &lt;attribute name=&quot;freespace&quot;&gt;
         &lt;a:documentation&gt;free space to be added to this volume. The value is
 used as MB by default but you can add &quot;M&quot; and/or &quot;G&quot; as
-prefix&lt;/a:documentation&gt;
+postfix&lt;/a:documentation&gt;
         &lt;ref name=&quot;volume-size-type&quot;/&gt;
       &lt;/attribute&gt;
     &lt;/define&gt;
@@ -2249,7 +2249,7 @@ exist inside the root directory.&lt;/a:documentation&gt;
         &lt;a:documentation&gt;absolute size of the volume. If the size value
 is too small to store all data it will be ignored.
 The value is used as MB by default but you can
-add &quot;M&quot; and/or &quot;G&quot; as prefix&lt;/a:documentation&gt;
+add &quot;M&quot; and/or &quot;G&quot; as postfix&lt;/a:documentation&gt;
         &lt;ref name=&quot;volume-size-type&quot;/&gt;
       &lt;/attribute&gt;
     &lt;/define&gt;
@@ -2267,9 +2267,9 @@ add &quot;M&quot; and/or &quot;G&quot; as prefix&lt;/a:documentation&gt;
     &lt;define name=&quot;k.volume&quot;&gt;
       &lt;element name=&quot;volume&quot;&gt;
         &lt;a:documentation&gt;Specify which parts of the filesystem should be
-on a extra volume.&lt;/a:documentation&gt;
-        &lt;db:para&gt;Specify which parts of the filesystem should be onextra
-a extra volume.&lt;/db:para&gt;
+on an extra volume.&lt;/a:documentation&gt;
+        &lt;db:para&gt;Specify which parts of the filesystem should be on
+an extra volume.&lt;/db:para&gt;
         &lt;ref name=&quot;k.volume.attlist&quot;/&gt;
         &lt;empty/&gt;
       &lt;/element&gt;
diff --git a/tests/unit/lib/Common/ktLog.pm b/tests/unit/lib/Common/ktLog.pm
index 29b5c11..8d409a4 100644
--- a/tests/unit/lib/Common/ktLog.pm
+++ b/tests/unit/lib/Common/ktLog.pm
@@ -35,6 +35,16 @@ use strict;
 use warnings;
 
 #==========================================
+# Destructor
+#------------------------------------------
+sub DESTROY {
+	# ...
+	# Clean up
+	# ---
+	unlink '/tmp/kiwiTestLog.log';
+}
+
+#==========================================
 # Constructor
 #------------------------------------------
 sub new {
@@ -61,6 +71,10 @@ sub new {
 	$this -&gt; {failed}    = 0;
 	$this -&gt; {msgType}   = 'none';
 	$this -&gt; {skipped}   = 0;
+	#==========================================
+	# A &quot;fake&quot; log file
+	#------------------------------------------
+	$this -&gt; {rootLog} = '/tmp/kiwiTestLog.log';
 	return $this;
 }
 
@@ -176,42 +190,6 @@ sub getLogInfoMessage {
 }
 
 #==========================================
-# getWarningMessage
-#------------------------------------------
-sub getWarningMessage {
-	# ...
-	# Retrieve the warning message.
-	# In general the getMessage method should be used. However, under certain
-	# test conditions it is unavoidable to have multiple messages in the log
-	# object. For these rare occasions the log allows access to the specific
-	# message types directly. The message type is reset, the final call in a
-	# test should always be to getMessage() to assure no unexpected messages
-	# are present.
-	# ---
-	my $this = shift;
-	my $msg = $this -&gt; {warnMsg};
-	$this -&gt; {warnMsg} = '';
-	return $msg;
-}
-
-#==========================================
-# getWarningState
-#------------------------------------------
-sub getWarningState {
-	# ...
-	# Retrieve the state of the skipped flag.
-	# Generally the getState method should be used. However, under certain
-	# circumstances the code issues a set of messages together. The individual
-	# get*State methods allow to retrieve the expected state and clear the
-	# flag for this state. THe final call in any test should always be to
-	# getState to assure there are no unexpected messages.
-	my $this = shift;
-	my $val = $this -&gt; {skipped} ? 'skipped' : 0;
-	$this -&gt; {skipped} = 0;
-	return $val;
-}
-
-#==========================================
 # getMessage
 #------------------------------------------
 sub getMessage {
@@ -233,6 +211,10 @@ sub getMessage {
 		$msg = $this -&gt; {logInfoMsg};
 		$msgCnt += 1;
 	}
+	if ( $this -&gt; {noteMsg} ) {
+		$msg = $this -&gt; {noteMsg};
+		$msgCnt += 1;
+	}
 	if ( $this -&gt; {warnMsg} ) {
 		$msg = $this -&gt; {warnMsg};
 		$msgCnt += 1;
@@ -259,6 +241,17 @@ sub getMessageType {
 }
 
 #==========================================
+# getRootLog
+#------------------------------------------
+sub getRootLog {
+	# ...
+	# Return test logfile location
+	# ---
+	my $this = shift;
+	return $this -&gt; {rootLog};
+}
+
+#==========================================
 # getState
 #------------------------------------------
 sub getState {
@@ -292,6 +285,42 @@ sub getState {
 }
 
 #==========================================
+# getWarningMessage
+#------------------------------------------
+sub getWarningMessage {
+	# ...
+	# Retrieve the warning message.
+	# In general the getMessage method should be used. However, under certain
+	# test conditions it is unavoidable to have multiple messages in the log
+	# object. For these rare occasions the log allows access to the specific
+	# message types directly. The message type is reset, the final call in a
+	# test should always be to getMessage() to assure no unexpected messages
+	# are present.
+	# ---
+	my $this = shift;
+	my $msg = $this -&gt; {warnMsg};
+	$this -&gt; {warnMsg} = '';
+	return $msg;
+}
+
+#==========================================
+# getWarningState
+#------------------------------------------
+sub getWarningState {
+	# ...
+	# Retrieve the state of the skipped flag.
+	# Generally the getState method should be used. However, under certain
+	# circumstances the code issues a set of messages together. The individual
+	# get*State methods allow to retrieve the expected state and clear the
+	# flag for this state. THe final call in any test should always be to
+	# getState to assure there are no unexpected messages.
+	my $this = shift;
+	my $val = $this -&gt; {skipped} ? 'skipped' : 0;
+	$this -&gt; {skipped} = 0;
+	return $val;
+}
+
+#==========================================
 # info
 #------------------------------------------
 sub info {
@@ -322,6 +351,32 @@ sub loginfo {
 }
 
 #==========================================
+# note
+#------------------------------------------
+sub note {
+	# ...
+	# Set note message
+	# ---
+	my $this = shift;
+	$this -&gt; {noteMsg} = shift;
+	$this -&gt; {msgType} = 'note';
+	return;
+}
+
+#==========================================
+# setRootLog
+#------------------------------------------
+sub setRootLog {
+	# ...
+	# Create a test log file
+	# ---
+	my $this = shift;
+	my $log = $this -&gt; {rootLog};
+	system &quot;touch $log&quot;;
+	return;
+}
+
+#==========================================
 # skipped
 #------------------------------------------
 sub skipped {
diff --git a/tests/unit/lib/Common/ktTestCase.pm b/tests/unit/lib/Common/ktTestCase.pm
index 97dc2b8..994dadb 100644
--- a/tests/unit/lib/Common/ktTestCase.pm
+++ b/tests/unit/lib/Common/ktTestCase.pm
@@ -53,11 +53,25 @@ sub assert_array_equal {
 		if ( ! grep /^$item$/x, @cmp_array ) {
 			my $msg = 'Did not get the expected list of names. '
 			.'Mismatch content.';
-			$self-&gt;assert(0, $msg);
+			$this -&gt; assert(0, $msg);
 		}
 	}
+	return;
+}
 
-return;
+#==========================================
+# assert_file_exists
+#------------------------------------------
+sub assert_file_exists {
+	# ...
+	# Test for file existence
+	# ---
+	my $this = shift;
+	my $fl   = shift;
+	if (! -f $fl) {
+		$this -&gt; assert(0, &quot;File $fl not found.&quot;);
+	}
+	return;
 }
 
 #==========================================
diff --git a/tests/unit/lib/Test/kiwiCommandLine.pm b/tests/unit/lib/Test/kiwiCommandLine.pm
index 50a8173..8141d90 100644
--- a/tests/unit/lib/Test/kiwiCommandLine.pm
+++ b/tests/unit/lib/Test/kiwiCommandLine.pm
@@ -17,6 +17,9 @@ package Test::kiwiCommandLine;
 use strict;
 use warnings;
 
+use Cwd;
+use FindBin;
+
 use Common::ktLog;
 use Common::ktTestCase;
 use base qw /Common::ktTestCase/;
@@ -58,6 +61,156 @@ sub test_ctor {
 }
 
 #==========================================
+# test_cmdAddPackages_improperArg
+#------------------------------------------
+sub test_cmdAddPackages_improperArg {
+	# ...
+	# Test the AdditionalPackages storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide improper argument
+	my @packages = ('foo');
+	my $res = $cmd -&gt; setAdditionalPackages(@packages);
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setAdditionalPackages method expecting ARRAY_REF as '
+		. 'first argument.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdAddPackages_noArg
+#------------------------------------------
+sub test_cmdAddPackages_noArg {
+	# ...
+	# Test the AdditionalPackages storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide no argument
+	my $res = $cmd -&gt; setAdditionalPackages();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setAdditionalPackages method called without '
+		. 'specifying packages';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdAddPackages_valid
+#------------------------------------------
+sub test_cmdAddPackages_valid {
+	# ...
+	# Test the AdditionalPackages storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Make sure there is no dafault
+	my $addlPckgs = $cmd -&gt; getPackagesToRemove();
+	$this -&gt; assert_null($addlPckgs);
+	# Expected use case
+	my @packages = ('foo', 'bar');
+	my $res = $cmd -&gt; setAdditionalPackages(\@packages);
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get our data back
+	$addlPckgs = $cmd -&gt; getAdditionalPackages();
+	$this -&gt; assert_array_equal(\@packages, $addlPckgs);
+}
+
+#==========================================
+# test_cmdAddPatterns_improperArg
+#------------------------------------------
+sub test_cmdAddPatterns_improperArg {
+	# ...
+	# Test the AdditionalPatterns storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide improper argument
+	my @patterns = ('foo');
+	my $res = $cmd -&gt; setAdditionalPatterns(@patterns);
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setAdditionalPatterns method expecting ARRAY_REF as '
+		. 'first argument.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdAddPatterns_noArg
+#------------------------------------------
+sub test_cmdAddPatterns_noArg {
+	# ...
+	# Test the AdditionalPatterns storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide no argument
+	my $res = $cmd -&gt; setAdditionalPatterns();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setAdditionalPatterns method called without '
+		. 'specifying packages';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdAddPatterns_valid
+#------------------------------------------
+sub test_cmdAddPatterns_valid {
+	# ...
+	# Test the AdditionalPatterns storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Make sure there is no dafault
+	my $addlPatterns = $cmd -&gt; getPackagesToRemove();
+	$this -&gt; assert_null($addlPatterns);
+	# Expected use case
+	my @patterns = ('foo', 'bar');
+	my $res = $cmd -&gt; setAdditionalPatterns(\@patterns);
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get our data back
+	$addlPatterns = $cmd -&gt; getAdditionalPatterns();
+	$this -&gt; assert_array_equal(\@patterns, $addlPatterns);
+}
+
+#==========================================
 # test_cmdAddRepos_improperAlias
 #------------------------------------------
 sub test_cmdAddRepos_improperAlias {
@@ -414,6 +567,108 @@ sub test_cmdBuildTypeUsage {
 }
 
 #==========================================
+# test_cmdCacheDirUsage_relPath
+#------------------------------------------
+sub test_cmdCacheDirUsage_relPath {
+	# ...
+	#Test the storage and verification of the cache directory data
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Specify relative path
+	my $res = $cmd -&gt; setCacheDir('tmp');
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'Specified relative path as cache location; moving '
+		. &quot;cache to /var/cache/kiwi/image/tmp\n&quot;;
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('info', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get the proper value back
+	my $dir = $cmd -&gt; getCacheDir();
+	$this -&gt; assert_str_equals('/var/cache/kiwi/image/tmp', $dir);
+}
+
+#==========================================
+# test_cmdCacheDirUsage_noArg
+#------------------------------------------
+sub test_cmdCacheDirUsage_noArg {
+	# ...
+	# Test the storage and verification of the cache directory data
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# No argument specified
+	my $res = $cmd -&gt; setCacheDir();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setCacheDir method called without specifying a '
+		. 'cache directory.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdCacheDirUsage_valid
+#------------------------------------------
+sub test_cmdCacheDirUsage_valid {
+	# ...
+	# Test the storage and verification of the cache directory data
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Expecting success
+	my $res = $cmd -&gt; setCacheDir('/tmp');
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get our data back
+	my $dir = $cmd -&gt; getCacheDir();
+	$this -&gt; assert_str_equals('/tmp', $dir);
+}
+
+#==========================================
+# test_cmdCacheDirUsage_noDirWrite
+#------------------------------------------
+sub test_cmdCacheDirUsage_noDirWrite {
+	# ...
+	# Test the storage and verification of the cache directory data
+	# ---
+	if ($&lt; == 0) {
+		print &quot;\t\tInfo: user root, skipping &quot;;
+		print &quot;test_cmdCacheDirUsage_noDirRead\n&quot;;
+		return;
+	}
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Directory has no read access
+	# If the test is run a root the test is skipped
+	my $res = $cmd -&gt; setCacheDir('/root');
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'No write access to specified cache directory '
+		. '&quot;/root&quot;.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
 # test_cmdConfDirUsage_noArg
 #------------------------------------------
 sub test_cmdConfDirUsage_noArg {
@@ -565,6 +820,79 @@ sub test_cmdIgnoreRepoUsage_conflict {
 }
 
 #==========================================
+# test_cmdImageArchUsage_invalidArg
+#------------------------------------------
+sub test_cmdImageArchUsage_invalidArg {
+	# ...
+	# Test the storage of the logfile path
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test improper call no argument
+	my $res = $cmd -&gt; setImageArchitecture('ia64');
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'Improper architecture setting, expecting on of: '
+		. 'i586 ppc ppc64 s390 s390x x86_64';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdImageArchUsage_noArg
+#------------------------------------------
+sub test_cmdImageArchUsage_noArg {
+	# ...
+	# Test the storage of the logfile path
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test that the command line object has no default
+	my $defArch = $cmd -&gt; getImageArchitecture();
+	$this -&gt; assert_null($defArch);
+	# Test improper call no argument
+	my $res = $cmd -&gt; setImageArchitecture();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setImageArchitecture method called without specifying '
+		. 'an architecture.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdImageArchUsage_valid
+#------------------------------------------
+sub test_cmdImageArchUsage_valid {
+	# ...
+	# Test the storage of the logfile path
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test improper call no argument
+	my $res = $cmd -&gt; setImageArchitecture('s390x');
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get our value back
+	my $arch = $cmd -&gt; getImageArchitecture();
+	$this -&gt; assert_str_equals('s390x', $arch);
+}
+
+#==========================================
 # test_cmdLogFileUsage_noArg
 #------------------------------------------
 sub test_cmdLogFileUsage_noArg {
@@ -714,6 +1042,81 @@ sub test_cmdPackageMgrUsage_valid {
 }
 
 #==========================================
+# test_cmdPckgsRemove_improperArg
+#------------------------------------------
+sub test_cmdPckgsRemove_improperArg {
+	# ...
+	# Test the PackagesToRemove storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide improper argument
+	my @packages = ('foo');
+	my $res = $cmd -&gt; setPackagesToRemove(@packages);
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setPackagesToRemove method expecting ARRAY_REF as '
+		. 'first argument.';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdPckgsRemove_noArg
+#------------------------------------------
+sub test_cmdPckgsRemove_noArg {
+	# ...
+	# Test the PackagesToRemove storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Provide no argument
+	my $res = $cmd -&gt; setPackagesToRemove();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setPackagesToRemove method called without '
+		. 'specifying packages';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res);
+}
+
+#==========================================
+# test_cmdPckgsRemove_valid
+#------------------------------------------
+sub test_cmdPckgsRemove_valid {
+	# ...
+	# Test the PackagesToRemove storage
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Make sure there is no dafault
+	my $rmPckgs = $cmd -&gt; getPackagesToRemove();
+	$this -&gt; assert_null($rmPckgs);
+	# Expected use case
+	my @packages = ('foo', 'bar');
+	my $res = $cmd -&gt; setPackagesToRemove(\@packages);
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Make sure we get our data back
+	$rmPckgs = $cmd -&gt; getPackagesToRemove();
+	$this -&gt; assert_array_equal(\@packages, $rmPckgs);
+}
+
+#==========================================
 # test_cmdProfileUsage_invalid
 #------------------------------------------
 sub test_cmdProfileUsage_invalid {
@@ -791,6 +1194,48 @@ sub test_cmdProfileUsage_valid {
 }
 
 #==========================================
+# test_cmdRecycleRoot_delayedSet
+#------------------------------------------
+sub test_cmdRecycleRoot_delayedSet {
+	# ...
+	# Test the storage for root directory recycling
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test the command lien object has no default
+	my $recycle = $cmd -&gt; getRecycleRootDir();
+	$this -&gt; assert_null($recycle);
+	# Enable root recycle, make sure we have not data as the source is not
+	# set yet
+	$cmd -&gt; enableRootRecycle();
+	$recycle = $cmd -&gt; getRecycleRootDir();
+	$this -&gt; assert_null($recycle);
+	# Set the root target, verify the recycle root get set
+	$cmd -&gt; setRootTargetDir('/tmp');
+	$recycle = $cmd -&gt; getRecycleRootDir();
+	$this -&gt; assert_str_equals('/tmp', $recycle);
+}
+
+#==========================================
+# test_cmdRecycleRoot_delayedSet
+#------------------------------------------
+sub test_cmdRecycleRoot_immediateSet {
+	# ...
+	# Test the storage for root directory recycling
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+
+	# Enable root recycle should have immediate effect
+	$cmd -&gt; setRootTargetDir('/tmp');
+	$cmd -&gt; enableRootRecycle();
+	my $recycle = $cmd -&gt; getRecycleRootDir();
+	$this -&gt; assert_str_equals('/tmp', $recycle);
+}
+
+#==========================================
 # test_cmdReplaceRepo_conflict
 #------------------------------------------
 sub test_cmdReplaceRepo_conflict {
@@ -897,7 +1342,7 @@ sub test_cmdReplaceRepo_unsupRepoType {
 	my $this = shift;
 	my $kiwi = $this -&gt; {kiwi};
 	my $cmd = $this -&gt; __getCmdObj();
-	# Test improper call no argument
+	# Test improper call unsuported repository type
 	my $res = $cmd -&gt; setReplacementRepo('os11.3', 'alias', 1, 'foo');
 	my $msg = $kiwi -&gt; getMessage();
 	my $expectedMsg = 'Specified repository type foo not supported.';
@@ -919,7 +1364,7 @@ sub test_cmdReplaceRepo_valid {
 	my $this = shift;
 	my $kiwi = $this -&gt; {kiwi};
 	my $cmd = $this -&gt; __getCmdObj();
-	# Test improper call no argument
+	# Test expected use case
 	my $res = $cmd -&gt; setReplacementRepo('os11.3', 'alias', 1, 'yast2');
 	my $msg = $kiwi -&gt; getMessage();
 	$this -&gt; assert_str_equals('No messages set', $msg);
@@ -937,6 +1382,83 @@ sub test_cmdReplaceRepo_valid {
 }
 
 #==========================================
+# test_cmdRootTargetDir_noArgs
+#------------------------------------------
+sub test_cmdRootTargetDir_noArgs {
+	# ...
+	# Test the storage of the root target directory information
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test that commandline object has no default setting
+	my $rootTgt = $cmd -&gt; getRootTargetDir();
+	$this -&gt; assert_null($rootTgt);
+	# Test improper call no argument
+	my $res = $cmd -&gt; setRootTargetDir();
+	my $msg = $kiwi -&gt; getMessage();
+	my $expectedMsg = 'setRootTargetDir method called without specifying a '
+		. 'target directory';
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('error', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('failed', $state);
+	$this -&gt; assert_null($res); 
+}
+
+#==========================================
+# test_cmdRootTargetDir_absPath
+#------------------------------------------
+sub test_cmdRootTargetDir_absPath {
+	# ...
+	# Test the storage of the root target directory information
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test expected use case with absolute path
+	my $res = $cmd -&gt; setRootTargetDir('/tmp');
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Check we get the expected result
+	my $rootTgt = $cmd -&gt; getRootTargetDir();
+	$this -&gt; assert_str_equals('/tmp', $rootTgt);
+}
+
+#==========================================
+# test_cmdRootTargetDir_noArgs
+#------------------------------------------
+sub test_cmdRootTargetDir_relPath {
+	# ...
+	# Test the storage of the root target directory information
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $cmd = $this -&gt; __getCmdObj();
+	# Test expected use case with absolute path
+	my $res = $cmd -&gt; setRootTargetDir('unpacked');
+	my $tgtPath = Cwd::realpath($FindBin::Bin . '/../../unpacked');
+	my $expectedMsg = 'Specified relative path for target directory; target '
+		. &quot;is $tgtPath\n&quot;;
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals($expectedMsg, $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('info', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	$this -&gt; assert_not_null($res);
+	# Check we get the expected result
+	my $rootTgt = $cmd -&gt; getRootTargetDir();
+	$this -&gt; assert_str_equals($tgtPath, $rootTgt);
+}
+
+#==========================================
 # Private helper methods
 #------------------------------------------
 #==========================================
diff --git a/tests/unit/lib/Test/kiwiLocator.pm b/tests/unit/lib/Test/kiwiLocator.pm
index 03ad28e..858ab9d 100644
--- a/tests/unit/lib/Test/kiwiLocator.pm
+++ b/tests/unit/lib/Test/kiwiLocator.pm
@@ -182,6 +182,27 @@ sub test_getControlFileNoErrorKiwiExt {
 }
 
 #==========================================
+# test_getDefCacheDir
+#------------------------------------------
+sub test_getDefCacheDir {
+	# ...
+	# Test that we get the expected location for the default cache directory
+	# ---
+	my $this = shift;
+	my $kiwi = $this -&gt; {kiwi};
+	my $locator = $this -&gt; __getLocator();
+	my $cacheDir = $locator -&gt; getDefaultCacheDir();
+	my $msg = $kiwi -&gt; getMessage();
+	$this -&gt; assert_str_equals('No messages set', $msg);
+	my $msgT = $kiwi -&gt; getMessageType();
+	$this -&gt; assert_str_equals('none', $msgT);
+	my $state = $kiwi -&gt; getState();
+	$this -&gt; assert_str_equals('No state set', $state);
+	# Make sure directory has expected path
+	$this -&gt; assert_str_equals($cacheDir, '/var/cache/kiwi/image');
+}
+
+#==========================================
 # test_getExecPathNoExec
 #------------------------------------------
 sub test_getExecPathNoExec {


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003400.html">[Kiwi-devel] style clean up, eliminate a bare word
</A></li>
	<LI>Next message: <A HREF="003403.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. c9c797b47cb4f785174dec004853d21d511fd090
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3402">[ date ]</a>
              <a href="thread.html#3402">[ thread ]</a>
              <a href="subject.html#3402">[ subject ]</a>
              <a href="author.html#3402">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
