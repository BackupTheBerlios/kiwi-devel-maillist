<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. f262ff3e74f2e574bd403d8a551353b520cb5174
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20f262ff3e74f2e574bd403d8a551353b520cb5174&In-Reply-To=%3C200908130910.n7D9A4Rf030356%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001409.html">
   <LINK REL="Next"  HREF="001411.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. f262ff3e74f2e574bd403d8a551353b520cb5174</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20f262ff3e74f2e574bd403d8a551353b520cb5174&In-Reply-To=%3C200908130910.n7D9A4Rf030356%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. f262ff3e74f2e574bd403d8a551353b520cb5174">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Thu Aug 13 11:10:04 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001409.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. e9aa9581fd6490c4934ce669f01c347fc03b7b95
</A></li>
        <LI>Next message: <A HREF="001411.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 63a3c26563a32517a0f4eed66c619ab72a79a973
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1410">[ date ]</a>
              <a href="thread.html#1410">[ thread ]</a>
              <a href="subject.html#1410">[ subject ]</a>
              <a href="author.html#1410">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  f262ff3e74f2e574bd403d8a551353b520cb5174 (commit)
      from  e9aa9581fd6490c4934ce669f01c347fc03b7b95 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f262ff3e74f2e574bd403d8a551353b520cb5174
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Thu Aug 13 11:09:56 2009 +0200

    - removed pigz from kiwi-tools, it's packaged and
      maintained by Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">agraf at suse.de</A>&gt; now

-----------------------------------------------------------------------

Summary of changes:
diff --git a/rpm/kiwi.changes b/rpm/kiwi.changes
index c74e63e..9ef3c4c 100644
--- a/rpm/kiwi.changes
+++ b/rpm/kiwi.changes
@@ -4,6 +4,8 @@ Tue Aug 11 18:33:29 CEST 2009 - <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>
 - v3.74
 - fixed VMFindSystem function in xenboot (bnc #530200)
 - make rpm-force content a boolean value
+- removed pigz from kiwi-tools, it's packaged and
+  maintained by Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">agraf at suse.de</A>&gt; now
 - run fsck and resize2fs only on first boot of a clic mount
 - don't wait for storage device if it's a loop
 - use resize2fs -M if possible ( &gt;= v1.41 )
diff --git a/tools/Makefile b/tools/Makefile
index 11644b8..670c029 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -1,7 +1,6 @@
 all:
 	${MAKE} -C startshell all
 	${MAKE} -C dcounter all
-	${MAKE} -C pigz all
 	${MAKE} -C driveready all
 	${MAKE} -C dbuslock -f Makefile.swig all
 	${MAKE} -C dbuslock BINDLIB=${bindlib} all
@@ -20,7 +19,6 @@ install:
 	#install -m 755 init/* ${INITVZ}
 	install -m 755 dcounter/dcounter ${TOOLSVZ}
 	install -m 755 startshell/startshell ${TOOLSVZ}
-	install -m 755 pigz/pigz ${TOOLSVZ}
 	install -m 755 driveready/driveready ${TOOLSVZ}
 	${MAKE} -C dbuslock DESTDIR=${buildroot} install_vendor
 	( \
@@ -39,7 +37,6 @@ clean:
 	${MAKE} -C dcounter clean
 	test -f burner/Makefile &amp;&amp; ${MAKE} -C burner clean || true
 	${MAKE} -C startshell clean
-	${MAKE} -C pigz clean
 	${MAKE} -C driveready clean
 	${MAKE} -C satplugin -f Makefile.swig clean
 	${MAKE} -C dbuslock -f Makefile.swig clean
diff --git a/tools/README b/tools/README
index 194c01c..c91b7a8 100644
--- a/tools/README
+++ b/tools/README
@@ -3,20 +3,19 @@
 # the kiwi image technology. If you need them in your image
 # just set the package kiwi-tools in your config.xml file
 # ----
-
 /usr/bin/startshell
    * small tool to run a shell on a specified console. Most often
      used in initrd images for providing shell access while init
      is not called
 
-/usr/bin/pigz
-   * small libz based tool which does compression on multiple
-     processors. It's compatible to gzip
-
-/usr/bin/createLiveCD
-   * wrapper script for kiwi to create the current SuSE Linux
-     live CD
-
 /usr/bin/driveready
    * small tool to check the sense code of a CD/DVD drive. The tool
      can be used to wait for the drive to be ready for mounting
+
+/usr/bin/imagewriter
+   * a Qt based frontend for dd, dumping images on a device
+     with a nice GUI. 
+
+/usr/bin/dcounter
+   * a small program to count bytes on a transfer so that you
+     can show a progress information about the transfer
diff --git a/tools/pigz/Makefile b/tools/pigz/Makefile
deleted file mode 100644
index 1ae1fd0..0000000
--- a/tools/pigz/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-CFLAGS=-Wall -O2
-
-all: pigz
-
-pigz: pigz.o yarn.o
-	cc -o pigz pigz.o yarn.o -lpthread -lz
-
-pigz.o: pigz.c yarn.h
-
-yarn.o: yarn.c yarn.h
-
-dev: pigz pigzt pigzn
-
-pigzt: pigzt.o yarnt.o
-	cc -o pigzt pigzt.o yarnt.o -lpthread -lz
-
-pigzt.o: pigz.c yarn.h
-	cc -Wall -O3 -DDEBUG -g -c -o pigzt.o pigz.c
-
-yarnt.o: yarn.c yarn.h
-	cc -Wall -O3 -DDEBUG -g -c -o yarnt.o yarn.c
-
-pigzn: pigzn.o
-	cc -o pigzn pigzn.o -lz
-
-pigzn.o: pigz.c
-	cc -Wall -O3 -DDEBUG -DNOTHREAD -g -c -o pigzn.o pigz.c
-
-clean:
-	rm -f *.o pigz pigzn pigzt
diff --git a/tools/pigz/README b/tools/pigz/README
deleted file mode 100644
index 8dfa0ef..0000000
--- a/tools/pigz/README
+++ /dev/null
@@ -1,48 +0,0 @@
-pigz 2.1.4 (9 Nov 2008) by Mark Adler
-
-pigz, which stands for Parallel Implementation of GZip, is a fully functional
-replacement for gzip that exploits multiple processors and multiple cores to
-the hilt when compressing data.
-
-pigz was written by Mark Adler, and uses the zlib and pthread libraries.
-
-This version of pigz is written to be portable across Unix-style operating
-systems that provide the zlib and pthread libraries.
-
-Type &quot;make&quot; in this directory to build the &quot;pigz&quot; executable.  You can then
-install the executable wherever you like in your path (e.g. /usr/local/bin/).
-Type &quot;pigz&quot; to see the command help and all of the command options.
-
-The latest version of pigz can be found at <A HREF="http://zlib.net/pigz/">http://zlib.net/pigz/</A> .  You need
-zlib version 1.2.3 or later to compile pigz.  You can find the latest version
-of zlib at <A HREF="http://zlib.net/">http://zlib.net/</A> .  You can look in pigz.c for the change history.
-
-Questions, comments, bug reports, fixes, etc. can be emailed to Mark at his
-address in the license below.
-
-The license from pigz.c is copied here:
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler
-  <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
-
-  Mark accepts donations for providing this software.  Donations are not
-  required or expected.  Any amount that you feel is appropriate would be
-  appreciated.  You can use this link:
-
-  <A HREF="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055">https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055</A>
diff --git a/tools/pigz/pigz.c b/tools/pigz/pigz.c
deleted file mode 100644
index 73acba8..0000000
--- a/tools/pigz/pigz.c
+++ /dev/null
@@ -1,3039 +0,0 @@
-/* pigz.c -- parallel implementation of gzip
- * Copyright (C) 2007, 2008 Mark Adler
- * Version 2.1.4  9 Nov 2008  Mark Adler
- */
-
-/*
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler
-  <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
-
-  Mark accepts donations for providing this software.  Donations are not
-  required or expected.  Any amount that you feel is appropriate would be
-  appreciated.  You can use this link:
-
-  <A HREF="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055">https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055</A>
-
- */
-
-/* Version history:
-   1.0    17 Jan 2007  First version, pipe only
-   1.1    28 Jan 2007  Avoid void * arithmetic (some compilers don't get that)
-                       Add note about requiring zlib 1.2.3
-                       Allow compression level 0 (no compression)
-                       Completely rewrite parallelism -- add a write thread
-                       Use deflateSetDictionary() to make use of history
-                       Tune argument defaults to best performance on four cores
-   1.2.1   1 Feb 2007  Add long command line options, add all gzip options
-                       Add debugging options
-   1.2.2  19 Feb 2007  Add list (--list) function
-                       Process file names on command line, write .gz output
-                       Write name and time in gzip header, set output file time
-                       Implement all command line options except --recursive
-                       Add --keep option to prevent deleting input files
-                       Add thread tracing information with -vv used
-                       Copy crc32_combine() from zlib (possible thread issue)
-   1.3    25 Feb 2007  Implement --recursive
-                       Expand help to show all options
-                       Show help if no arguments or output piping are provided
-                       Process options in GZIP environment variable
-                       Add progress indicator to write thread if --verbose
-   1.4     4 Mar 2007  Add --independent to facilitate damaged file recovery
-                       Reallocate jobs for new --blocksize or --processes
-                       Do not delete original if writing to stdout
-                       Allow --processes 1, which does no threading
-                       Add NOTHREAD define to compile without threads
-                       Incorporate license text from zlib in source code
-   1.5    25 Mar 2007  Reinitialize jobs for new compression level
-                       Copy attributes and owner from input file to output file
-                       Add decompression and testing
-                       Add -lt (or -ltv) to show all entries and proper lengths
-                       Add decompression, testing, listing of LZW (.Z) files
-                       Only generate and show trace log if DEBUG defined
-                       Take &quot;-&quot; argument to mean read file from stdin
-   1.6    30 Mar 2007  Add zlib stream compression (--zlib), and decompression
-   1.7    29 Apr 2007  Decompress first entry of a zip file (if deflated)
-                       Avoid empty deflate blocks at end of deflate stream
-                       Show zlib check value (Adler-32) when listing
-                       Don't complain when decompressing empty file
-                       Warn about trailing junk for gzip and zlib streams
-                       Make listings consistent, ignore gzip extra flags
-                       Add zip stream compression (--zip)
-   1.8    13 May 2007  Document --zip option in help output
-   2.0    19 Oct 2008  Complete rewrite of thread usage and synchronization
-                       Use polling threads and a pool of memory buffers
-                       Remove direct pthread library use, hide in yarn.c
-   2.0.1  20 Oct 2008  Check version of zlib at compile time, need &gt;= 1.2.3
-   2.1    24 Oct 2008  Decompress with read, write, inflate, and check threads
-                       Remove spurious use of ctime_r(), ctime() more portable
-                       Change application of job-&gt;calc lock to be a semaphore
-                       Detect size of off_t at run time to select %lu vs. %llu
-                       #define large file support macro even if not __linux__
-                       Remove _LARGEFILE64_SOURCE, _FILE_OFFSET_BITS is enough
-                       Detect file-too-large error and report, blame build
-                       Replace check combination routines with those from zlib
-   2.1.1  28 Oct 2008  Fix a leak for files with an integer number of blocks
-                       Update for yarn 1.1 (yarn_prefix and yarn_abort)
-   2.1.2  30 Oct 2008  Work around use of beta zlib in production systems
-   2.1.3   8 Nov 2008  Don't use zlib combination routines, put back in pigz
-   2.1.4   9 Nov 2008  Fix bug when decompressing very short files
- */
-
-#define VERSION &quot;pigz 2.1.4\n&quot;
-
-/* To-do:
-    - add --rsyncable (or -R) [use my own algorithm, set min/max block size]
-    - make source portable for Windows, VMS, etc. (see gzip source code)
-    - make build portable (currently good for Unixish)
- */
-
-/*
-   pigz compresses using threads to make use of multiple processors and cores.
-   The input is broken up into 128 KB chunks with each compressed in parallel.
-   The individual check value for each chunk is also calculated in parallel.
-   The compressed data is written in order to the output, and a combined check
-   value is calculated from the individual check values.
-
-   The compressed data format generated is in the gzip, zlib, or single-entry
-   zip format using the deflate compression method.  The compression produces
-   partial raw deflate streams which are concatenated by a single write thread
-   and wrapped with the appropriate header and trailer, where the trailer
-   contains the combined check value.
-
-   Each partial raw deflate stream is terminated by an empty stored block
-   (using the Z_SYNC_FLUSH option of zlib), in order to end that partial bit
-   stream at a byte boundary.  That allows the partial streams to be
-   concatenated simply as sequences of bytes.  This adds a very small four to
-   five byte overhead to the output for each input chunk.
-
-   The default input block size is 128K, but can be changed with the -b option.
-   The number of compress threads is set by default to 8, which can be changed
-   using the -p option.  Specifying -p 1 avoids the use of threads entirely.
-
-   The input blocks, while compressed independently, have the last 32K of the
-   previous block loaded as a preset dictionary to preserve the compression
-   effectiveness of deflating in a single thread.  This can be turned off using
-   the --independent or -i option, so that the blocks can be decompressed
-   independently for partial error recovery or for random access.
-
-   Decompression can't be parallelized, at least not without specially prepared
-   deflate streams for that purpose.  As a result, pigz uses a single thread
-   (the main thread) for decompression, but will create three other threads for
-   reading, writing, and check calculation, which can speed up decompression
-   under some circumstances.  Parallel decompression can be turned off by
-   specifying one process (-dp 1 or -tp 1).
-
-   pigz requires zlib 1.2.1 or later to allow setting the dictionary when doing
-   raw deflate.  Since zlib 1.2.3 corrects security vulnerabilities in zlib
-   version 1.2.1 and 1.2.2, conditionals check for zlib 1.2.3 or later during
-   the compilation of pigz.c.
-
-   pigz uses the POSIX pthread library for thread control and communication,
-   through the yarn.h interface to yarn.c.  yarn.c can be replaced with
-   equivalent implementations using other thread libraries.  pigz can be
-   compiled with NOTHREAD #defined to not use threads at all (in which case
-   pigz will not be able to live up to the &quot;parallel&quot; in its name).
- */
-
-/*
-   Details of parallel compression implementation:
-
-   When doing parallel compression, pigz uses the main thread to read the input
-   in 'size' sized chunks (see -b), and puts those in a compression job list,
-   each with a sequence number to keep track of the ordering.  If it is not the
-   first chunk, then that job also points to the previous input buffer, from
-   which the last 32K will be used as a dictionary (unless -i is specified).
-   This sets a lower limit of 32K on 'size'.
-
-   pigz launches up to 'procs' compression threads (see -p).  Each compression
-   thread continues to look for jobs in the compression list and perform those
-   jobs until instructed to return.  When a job is pulled, the dictionary, if
-   provided, will be loaded into the deflate engine and then that input buffer
-   is dropped for reuse.  Then the input data is compressed into an output
-   buffer sized to assure that it can contain maximally expanded deflate data.
-   The job is then put into the write job list, sorted by the sequence number.
-   The compress thread however continues to calculate the check value on the
-   input data, either a CRC-32 or Adler-32, possibly in parallel with the write
-   thread writing the output data.  Once that's done, the compress thread drops
-   the input buffer and also releases the lock on the check value so that the
-   write thread can combine it with the previous check values.  The compress
-   thread has then completed that job, and goes to look for another.
-
-   All of the compress threads are left running and waiting even after the last
-   chunk is processed, so that they can support the next input to be compressed
-   (more than one input file on the command line).  Once pigz is done, it will
-   call all the compress threads home (that'll do pig, that'll do).
-
-   Before starting to read the input, the main thread launches the write thread
-   so that it is ready pick up jobs immediately.  The compress thread puts the
-   write jobs in the list in sequence sorted order, so that the first job in
-   the list is always has the lowest sequence number.  The write thread waits
-   for the next write job in sequence, and then gets that job.  The job still
-   holds its input buffer, from which the write thread gets the input buffer
-   length for use in check value combination.  Then the write thread drops that
-   input buffer to allow its reuse.  Holding on to the input buffer until the
-   write thread starts also has the benefit that the read and compress threads
-   can't get way ahead of the write thread and build up a large backlog of
-   unwritten compressed data.  The write thread will write the compressed data,
-   drop the output buffer, and then wait for the check value to be unlocked
-   by the compress thread.  Then the write thread combines the check value for
-   this chunk with the total check value for eventual use in the trailer.  If
-   this is not the last chunk, the write thread then goes back to look for the
-   next output chunk in sequence.  After the last chunk, the write thread
-   returns and joins the main thread.  Unlike the compress threads, a new write
-   thread is launched for each input stream.  The write thread writes the
-   appropriate header and trailer around the compressed data.
-
-   The input and output buffers are reused through their collection in pools.
-   Each buffer has a use count, which when decremented to zero returns the
-   buffer to the respective pool.  Each input buffer has up to three parallel
-   uses: as the input for compression, as the data for the check value
-   calculation, and as a dictionary for compression.  Each output buffer has
-   only one use, which is as the output of compression followed serially as
-   data to be written.  The input pool is limited in the number of buffers, so
-   that reading does not get way ahead of compression and eat up memory with
-   more input than can be used.  The limit is approximately two times the
-   number of compression threads.  In the case that reading is fast as compared
-   to compression, that number allows a second set of buffers to be read while
-   the first set of compressions are being performed.  The number of output
-   buffers is not directly limited, but is indirectly limited by the release of
-   input buffers to the same number.
- */
-
-/* use large file functions if available */
-#define _FILE_OFFSET_BITS 64
-
-/* included headers and what is expected from each */
-#include &lt;stdio.h&gt;      /* fflush(), fprintf(), fputs(), getchar(), putc(), */
-                        /* puts(), printf(), vasprintf(), stderr, EOF, NULL,
-                           SEEK_END, size_t, off_t */
-#include &lt;stdlib.h&gt;     /* exit(), malloc(), free(), realloc(), atol(), */
-                        /* atoi(), getenv() */
-#include &lt;stdarg.h&gt;     /* va_start(), va_end(), va_list */
-#include &lt;string.h&gt;     /* memset(), memchr(), memcpy(), strcmp(), */
-                        /* strcpy(), strncpy(), strlen(), strcat() */
-#include &lt;errno.h&gt;      /* errno, EEXIST */
-#include &lt;assert.h&gt;     /* assert() */
-#include &lt;time.h&gt;       /* ctime(), time(), time_t, mktime() */
-#include &lt;signal.h&gt;     /* signal(), SIGINT */
-#include &lt;sys/types.h&gt;  /* ssize_t */
-#include &lt;sys/stat.h&gt;   /* chmod(), stat(), fstat(), lstat(), struct stat, */
-                        /* S_IFDIR, S_IFLNK, S_IFMT, S_IFREG */
-#include &lt;sys/time.h&gt;   /* utimes(), gettimeofday(), struct timeval */
-#include &lt;unistd.h&gt;     /* unlink(), _exit(), read(), write(), close(), */
-                        /* lseek(), isatty(), chown() */
-#include &lt;fcntl.h&gt;      /* open(), O_CREAT, O_EXCL, O_RDONLY, O_TRUNC, */
-                        /* O_WRONLY */
-#include &lt;dirent.h&gt;     /* opendir(), readdir(), closedir(), DIR, */
-                        /* struct dirent */
-#include &lt;limits.h&gt;     /* PATH_MAX */
-
-#include &quot;zlib.h&quot;       /* deflateInit2(), deflateReset(), deflate(), */
-                        /* deflateEnd(), deflateSetDictionary(), crc32(),
-                           Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY,
-                           Z_DEFLATED, Z_NO_FLUSH, Z_NULL, Z_OK,
-                           Z_SYNC_FLUSH, z_stream */
-#if !defined(ZLIB_VERNUM) || ZLIB_VERNUM &lt; 0x1230
-#  error Need zlib version 1.2.3 or later
-#endif
-
-#ifndef NOTHREAD
-#  include &quot;yarn.h&quot;     /* thread, launch(), join(), join_all(), */
-                        /* lock, new_lock(), possess(), twist(), wait_for(),
-                           release(), peek_lock(), free_lock(), yarn_name */
-#endif
-
-/* for local functions and globals */
-#define local static
-
-/* prevent end-of-line conversions on MSDOSish operating systems */
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include &lt;io.h&gt;       /* setmode(), O_BINARY */
-#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
-#else
-#  define SET_BINARY_MODE(fd)
-#endif
-
-/* release an allocated pointer, if allocated, and mark as unallocated */
-#define RELEASE(ptr) \
-    do { \
-        if ((ptr) != NULL) { \
-            free(ptr); \
-            ptr = NULL; \
-        } \
-    } while (0)
-
-/* globals (modified by main thread only when it's the only thread) */
-local int ind;              /* input file descriptor */
-local int outd;             /* output file descriptor */
-local char in[PATH_MAX+1];  /* input file name (accommodate recursion) */
-local char *out = NULL;     /* output file name (allocated if not NULL) */
-local int verbosity;        /* 0 = quiet, 1 = normal, 2 = verbose, 3 = trace */
-local int headis;           /* 1 to store name, 2 to store date, 3 both */
-local int pipeout;          /* write output to stdout even if file */
-local int keep;             /* true to prevent deletion of input file */
-local int force;            /* true to overwrite, compress links */
-local int form;             /* gzip = 0, zlib = 1, zip = 2 or 3 */
-local int recurse;          /* true to dive down into directory structure */
-local char *sufx;           /* suffix to use (&quot;.gz&quot; or user supplied) */
-local char *name;           /* name for gzip header */
-local time_t mtime;         /* time stamp from input file for gzip header */
-local int list;             /* true to list files instead of compress */
-local int first = 1;        /* true if we need to print listing header */
-local int decode;           /* 0 to compress, 1 to decompress, 2 to test */
-local int level;            /* compression level */
-local int rsync;            /* true for rsync blocking */
-local int procs;            /* maximum number of compression threads (&gt;= 1) */
-local int dict;             /* true to initialize dictionary in each thread */
-local size_t size;          /* uncompressed input size per thread (&gt;= 32K) */
-
-/* saved gzip/zip header data for decompression, testing, and listing */
-local time_t stamp;                 /* time stamp from gzip header */
-local char *hname = NULL;           /* name from header (allocated) */
-local unsigned long zip_crc;        /* local header crc */
-local unsigned long zip_clen;       /* local header compressed length */
-local unsigned long zip_ulen;       /* local header uncompressed length */
-
-/* exit with error, delete output file if in the middle of writing it */
-local int bail(char *why, char *what)
-{
-    if (outd != -1 &amp;&amp; out != NULL)
-        unlink(out);
-    if (verbosity &gt; 0)
-        fprintf(stderr, &quot;pigz abort: %s%s\n&quot;, why, what);
-    exit(1);
-    return 0;
-}
-
-#ifdef DEBUG
-
-/* starting time of day for tracing */
-local struct timeval start;
-
-/* trace log */
-local struct log {
-    struct timeval when;    /* time of entry */
-    char *msg;              /* message */
-    struct log *next;       /* next entry */
-} *log_head, **log_tail = NULL;
-#ifndef NOTHREAD
-  local lock *log_lock = NULL;
-#endif
-
-/* maximum log entry length */
-#define MAXMSG 256
-
-/* set up log (call from main thread before other threads launched) */
-local void log_init(void)
-{
-    if (log_tail == NULL) {
-#ifndef NOTHREAD
-        log_lock = new_lock(0);
-#endif
-        log_head = NULL;
-        log_tail = &amp;log_head;
-    }
-}
-
-/* add entry to trace log */
-local void log_add(char *fmt, ...)
-{
-    struct timeval now;
-    struct log *me;
-    va_list ap;
-    char msg[MAXMSG];
-
-    gettimeofday(&amp;now, NULL);
-    me = malloc(sizeof(struct log));
-    if (me == NULL)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-    me-&gt;when = now;
-    va_start(ap, fmt);
-    vsnprintf(msg, MAXMSG, fmt, ap);
-    va_end(ap);
-    me-&gt;msg = malloc(strlen(msg) + 1);
-    if (me-&gt;msg == NULL) {
-        free(me);
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-    }
-    strcpy(me-&gt;msg, msg);
-    me-&gt;next = NULL;
-#ifndef NOTHREAD
-    assert(log_lock != NULL);
-    possess(log_lock);
-#endif
-    *log_tail = me;
-    log_tail = &amp;(me-&gt;next);
-#ifndef NOTHREAD
-    twist(log_lock, BY, +1);
-#endif
-}
-
-/* pull entry from trace log and print it, return false if empty */
-local int log_show(void)
-{
-    struct log *me;
-    struct timeval diff;
-
-    if (log_tail == NULL)
-        return 0;
-#ifndef NOTHREAD
-    possess(log_lock);
-#endif
-    me = log_head;
-    if (me == NULL) {
-#ifndef NOTHREAD
-        release(log_lock);
-#endif
-        return 0;
-    }
-    log_head = me-&gt;next;
-    if (me-&gt;next == NULL)
-        log_tail = &amp;log_head;
-#ifndef NOTHREAD
-    twist(log_lock, BY, -1);
-#endif
-    diff.tv_usec = me-&gt;when.tv_usec - start.tv_usec;
-    diff.tv_sec = me-&gt;when.tv_sec - start.tv_sec;
-    if (diff.tv_usec &lt; 0) {
-        diff.tv_usec += 1000000L;
-        diff.tv_sec--;
-    }
-    fprintf(stderr, &quot;trace %ld.%06ld %s\n&quot;,
-            (long)diff.tv_sec, (long)diff.tv_usec, me-&gt;msg);
-    fflush(stderr);
-    free(me-&gt;msg);
-    free(me);
-    return 1;
-}
-
-/* release log resources (need to do log_init() to use again) */
-local void log_free(void)
-{
-    struct log *me;
-
-    if (log_tail != NULL) {
-#ifndef NOTHREAD
-        possess(log_lock);
-#endif
-        while ((me = log_head) != NULL) {
-            log_head = me-&gt;next;
-            free(me-&gt;msg);
-            free(me);
-        }
-#ifndef NOTHREAD
-        twist(log_lock, TO, 0);
-        free_lock(log_lock);
-        log_lock = NULL;
-#endif
-        log_tail = NULL;
-    }
-}
-
-/* show entries until no more, free log */
-local void log_dump(void)
-{
-    if (log_tail == NULL)
-        return;
-    while (log_show())
-        ;
-    log_free();
-}
-
-/* debugging macro */
-#define Trace(x) \
-    do { \
-        if (verbosity &gt; 2) { \
-            log_add x; \
-        } \
-    } while (0)
-
-#else /* !DEBUG */
-
-#define log_dump()
-#define Trace(x)
-
-#endif
-
-/* read up to len bytes into buf, repeating read() calls as needed */
-local size_t readn(int desc, unsigned char *buf, size_t len)
-{
-    ssize_t ret;
-    size_t got;
-
-    got = 0;
-    while (len) {
-        ret = read(desc, buf, len);
-        if (ret &lt; 0)
-            bail(&quot;read error on &quot;, in);
-        if (ret == 0)
-            break;
-        buf += ret;
-        len -= ret;
-        got += ret;
-    }
-    return got;
-}
-
-/* write len bytes, repeating write() calls as needed */
-local void writen(int desc, unsigned char *buf, size_t len)
-{
-    ssize_t ret;
-
-    while (len) {
-        ret = write(desc, buf, len);
-        if (ret &lt; 1)
-            fprintf(stderr, &quot;write error code %d\n&quot;, errno);
-        if (ret &lt; 1)
-            bail(&quot;write error on &quot;, out);
-        buf += ret;
-        len -= ret;
-    }
-}
-
-/* sliding dictionary size for deflate */
-#define DICT 32768U
-
-/* largest power of 2 that fits in an unsigned int -- used to limit requests
-   to zlib functions that use unsigned int lengths */
-#define MAX ((((unsigned)0 - 1) &gt;&gt; 1) + 1)
-
-/* convert Unix time to MS-DOS date and time, assuming current timezone
-   (you got a better idea?) */
-local unsigned long time2dos(time_t t)
-{
-    struct tm *tm;
-    unsigned long dos;
-
-    if (t == 0)
-        t = time(NULL);
-    tm = localtime(&amp;t);
-    if (tm-&gt;tm_year &lt; 80 || tm-&gt;tm_year &gt; 207)
-        return 0;
-    dos = (tm-&gt;tm_year - 80) &lt;&lt; 25;
-    dos += (tm-&gt;tm_mon + 1) &lt;&lt; 21;
-    dos += tm-&gt;tm_mday &lt;&lt; 16;
-    dos += tm-&gt;tm_hour &lt;&lt; 11;
-    dos += tm-&gt;tm_min &lt;&lt; 5;
-    dos += (tm-&gt;tm_sec + 1) &gt;&gt; 1;   /* round to double-seconds */
-    return dos;
-}
-
-/* put a 4-byte integer into a byte array in LSB order or MSB order */
-#define PUT2L(a,b) (*(a)=(b)&amp;0xff,(a)[1]=(b)&gt;&gt;8)
-#define PUT4L(a,b) (PUT2L(a,(b)&amp;0xffff),PUT2L((a)+2,(b)&gt;&gt;16))
-#define PUT4M(a,b) (*(a)=(b)&gt;&gt;24,(a)[1]=(b)&gt;&gt;16,(a)[2]=(b)&gt;&gt;8,(a)[3]=(b))
-
-/* write a gzip, zlib, or zip header using the information in the globals */
-local unsigned long put_header(void)
-{
-    unsigned long len;
-    unsigned char head[30];
-
-    if (form &gt; 1) {                 /* zip */
-        /* write local header */
-        PUT4L(head, 0x04034b50UL);  /* local header signature */
-        PUT2L(head + 4, 20);        /* version needed to extract (2.0) */
-        PUT2L(head + 6, 8);         /* flags: data descriptor follows data */
-        PUT2L(head + 8, 8);         /* deflate */
-        PUT4L(head + 10, time2dos(mtime));
-        PUT4L(head + 14, 0);        /* crc (not here) */
-        PUT4L(head + 18, 0);        /* compressed length (not here) */
-        PUT4L(head + 22, 0);        /* uncompressed length (not here) */
-        PUT2L(head + 26, name == NULL ? 1 : strlen(name));  /* name length */
-        PUT2L(head + 28, 9);        /* length of extra field (see below) */
-        writen(outd, head, 30);     /* write local header */
-        len = 30;
-
-        /* write file name (use &quot;-&quot; for stdin) */
-        if (name == NULL)
-            writen(outd, (unsigned char *)&quot;-&quot;, 1);
-        else
-            writen(outd, (unsigned char *)name, strlen(name));
-        len += name == NULL ? 1 : strlen(name);
-
-        /* write extended timestamp extra field block (9 bytes) */
-        PUT2L(head, 0x5455);        /* extended timestamp signature */
-        PUT2L(head + 2, 5);         /* number of data bytes in this block */
-        head[4] = 1;                /* flag presence of mod time */
-        PUT4L(head + 5, mtime);     /* mod time */
-        writen(outd, head, 9);      /* write extra field block */
-        len += 9;
-    }
-    else if (form) {                /* zlib */
-        head[0] = 0x78;             /* deflate, 32K window */
-        head[1] = (level == 9 ? 3 : (level == 1 ? 0 :
-            (level &gt;= 6 || level == Z_DEFAULT_COMPRESSION ? 1 :  2))) &lt;&lt; 6;
-        head[1] += 31 - (((head[0] &lt;&lt; 8) + head[1]) % 31);
-        writen(outd, head, 2);
-        len = 2;
-    }
-    else {                          /* gzip */
-        head[0] = 31;
-        head[1] = 139;
-        head[2] = 8;                /* deflate */
-        head[3] = name != NULL ? 8 : 0;
-        PUT4L(head + 4, mtime);
-        head[8] = level == 9 ? 2 : (level == 1 ? 4 : 0);
-        head[9] = 3;                /* unix */
-        writen(outd, head, 10);
-        len = 10;
-        if (name != NULL)
-            writen(outd, (unsigned char *)name, strlen(name) + 1);
-        if (name != NULL)
-            len += strlen(name) + 1;
-    }
-    return len;
-}
-
-/* write a gzip, zlib, or zip trailer */
-local void put_trailer(unsigned long ulen, unsigned long clen,
-                       unsigned long check, unsigned long head)
-{
-    unsigned char tail[46];
-
-    if (form &gt; 1) {                 /* zip */
-        unsigned long cent;
-
-        /* write data descriptor (as promised in local header) */
-        PUT4L(tail, check);
-        PUT4L(tail + 4, clen);
-        PUT4L(tail + 8, ulen);
-        writen(outd, tail, 12);
-
-        /* write central file header */
-        PUT4L(tail, 0x02014b50UL);  /* central header signature */
-        tail[4] = 63;               /* obeyed version 6.3 of the zip spec */
-        tail[5] = 255;              /* ignore external attributes */
-        PUT2L(tail + 6, 20);        /* version needed to extract (2.0) */
-        PUT2L(tail + 8, 8);         /* data descriptor is present */
-        PUT2L(tail + 10, 8);        /* deflate */
-        PUT4L(tail + 12, time2dos(mtime));
-        PUT4L(tail + 16, check);    /* crc */
-        PUT4L(tail + 20, clen);     /* compressed length */
-        PUT4L(tail + 24, ulen);     /* uncompressed length */
-        PUT2L(tail + 28, name == NULL ? 1 : strlen(name));  /* name length */
-        PUT2L(tail + 30, 9);        /* length of extra field (see below) */
-        PUT2L(tail + 32, 0);        /* no file comment */
-        PUT2L(tail + 34, 0);        /* disk number 0 */
-        PUT2L(tail + 36, 0);        /* internal file attributes */
-        PUT4L(tail + 38, 0);        /* external file attributes (ignored) */
-        PUT4L(tail + 42, 0);        /* offset of local header */
-        writen(outd, tail, 46);     /* write central file header */
-        cent = 46;
-
-        /* write file name (use &quot;-&quot; for stdin) */
-        if (name == NULL)
-            writen(outd, (unsigned char *)&quot;-&quot;, 1);
-        else
-            writen(outd, (unsigned char *)name, strlen(name));
-        cent += name == NULL ? 1 : strlen(name);
-
-        /* write extended timestamp extra field block (9 bytes) */
-        PUT2L(tail, 0x5455);        /* extended timestamp signature */
-        PUT2L(tail + 2, 5);         /* number of data bytes in this block */
-        tail[4] = 1;                /* flag presence of mod time */
-        PUT4L(tail + 5, mtime);     /* mod time */
-        writen(outd, tail, 9);      /* write extra field block */
-        cent += 9;
-
-        /* write end of central directory record */
-        PUT4L(tail, 0x06054b50UL);  /* end of central directory signature */
-        PUT2L(tail + 4, 0);         /* number of this disk */
-        PUT2L(tail + 6, 0);         /* disk with start of central directory */
-        PUT2L(tail + 8, 1);         /* number of entries on this disk */
-        PUT2L(tail + 10, 1);        /* total number of entries */
-        PUT4L(tail + 12, cent);     /* size of central directory */
-        PUT4L(tail + 16, head + clen + 12); /* offset of central directory */
-        PUT2L(tail + 20, 0);        /* no zip file comment */
-        writen(outd, tail, 22);     /* write end of central directory record */
-    }
-    else if (form) {                /* zlib */
-        PUT4M(tail, check);
-        writen(outd, tail, 4);
-    }
-    else {                          /* gzip */
-        PUT4L(tail, check);
-        PUT4L(tail + 4, ulen);
-        writen(outd, tail, 8);
-    }
-}
-
-/* compute check value depending on format */
-#define CHECK(a,b,c) (form == 1 ? adler32(a,b,c) : crc32(a,b,c))
-
-#ifndef NOTHREAD
-/* -- threaded portions of pigz -- */
-
-/* -- check value combination routines for parallel calculation -- */
-
-#define COMB(a,b,c) (form == 1 ? adler32_comb(a,b,c) : crc32_comb(a,b,c))
-/* combine two crc-32's or two adler-32's (copied from zlib 1.2.3 so that pigz
-   can be compatible with older versions of zlib) */
-
-/* we copy the combination routines from zlib here, in order to avoid
-   linkage issues with the zlib builds on Sun, Ubuntu, and others */
-
-local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec &amp; 1)
-            sum ^= *mat;
-        vec &gt;&gt;= 1;
-        mat++;
-    }
-    return sum;
-}
-
-local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
-{
-    int n;
-
-    for (n = 0; n &lt; 32; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-local unsigned long crc32_comb(unsigned long crc1, unsigned long crc2,
-                               size_t len2)
-{
-    int n;
-    unsigned long row;
-    unsigned long even[32];     /* even-power-of-two zeros operator */
-    unsigned long odd[32];      /* odd-power-of-two zeros operator */
-
-    /* degenerate case */
-    if (len2 == 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n &lt; 32; n++) {
-        odd[n] = row;
-        row &lt;&lt;= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 &amp; 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 &gt;&gt;= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 &amp; 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 &gt;&gt;= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
-
-#define BASE 65521U     /* largest prime smaller than 65536 */
-#define LOW16 0xffff    /* mask lower 16 bits */
-
-local unsigned long adler32_comb(unsigned long adler1, unsigned long adler2,
-                                 size_t len2)
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    rem = (unsigned)(len2 % BASE);
-    sum1 = adler1 &amp; LOW16;
-    sum2 = (rem * sum1) % BASE;
-    sum1 += (adler2 &amp; LOW16) + BASE - 1;
-    sum2 += ((adler1 &gt;&gt; 16) &amp; LOW16) + ((adler2 &gt;&gt; 16) &amp; LOW16) + BASE - rem;
-    if (sum1 &gt;= BASE) sum1 -= BASE;
-    if (sum1 &gt;= BASE) sum1 -= BASE;
-    if (sum2 &gt;= (BASE &lt;&lt; 1)) sum2 -= (BASE &lt;&lt; 1);
-    if (sum2 &gt;= BASE) sum2 -= BASE;
-    return sum1 | (sum2 &lt;&lt; 16);
-}
-
-/* -- pool of spaces for buffer management -- */
-
-/* These routines manage a pool of spaces.  Each pool specifies a fixed size
-   buffer to be contained in each space.  Each space has a use count, which
-   when decremented to zero returns the space to the pool.  If a space is
-   requested from the pool and the pool is empty, a space is immediately
-   created unless a specified limit on the number of spaces has been reached.
-   Only if the limit is reached will it wait for a space to be returned to the
-   pool.  Each space knows what pool it belongs to, so that it can be returned.
- */
-
-/* a space (one buffer for each space) */
-struct space {
-    lock *use;              /* use count -- return to pool when zero */
-    void *buf;              /* buffer of size pool-&gt;size */
-    size_t len;             /* for application usage */
-    struct pool *pool;      /* pool to return to */
-    struct space *next;     /* for pool linked list */
-};
-
-/* pool of spaces (one pool for each size needed) */
-struct pool {
-    lock *have;             /* unused spaces available, lock for list */
-    struct space *head;     /* linked list of available buffers */
-    size_t size;            /* size of all buffers in this pool */
-    int limit;              /* number of new spaces allowed, or -1 */
-    int made;               /* number of buffers made */
-};
-
-/* initialize a pool (pool structure itself provided, not allocated) -- the
-   limit is the maximum number of spaces in the pool, or -1 to indicate no
-   limit, i.e., to never wait for a buffer to return to the pool */
-local void new_pool(struct pool *pool, size_t size, int limit)
-{
-    pool-&gt;have = new_lock(0);
-    pool-&gt;head = NULL;
-    pool-&gt;size = size;
-    pool-&gt;limit = limit;
-    pool-&gt;made = 0;
-}
-
-/* get a space from a pool -- the use count is initially set to one, so there
-   is no need to call use_space() for the first use */
-local struct space *get_space(struct pool *pool)
-{
-    struct space *space;
-
-    /* if can't create any more, wait for a space to show up */
-    possess(pool-&gt;have);
-    if (pool-&gt;limit == 0)
-        wait_for(pool-&gt;have, NOT_TO_BE, 0);
-
-    /* if a space is available, pull it from the list and return it */
-    if (pool-&gt;head != NULL) {
-        space = pool-&gt;head;
-        possess(space-&gt;use);
-        pool-&gt;head = space-&gt;next;
-        twist(pool-&gt;have, BY, -1);      /* one less in pool */
-        twist(space-&gt;use, TO, 1);       /* initially one user */
-        return space;
-    }
-
-    /* nothing available, don't want to wait, make a new space */
-    assert(pool-&gt;limit != 0);
-    if (pool-&gt;limit &gt; 0)
-        pool-&gt;limit--;
-    pool-&gt;made++;
-    release(pool-&gt;have);
-    space = malloc(sizeof(struct space));
-    if (space == NULL)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-    space-&gt;use = new_lock(1);           /* initially one user */
-    space-&gt;buf = malloc(pool-&gt;size);
-    if (space-&gt;buf == NULL)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-    space-&gt;pool = pool;                 /* remember the pool this belongs to */
-    return space;
-}
-
-/* increment the use count to require one more drop before returning this space
-   to the pool */
-local void use_space(struct space *space)
-{
-    possess(space-&gt;use);
-    twist(space-&gt;use, BY, +1);
-}
-
-/* drop a space, returning it to the pool if the use count is zero */
-local void drop_space(struct space *space)
-{
-    int use;
-    struct pool *pool;
-
-    possess(space-&gt;use);
-    use = peek_lock(space-&gt;use);
-    assert(use != 0);
-    if (use == 1) {
-        pool = space-&gt;pool;
-        possess(pool-&gt;have);
-        space-&gt;next = pool-&gt;head;
-        pool-&gt;head = space;
-        twist(pool-&gt;have, BY, +1);
-    }
-    twist(space-&gt;use, BY, -1);
-}
-
-/* free the memory and lock resources of a pool -- return number of spaces for
-   debugging and resource usage measurement */
-local int free_pool(struct pool *pool)
-{
-    int count;
-    struct space *space;
-
-    possess(pool-&gt;have);
-    count = 0;
-    while ((space = pool-&gt;head) != NULL) {
-        pool-&gt;head = space-&gt;next;
-        free(space-&gt;buf);
-        free_lock(space-&gt;use);
-        free(space);
-        count++;
-    }
-    release(pool-&gt;have);
-    free_lock(pool-&gt;have);
-    assert(count == pool-&gt;made);
-    return count;
-}
-
-/* input and output buffer pools */
-local struct pool in_pool;
-local struct pool out_pool;
-
-/* -- parallel compression -- */
-
-/* compress or write job (passed from compress list to write list) -- if seq is
-   equal to -1, compress_thread is instructed to return; if more is false then
-   this is the last chunk, which after writing tells write_thread to return */
-struct job {
-    long seq;                   /* sequence number */
-    int more;                   /* true if this is not the last chunk */
-    struct space *in;           /* input data to compress */
-    struct space *out;          /* dictionary or resulting compressed data */
-    unsigned long check;        /* check value for input data */
-    lock *calc;                 /* released when check calculation complete */
-    struct job *next;           /* next job in the list (either list) */
-};
-
-/* list of compress jobs (with tail for appending to list) */
-local lock *compress_have = NULL;   /* number of compress jobs waiting */
-local struct job *compress_head, **compress_tail;
-
-/* list of write jobs */
-local lock *write_first;            /* lowest sequence number in list */
-local struct job *write_head;
-
-/* number of compression threads running */
-local int cthreads = 0;
-
-/* write thread if running */
-local thread *writeth = NULL;
-
-/* setup job lists (call from main thread) */
-local void setup_jobs(void)
-{
-    /* set up only if not already set up*/
-    if (compress_have != NULL)
-        return;
-
-    /* allocate locks and initialize lists */
-    compress_have = new_lock(0);
-    compress_head = NULL;
-    compress_tail = &amp;compress_head;
-    write_first = new_lock(-1);
-    write_head = NULL;
-
-    /* initialize buffer pools */
-    new_pool(&amp;in_pool, size, (procs &lt;&lt; 1) + 2);
-    new_pool(&amp;out_pool, size + (size &gt;&gt; 11) + 10, -1);
-}
-
-/* command the compress threads to all return, then join them all (call from
-   main thread), free all the thread-related resources */
-local void finish_jobs(void)
-{
-    struct job job;
-    int caught;
-
-    /* only do this once */
-    if (compress_have == NULL)
-        return;
-
-    /* command all of the extant compress threads to return */
-    possess(compress_have);
-    job.seq = -1;
-    job.next = NULL;
-    compress_head = &job;
-    compress_tail = &amp;(job.next);
-    twist(compress_have, BY, +1);       /* will wake them all up */
-
-    /* join all of the compress threads, verify they all came back */
-    caught = join_all();
-    Trace((&quot;-- joined %d compress threads&quot;, caught));
-    assert(caught == cthreads);
-    cthreads = 0;
-
-    /* free the resources */
-    caught = free_pool(&amp;out_pool);
-    Trace((&quot;-- freed %d output buffers&quot;, caught));
-    caught = free_pool(&amp;in_pool);
-    Trace((&quot;-- freed %d input buffers&quot;, caught));
-    free_lock(write_first);
-    free_lock(compress_have);
-    compress_have = NULL;
-}
-
-/* get the next compression job from the head of the list, compress and compute
-   the check value on the input, and put a job in the write list with the
-   results -- keep looking for more jobs, returning when a job is found with a
-   sequence number of -1 (leave that job in the list for other incarnations to
-   find) */
-local void compress_thread(void *dummy)
-{
-    struct job *job;                /* job pulled and working on */ 
-    struct job *here, **prior;      /* pointers for inserting in write list */ 
-    unsigned long check;            /* check value of input */
-    unsigned char *next;            /* pointer for check value data */
-    size_t len;                     /* remaining bytes to compress/check */
-    z_stream strm;                  /* deflate stream */
-
-    /* initialize the deflate stream for this thread */
-    strm.zfree = Z_NULL;
-    strm.zalloc = Z_NULL;
-    strm.opaque = Z_NULL;
-    if (deflateInit2(&amp;strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) !=
-            Z_OK)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-
-    /* keep looking for work */
-    for (;;) {
-        /* get a job (like I tell my son) */
-        possess(compress_have);
-        wait_for(compress_have, NOT_TO_BE, 0);
-        job = compress_head;
-        assert(job != NULL);
-        if (job-&gt;seq == -1)
-            break;
-        compress_head = job-&gt;next;
-        if (job-&gt;next == NULL)
-            compress_tail = &amp;compress_head;
-        twist(compress_have, BY, -1);
-
-        /* got a job -- initialize and set the compression level (note that if
-           deflateParams() is called immediately after deflateReset(), there is
-           no need to initialize the input/output for the stream) */
-        Trace((&quot;-- compressing #%ld&quot;, job-&gt;seq));
-        (void)deflateReset(&amp;strm);
-        (void)deflateParams(&amp;strm, level, Z_DEFAULT_STRATEGY);
-
-        /* set dictionary if provided, release that input buffer (only provided
-           if dict is true and if this is not the first work unit) -- the
-           amount of data in the buffer is assured to be &gt;= DICT */
-        if (job-&gt;out != NULL) {
-            len = job-&gt;out-&gt;len;
-            deflateSetDictionary(&amp;strm,
-                (unsigned char *)(job-&gt;out-&gt;buf) + (len - DICT), DICT);
-            drop_space(job-&gt;out);
-        }
-
-        /* set up input and output (the output size is assured to be big enough
-           for the worst case expansion of the input buffer size, plus five
-           bytes for the terminating stored block) */
-        job-&gt;out = get_space(&amp;out_pool);
-        strm.next_in = job-&gt;in-&gt;buf;
-        strm.next_out = job-&gt;out-&gt;buf;
-
-        /* run MAX-sized amounts of input through deflate -- this loop is
-           needed for those cases where the integer type is smaller than the
-           size_t type, or when len is close to the limit of the size_t type */
-        len = job-&gt;in-&gt;len;
-        while (len &gt; MAX) {
-            strm.avail_in = MAX;
-            strm.avail_out = (unsigned)-1;
-            (void)deflate(&amp;strm, Z_NO_FLUSH);
-            assert(strm.avail_in == 0 &amp;&amp; strm.avail_out != 0);
-            len -= MAX;
-        }
-
-        /* run the last piece through deflate -- terminate with a sync marker,
-           or finish deflate stream if this is the last block */
-        strm.avail_in = (unsigned)len;
-        strm.avail_out = (unsigned)-1;
-        (void)deflate(&amp;strm, job-&gt;more ? Z_SYNC_FLUSH :  Z_FINISH);
-        assert(strm.avail_in == 0 &amp;&amp; strm.avail_out != 0);
-        job-&gt;out-&gt;len = strm.next_out - (unsigned char *)(job-&gt;out-&gt;buf);
-        Trace((&quot;-- compressed #%ld%s&quot;, job-&gt;seq, job-&gt;more ? &quot;&quot; : &quot; (last)&quot;));
-
-        /* reserve input buffer until check value has been calculated */
-        use_space(job-&gt;in);
-
-        /* insert write job in list in sorted order, alert write thread */
-        possess(write_first);
-        prior = &amp;write_head;
-        while ((here = *prior) != NULL) {
-            if (here-&gt;seq &gt; job-&gt;seq)
-                break;
-            prior = &amp;(here-&gt;next);
-        }
-        job-&gt;next = here;
-        *prior = job;
-        twist(write_first, TO, write_head-&gt;seq);
-
-        /* calculate the check value in parallel with writing, alert the write
-           thread that the calculation is complete, and drop this usage of the
-           input buffer */
-        len = job-&gt;in-&gt;len;
-        next = job-&gt;in-&gt;buf;
-        check = CHECK(0L, Z_NULL, 0);
-        while (len &gt; MAX) {
-            check = CHECK(check, next, MAX);
-            len -= MAX;
-            next += MAX;
-        }
-        check = CHECK(check, next, (unsigned)len);
-        drop_space(job-&gt;in);
-        job-&gt;check = check;
-        possess(job-&gt;calc);
-        twist(job-&gt;calc, TO, 1);
-        Trace((&quot;-- checked #%ld%s&quot;, job-&gt;seq, job-&gt;more ? &quot;&quot; : &quot; (last)&quot;));
-
-        /* done with that one -- go find another job */
-    }
-
-    /* found job with seq == -1 -- free deflate memory and return to join */
-    release(compress_have);
-    deflateEnd(&amp;strm);
-}
-
-/* collect the write jobs off of the list in sequence order and write out the
-   compressed data until the last chunk is written -- also write the header and
-   trailer and combine the individual check values of the input buffers */
-local void write_thread(void *dummy)
-{
-    long seq;                       /* next sequence number looking for */
-    struct job *job;                /* job pulled and working on */
-    size_t len;                     /* input length */
-    int more;                       /* true if more chunks to write */
-    unsigned long head;             /* header length */
-    unsigned long ulen;             /* total uncompressed size (overflow ok) */
-    unsigned long clen;             /* total compressed size (overflow ok) */
-    unsigned long check;            /* check value of uncompressed data */
-
-    /* build and write header */
-    Trace((&quot;-- write thread running&quot;));
-    head = put_header();
-
-    /* process output of compress threads until end of input */    
-    ulen = clen = 0;
-    check = CHECK(0L, Z_NULL, 0);
-    seq = 0;
-    do {
-        /* get next write job in order */
-        possess(write_first);
-        wait_for(write_first, TO_BE, seq);
-        job = write_head;
-        write_head = job-&gt;next;
-        twist(write_first, TO, write_head == NULL ? -1 : write_head-&gt;seq);
-
-        /* update lengths, save uncompressed length for COMB */
-        more = job-&gt;more;
-        len = job-&gt;in-&gt;len;
-        drop_space(job-&gt;in);
-        ulen += (unsigned long)len;
-        clen += (unsigned long)(job-&gt;out-&gt;len);
-
-        /* write the compressed data and drop the output buffer */
-        Trace((&quot;-- writing #%ld&quot;, seq));
-        writen(outd, job-&gt;out-&gt;buf, job-&gt;out-&gt;len);
-        drop_space(job-&gt;out);
-        Trace((&quot;-- wrote #%ld%s&quot;, seq, more ? &quot;&quot; : &quot; (last)&quot;));
-
-        /* wait for check calculation to complete, then combine, once
-           the compress thread is done with the input, release it */
-        possess(job-&gt;calc);
-        wait_for(job-&gt;calc, TO_BE, 1);
-        release(job-&gt;calc);
-        check = COMB(check, job-&gt;check, len);
-
-        /* free the job */
-        free_lock(job-&gt;calc);
-        free(job);
-
-        /* get the next buffer in sequence */
-        seq++;
-    } while (more);
-
-    /* write trailer */
-    put_trailer(ulen, clen, check, head);
-
-    /* verify no more jobs, prepare for next use */
-    possess(compress_have);
-    assert(compress_head == NULL &amp;&amp; peek_lock(compress_have) == 0);
-    release(compress_have);
-    possess(write_first);
-    assert(write_head == NULL);
-    twist(write_first, TO, -1);
-}
-
-/* compress ind to outd, using multiple threads for the compression and check
-   value calculations and one other thread for writing the output -- compress
-   threads will be launched and left running (waiting actually) to support
-   subsequent calls of parallel_compress() */
-local void parallel_compress(void)
-{
-    long seq;                       /* sequence number */
-    struct space *prev;             /* previous input space */
-    struct space *next;             /* next input space */
-    struct job *job;                /* job for compress, then write */
-    int more;                       /* true if more input to read */
-
-    /* if first time or after an option change, setup the job lists */
-    setup_jobs();
-
-    /* start write thread */
-    writeth = launch(write_thread, NULL);
-
-    /* read from input and start compress threads (write thread will pick up
-       the output of the compress threads) */
-    seq = 0;
-    prev = NULL;
-    next = get_space(&amp;in_pool);
-    next-&gt;len = readn(ind, next-&gt;buf, next-&gt;pool-&gt;size);
-    do {
-        /* create a new job, use next input chunk, previous as dictionary */
-        job = malloc(sizeof(struct job));
-        if (job == NULL)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-        job-&gt;seq = seq;
-        job-&gt;in = next;
-        job-&gt;out = dict ? prev : NULL;  /* dictionary for compression */
-        job-&gt;calc = new_lock(0);
-
-        /* check for end of file, reading next chunk if not sure */
-        if (next-&gt;len &lt; next-&gt;pool-&gt;size)
-            more = 0;
-        else {
-            next = get_space(&amp;in_pool);
-            next-&gt;len = readn(ind, next-&gt;buf, next-&gt;pool-&gt;size);
-            more = next-&gt;len != 0;
-            if (!more)
-                drop_space(next);       /* won't be using it */
-            if (dict &amp;&amp; more) {
-                use_space(job-&gt;in);     /* hold as dictionary for next loop */
-                prev = job-&gt;in;
-            }
-        }
-        job-&gt;more = more;
-        Trace((&quot;-- read #%ld%s&quot;, seq, more ? &quot;&quot; : &quot; (last)&quot;));
-        if (++seq &lt; 1)
-            bail(&quot;input too long: &quot;, in);
-
-        /* start another compress thread if needed */
-        if (cthreads &lt; seq &amp;&amp; cthreads &lt; procs) {
-            (void)launch(compress_thread, NULL);
-            cthreads++;
-        }
-
-        /* put job at end of compress list, let all the compressors know */
-        possess(compress_have);
-        job-&gt;next = NULL;
-        *compress_tail = job;
-        compress_tail = &amp;(job-&gt;next);
-        twist(compress_have, BY, +1);
-
-        /* do until end of input */
-    } while (more);
-
-    /* wait for the write thread to complete (we leave the compress threads out
-       there and waiting in case there is another stream to compress) */
-    join(writeth);
-    writeth = NULL;
-    Trace((&quot;-- write thread joined&quot;));
-}
-
-#endif
-
-/* do a simple compression in a single thread from ind to outd -- if reset is
-   true, instead free the memory that was allocated and retained for input,
-   output, and deflate */
-local void single_compress(int reset)
-{
-    size_t got;                     /* amount read */
-    size_t more;                    /* amount of next read (0 if eof) */
-    unsigned long head;             /* header length */
-    unsigned long ulen;             /* total uncompressed size (overflow ok) */
-    unsigned long clen;             /* total compressed size (overflow ok) */
-    unsigned long check;            /* check value of uncompressed data */
-    static unsigned out_size;       /* size of output buffer */
-    static unsigned char *in, *next, *out;  /* reused i/o buffers */
-    static z_stream *strm = NULL;   /* reused deflate structure */
-
-    /* if requested, just release the allocations and return */
-    if (reset) {
-        if (strm != NULL) {
-            deflateEnd(strm);
-            free(strm);
-            free(out);
-            free(next);
-            free(in);
-            strm = NULL;
-        }
-        return;
-    }
-
-    /* initialize the deflate structure if this is the first time */
-    if (strm == NULL) {
-        out_size = size &gt; MAX ? MAX : (unsigned)size;
-        if ((in = malloc(size)) == NULL ||
-            (next = malloc(size)) == NULL ||
-            (out = malloc(out_size)) == NULL ||
-            (strm = malloc(sizeof(z_stream))) == NULL)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-        strm-&gt;zfree = Z_NULL;
-        strm-&gt;zalloc = Z_NULL;
-        strm-&gt;opaque = Z_NULL;
-        if (deflateInit2(strm, level, Z_DEFLATED, -15, 8,
-                         Z_DEFAULT_STRATEGY) != Z_OK)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-    }
-
-    /* write header */
-    head = put_header();
-
-    /* set compression level in case it changed */
-    (void)deflateReset(strm);
-    (void)deflateParams(strm, level, Z_DEFAULT_STRATEGY);
-
-    /* do raw deflate and calculate check value */
-    ulen = clen = 0;
-    check = CHECK(0L, Z_NULL, 0);
-    more = readn(ind, next, size);
-    do {
-        /* get data to compress, see if there is any more input */
-        got = more;
-        { unsigned char *temp; temp = in; in = next; next = temp; }
-        more = got &lt; size ? 0 : readn(ind, next, size);
-        ulen += (unsigned long)got;
-        strm-&gt;next_in = in;
-
-        /* compress MAX-size chunks in case unsigned type is small */
-        while (got &gt; MAX) {
-            strm-&gt;avail_in = MAX;
-            check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
-            do {
-                strm-&gt;avail_out = out_size;
-                strm-&gt;next_out = out;
-                (void)deflate(strm, Z_NO_FLUSH);
-                writen(outd, out, out_size - strm-&gt;avail_out);
-                clen += out_size - strm-&gt;avail_out;
-            } while (strm-&gt;avail_out == 0);
-            assert(strm-&gt;avail_in == 0);
-            got -= MAX;
-        }
-
-        /* compress the remainder, finishing if end of input -- when not -i,
-           use a Z_SYNC_FLUSH so that this and parallel compression produce the
-           same output */
-        strm-&gt;avail_in = (unsigned)got;
-        check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
-        do {
-            strm-&gt;avail_out = out_size;
-            strm-&gt;next_out = out;
-            (void)deflate(strm,
-                more ? (dict ? Z_SYNC_FLUSH : Z_FULL_FLUSH) : Z_FINISH);
-            writen(outd, out, out_size - strm-&gt;avail_out);
-            clen += out_size - strm-&gt;avail_out;
-        } while (strm-&gt;avail_out == 0);
-        assert(strm-&gt;avail_in == 0);
-
-        /* do until no more input */
-    } while (more);
-
-    /* write trailer */
-    put_trailer(ulen, clen, check, head);
-}
-
-/* --- decompression --- */
-
-/* globals for decompression and listing buffered reading */
-#define BUF 32768U                  /* input buffer size */
-local unsigned char in_buf[BUF];    /* input buffer */
-local unsigned char *in_next;       /* next unused byte in buffer */
-local size_t in_left;               /* number of unused bytes in buffer */
-local int in_eof;                   /* true if reached end of file on input */
-local int in_short;                 /* true if last read didn't fill buffer */
-local off_t in_tot;                 /* total bytes read from input */
-local off_t out_tot;                /* total bytes written to output */
-local unsigned long out_check;      /* check value of output */
-
-#ifndef NOTHREAD
-/* parallel reading */
-
-local unsigned char in_buf2[BUF];   /* second buffer for parallel reads */
-local size_t in_len;                /* data waiting in next buffer */
-local int in_which;                 /* -1: start, 0: in_buf2, 1: in_buf */
-local lock *load_state;             /* value = 0 to wait, 1 to read a buffer */
-local thread *load_thread;          /* load_read() thread for joining */
-
-/* parallel read thread */
-local void load_read(void *dummy)
-{
-    size_t len;
-
-    Trace((&quot;-- launched decompress read thread&quot;));
-    do {
-        possess(load_state);
-        wait_for(load_state, TO_BE, 1);
-        in_len = len = readn(ind, in_which ? in_buf : in_buf2, BUF);
-        Trace((&quot;-- decompress read thread read %lu bytes&quot;, len));
-        twist(load_state, TO, 0);
-    } while (len == BUF);
-    Trace((&quot;-- exited decompress read thread&quot;));
-}
-
-#endif
-
-/* load() is called when in_left has gone to zero in order to provide more
-   input data: load the input buffer with BUF or less bytes (less if at end of
-   file) from the file ind, set in_next to point to the in_left bytes read,
-   update in_tot, and return in_left -- in_eof is set to true when in_left has
-   gone to zero and there is no more data left to read from ind */
-local size_t load(void)
-{
-    /* if already detected end of file, do nothing */
-    if (in_short) {
-        in_eof = 1;
-        return 0;
-    }
-
-#ifndef NOTHREAD
-    /* if first time in or procs == 1, read a buffer to have something to
-       return, otherwise wait for the previous read job to complete */
-    if (procs &gt; 1) {
-        /* if first time, fire up the read thread, ask for a read */
-        if (in_which == -1) {
-            in_which = 1;
-            load_state = new_lock(1);
-            load_thread = launch(load_read, NULL);
-        }
-
-        /* wait for the previously requested read to complete */
-        possess(load_state);
-        wait_for(load_state, TO_BE, 0);
-        release(load_state);
-
-        /* set up input buffer with the data just read */
-        in_next = in_which ? in_buf : in_buf2;
-        in_left = in_len;
-
-        /* if not at end of file, alert read thread to load next buffer,
-           alternate between in_buf and in_buf2 */
-        if (in_len == BUF) {
-            in_which = 1 - in_which;
-            possess(load_state);
-            twist(load_state, TO, 1);
-        }
-
-        /* at end of file -- join read thread (already exited), clean up */
-        else {
-            join(load_thread);
-            free_lock(load_state);
-            in_which = -1;
-        }
-    }
-    else
-#endif
-    {
-        /* don't use threads -- simply read a buffer into in_buf */
-        in_left = readn(ind, in_next = in_buf, BUF);
-    }
-
-    /* note end of file */
-    if (in_left &lt; BUF) {
-        in_short = 1;
-
-        /* if we got bupkis, now is the time to mark eof */
-        if (in_left == 0)
-            in_eof = 1;
-    }
-
-    /* update the total and return the available bytes */
-    in_tot += in_left;
-    return in_left;
-}
-
-/* initialize for reading new input */
-local void in_init(void)
-{
-    in_left = 0;
-    in_eof = 0;
-    in_short = 0;
-    in_tot = 0;
-#ifndef NOTHREAD
-    in_which = -1;
-#endif
-}
-
-/* buffered reading macros for decompression and listing */
-#define GET() (in_eof || (in_left == 0 &amp;&amp; load() == 0) ? EOF : \
-               (in_left--, *in_next++))
-#define GET2() (tmp2 = GET(), tmp2 + (GET() &lt;&lt; 8))
-#define GET4() (tmp4 = GET2(), tmp4 + ((unsigned long)(GET2()) &lt;&lt; 16))
-#define SKIP(dist) \
-    do { \
-        size_t togo = (dist); \
-        while (togo &gt; in_left) { \
-            togo -= in_left; \
-            if (load() == 0) \
-                return -1; \
-        } \
-        in_left -= togo; \
-        in_next += togo; \
-    } while (0)
-
-/* convert MS-DOS date and time to a Unix time, assuming current timezone
-   (you got a better idea?) */
-local time_t dos2time(unsigned long dos)
-{
-    struct tm tm;
-
-    if (dos == 0)
-        return time(NULL);
-    tm.tm_year = ((int)(dos &gt;&gt; 25) &amp; 0x7f) + 80;
-    tm.tm_mon  = ((int)(dos &gt;&gt; 21) &amp; 0xf) - 1;
-    tm.tm_mday = (int)(dos &gt;&gt; 16) &amp; 0x1f;
-    tm.tm_hour = (int)(dos &gt;&gt; 11) &amp; 0x1f;
-    tm.tm_min  = (int)(dos &gt;&gt; 5) &amp; 0x3f;
-    tm.tm_sec  = (int)(dos &lt;&lt; 1) &amp; 0x3e;
-    tm.tm_isdst = -1;           /* figure out if DST or not */
-    return mktime(&amp;tm);
-}
-
-/* convert an unsigned 32-bit integer to signed, even if long &gt; 32 bits */
-local long tolong(unsigned long val)
-{
-    return (long)(val &amp; 0x7fffffffUL) - (long)(val &amp; 0x80000000UL);
-}
-
-#define LOW32 0xffffffffUL
-
-/* process zip extra field to extract zip64 lengths and Unix mod time */
-local int read_extra(unsigned len, int save)
-{
-    unsigned id, size, tmp2;
-    unsigned long tmp4;
-
-    /* process extra blocks */
-    while (len &gt;= 4) {
-        id = GET2();
-        size = GET2();
-        if (in_eof)
-            return -1;
-        len -= 4;
-        if (size &gt; len)
-            break;
-        len -= size;
-        if (id == 0x0001) {
-            /* Zip64 Extended Information Extra Field */
-            if (zip_ulen == LOW32 &amp;&amp; size &gt;= 8) {
-                zip_ulen = GET4();
-                SKIP(4);
-                size -= 8;
-            }
-            if (zip_clen == LOW32 &amp;&amp; size &gt;= 8) {
-                zip_clen = GET4();
-                SKIP(4);
-                size -= 8;
-            }
-        }
-        if (save) {
-            if ((id == 0x000d || id == 0x5855) &amp;&amp; size &gt;= 8) {
-                /* PKWare Unix or Info-ZIP Type 1 Unix block */
-                SKIP(4);
-                stamp = tolong(GET4());
-                size -= 8;
-            }
-            if (id == 0x5455 &amp;&amp; size &gt;= 5) {
-                /* Extended Timestamp block */
-                size--;
-                if (GET() &amp; 1) {
-                    stamp = tolong(GET4());
-                    size -= 4;
-                }
-            }
-        }
-        SKIP(size);
-    }
-    SKIP(len);
-    return 0;
-}
-
-/* read a gzip, zip, zlib, or lzw header from ind and extract useful
-   information, return the method -- or on error return negative: -1 is
-   immediate EOF, -2 is not a recognized compressed format, -3 is premature EOF
-   within the header, -4 is unexpected header flag values; a method of 256 is
-   lzw -- set form to indicate gzip, zlib, or zip */
-local int get_header(int save)
-{
-    unsigned magic;             /* magic header */
-    int method;                 /* compression method */
-    int flags;                  /* header flags */
-    unsigned fname, extra;      /* name and extra field lengths */
-    unsigned tmp2;              /* for macro */
-    unsigned long tmp4;         /* for macro */
-
-    /* clear return information */
-    if (save) {
-        stamp = 0;
-        RELEASE(hname);
-    }
-
-    /* see if it's a gzip, zlib, or lzw file */
-    form = 0;
-    magic = GET() &lt;&lt; 8;
-    if (in_eof)
-        return -1;
-    magic += GET();
-    if (in_eof)
-        return -2;
-    if (magic % 31 == 0) {          /* it's zlib */
-        form = 1;
-        return (int)((magic &gt;&gt; 8) &amp; 0xf);
-    }
-    if (magic == 0x1f9d)            /* it's lzw */
-        return 256;
-    if (magic == 0x504b) {          /* it's zip */
-        if (GET() != 3 || GET() != 4)
-            return -3;
-        SKIP(2);
-        flags = GET2();
-        if (in_eof)
-            return -3;
-        if (flags &amp; 0xfff0)
-            return -4;
-        method = GET2();
-        if (flags &amp; 1)              /* encrypted */
-            method = 255;           /* mark as unknown method */
-        if (in_eof)
-            return -3;
-        if (save)
-            stamp = dos2time(GET4());
-        else
-            SKIP(4);
-        zip_crc = GET4();
-        zip_clen = GET4();
-        zip_ulen = GET4();
-        fname = GET2();
-        extra = GET2();
-        if (save) {
-            char *next = hname = malloc(fname + 1);
-            if (hname == NULL)
-                bail(&quot;not enough memory&quot;, &quot;&quot;);
-            while (fname &gt; in_left) {
-                memcpy(next, in_next, in_left);
-                fname -= in_left;
-                next += in_left;
-                if (load() == 0)
-                    return -3;
-            }
-            memcpy(next, in_next, fname);
-            in_left -= fname;
-            in_next += fname;
-            next += fname;
-            *next = 0;
-        }
-        else
-            SKIP(fname);
-        read_extra(extra, save);
-        form = 2 + ((flags &amp; 8) &gt;&gt; 3);
-        return in_eof ? -3 : method;
-    }
-    if (magic != 0x1f8b)            /* not gzip */
-        return -2;
-
-    /* it's gzip -- get method and flags */
-    method = GET();
-    flags = GET();
-    if (in_eof)
-        return -1;
-    if (flags &amp; 0xe0)
-        return -4;
-
-    /* get time stamp */
-    if (save)
-        stamp = tolong(GET4());
-    else
-        SKIP(4);
-
-    /* skip extra field and OS */
-    SKIP(2);
-
-    /* skip extra field, if present */
-    if (flags &amp; 4) {
-        extra = GET2();
-        if (in_eof)
-            return -3;
-        SKIP(extra);
-    }
-
-    /* read file name, if present, into allocated memory */
-    if ((flags &amp; 8) &amp;&amp; save) {
-        unsigned char *end;
-        size_t copy, have, size = 128;
-        hname = malloc(size);
-        if (hname == NULL)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-        have = 0;
-        do {
-            if (in_left == 0 &amp;&amp; load() == 0)
-                return -3;
-            end = memchr(in_next, 0, in_left);
-            copy = end == NULL ? in_left : (end - in_next) + 1;
-            if (have + copy &gt; size) {
-                while (have + copy &gt; (size &lt;&lt;= 1))
-                    ;
-                hname = realloc(hname, size);
-                if (hname == NULL)
-                    bail(&quot;not enough memory&quot;, &quot;&quot;);
-            }
-            memcpy(hname + have, in_next, copy);
-            have += copy;
-            in_left -= copy;
-            in_next += copy;
-        } while (end == NULL);
-    }
-    else if (flags &amp; 8)
-        while (GET() != 0)
-            if (in_eof)
-                return -3;
-
-    /* skip comment */
-    if (flags &amp; 16)
-        while (GET() != 0)
-            if (in_eof)
-                return -3;
-
-    /* skip header crc */
-    if (flags &amp; 2)
-        SKIP(2);
-
-    /* return compression method */
-    return method;
-}
-
-/* --- list contents of compressed input (gzip, zlib, or lzw) */
-
-/* find standard compressed file suffix, return length of suffix */
-local size_t compressed_suffix(char *nm)
-{
-    size_t len;
-
-    len = strlen(nm);
-    if (len &gt; 4) {
-        nm += len - 4;
-        len = 4;
-        if (strcmp(nm, &quot;.zip&quot;) == 0 || strcmp(nm, &quot;.ZIP&quot;) == 0 || strcmp(nm, &quot;.spl&quot;) == 0)
-            return 4;
-    }
-    if (len &gt; 3) {
-        nm += len - 3;
-        len = 3;
-        if (strcmp(nm, &quot;.gz&quot;) == 0 || strcmp(nm, &quot;-gz&quot;) == 0 ||
-            strcmp(nm, &quot;.zz&quot;) == 0 || strcmp(nm, &quot;-zz&quot;) == 0)
-            return 3;
-    }
-    if (len &gt; 2) {
-        nm += len - 2;
-        if (strcmp(nm, &quot;.z&quot;) == 0 || strcmp(nm, &quot;-z&quot;) == 0 ||
-            strcmp(nm, &quot;_z&quot;) == 0 || strcmp(nm, &quot;.Z&quot;) == 0)
-            return 2;
-    }
-    return 0;
-}
-
-/* listing file name lengths for -l and -lv */
-#define NAMEMAX1 48     /* name display limit at verbosity 1 */
-#define NAMEMAX2 16     /* name display limit at verbosity 2 */
-
-/* print gzip or lzw file information */
-local void show_info(int method, unsigned long check, off_t len, int cont)
-{
-    int max;                /* maximum name length for current verbosity */
-    size_t n;               /* name length without suffix */
-    time_t now;             /* for getting current year */
-    char mod[26];           /* modification time in text */
-    char name[NAMEMAX1+1];  /* header or file name, possibly truncated */
-
-    /* create abbreviated name from header file name or actual file name */
-    max = verbosity &gt; 1 ? NAMEMAX2 : NAMEMAX1;
-    memset(name, 0, max + 1);
-    if (cont)
-        strncpy(name, &quot;&lt;...&gt;&quot;, max + 1);
-    else if (hname == NULL) {
-        n = strlen(in) - compressed_suffix(in);
-        strncpy(name, in, n &gt; max + 1 ? max + 1 : n);
-    }
-    else
-        strncpy(name, hname, max + 1);
-    if (name[max])
-        strcpy(name + max - 3, &quot;...&quot;);
-
-    /* convert time stamp to text */
-    if (stamp) {
-        strcpy(mod, ctime(&amp;stamp));
-        now = time(NULL);
-        if (strcmp(mod + 20, ctime(&amp;now) + 20) != 0)
-            strcpy(mod + 11, mod + 19);
-    }
-    else
-        strcpy(mod + 4, &quot;------ -----&quot;);
-    mod[16] = 0;
-
-    /* if first time, print header */
-    if (first) {
-        if (verbosity &gt; 1)
-            fputs(&quot;method    check    timestamp    &quot;, stdout);
-        if (verbosity &gt; 0)
-            puts(&quot;compressed   original reduced  name&quot;);
-        first = 0;
-    }
-
-    /* print information */
-    if (verbosity &gt; 1) {
-        if (form == 3 &amp;&amp; !decode)
-            printf(&quot;zip%3d  --------  %s  &quot;, method, mod + 4);
-        else if (form &gt; 1)
-            printf(&quot;zip%3d  %08lx  %s  &quot;, method, check, mod + 4);
-        else if (form)
-            printf(&quot;zlib%2d  %08lx  %s  &quot;, method, check, mod + 4);
-        else if (method == 256)
-            printf(&quot;lzw     --------  %s  &quot;, mod + 4);
-        else
-            printf(&quot;gzip%2d  %08lx  %s  &quot;, method, check, mod + 4);
-    }
-    if (verbosity &gt; 0) {
-        if ((form == 3 &amp;&amp; !decode) ||
-            (method == 8 &amp;&amp; in_tot &gt; (len + (len &gt;&gt; 10) + 12)) ||
-            (method == 256 &amp;&amp; in_tot &gt; len + (len &gt;&gt; 1) + 3))
-            printf(sizeof(off_t) == 4 ? &quot;%10lu %10lu?  unk    %s\n&quot; :
-                                        &quot;%10llu %10llu?  unk    %s\n&quot;,
-                   in_tot, len, name);
-        else
-            printf(sizeof(off_t) == 4 ? &quot;%10lu %10lu %6.1f%%  %s\n&quot; :
-                                        &quot;%10llu %10llu %6.1f%%  %s\n&quot;,
-                   in_tot, len,
-                   len == 0 ? 0 : 100 * (len - in_tot)/(double)len,
-                   name);
-    }
-}
-
-/* list content information about the gzip file at ind (only works if the gzip
-   file contains a single gzip stream with no junk at the end, and only works
-   well if the uncompressed length is less than 4 GB) */
-local void list_info(void)
-{
-    int method;             /* get_header() return value */
-    size_t n;               /* available trailer bytes */
-    off_t at;               /* used to calculate compressed length */
-    unsigned char tail[8];  /* trailer containing check and length */
-    unsigned long check, len;   /* check value and length from trailer */
-
-    /* initialize input buffer */
-    in_init();
-
-    /* read header information and position input after header */
-    method = get_header(1);
-    if (method &lt; 0) {
-        RELEASE(hname);
-        if (method != -1 &amp;&amp; verbosity &gt; 1)
-            fprintf(stderr, &quot;%s not a compressed file -- skipping\n&quot;, in);
-        return;
-    }
-
-    /* list zip file */
-    if (form &gt; 1) {
-        in_tot = zip_clen;
-        show_info(method, zip_crc, zip_ulen, 0);
-        return;
-    }
-
-    /* list zlib file */
-    if (form) {
-        at = lseek(ind, 0, SEEK_END);
-        if (at == -1) {
-            check = 0;
-            do {
-                len = in_left &lt; 4 ? in_left : 4;
-                in_next += in_left - len;
-                while (len--)
-                    check = (check &lt;&lt; 8) + *in_next++;
-            } while (load() != 0);
-            check &amp;= LOW32;
-        }
-        else {
-            in_tot = at;
-            lseek(ind, -4, SEEK_END);
-            readn(ind, tail, 4);
-            check = (*tail &lt;&lt; 24) + (tail[1] &lt;&lt; 16) + (tail[2] &lt;&lt; 8) + tail[3];
-        }
-        in_tot -= 6;
-        show_info(method, check, 0, 0);
-        return;
-    }
-
-    /* list lzw file */
-    if (method == 256) {
-        at = lseek(ind, 0, SEEK_END);
-        if (at == -1)
-            while (load() != 0)
-                ;
-        else
-            in_tot = at;
-        in_tot -= 3;
-        show_info(method, 0, 0, 0);
-        return;
-    }
-
-    /* skip to end to get trailer (8 bytes), compute compressed length */
-    if (in_short) {                     /* whole thing already read */
-        if (in_left &lt; 8) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s not a valid gzip file -- skipping\n&quot;,
-                        in);
-            return;
-        }
-        in_tot = in_left - 8;           /* compressed size */
-        memcpy(tail, in_next + (in_left - 8), 8);
-    }
-    else if ((at = lseek(ind, -8, SEEK_END)) != -1) {
-        in_tot = at - in_tot + in_left; /* compressed size */
-        readn(ind, tail, 8);            /* get trailer */
-    }
-    else {                              /* can't seek */
-        at = in_tot - in_left;          /* save header size */
-        do {
-            n = in_left &lt; 8 ? in_left : 8;
-            memcpy(tail, in_next + (in_left - n), n);
-            load();
-        } while (in_left == BUF);       /* read until end */
-        if (in_left &lt; 8) {
-            if (n + in_left &lt; 8) {
-                if (verbosity &gt; 0)
-                    fprintf(stderr, &quot;%s not a valid gzip file -- skipping\n&quot;,
-                            in);
-                return;
-            }
-            if (in_left) {
-                if (n + in_left &gt; 8)
-                    memcpy(tail, tail + n - (8 - in_left), 8 - in_left);
-                memcpy(tail + 8 - in_left, in_next, in_left);
-            }
-        }
-        else
-            memcpy(tail, in_next + (in_left - 8), 8);
-        in_tot -= at + 8;
-    }
-    if (in_tot &lt; 2) {
-        if (verbosity &gt; 0)
-            fprintf(stderr, &quot;%s not a valid gzip file -- skipping\n&quot;, in);
-        return;
-    }
-
-    /* convert trailer to check and uncompressed length (modulo 2^32) */
-    check = tail[0] + (tail[1] &lt;&lt; 8) + (tail[2] &lt;&lt; 16) + (tail[3] &lt;&lt; 24);
-    len = tail[4] + (tail[5] &lt;&lt; 8) + (tail[6] &lt;&lt; 16) + (tail[7] &lt;&lt; 24);
-
-    /* list information about contents */
-    show_info(method, check, len, 0);
-    RELEASE(hname);
-}
-
-/* --- decompress deflate input --- */
-
-/* call-back input function for inflateBack() */
-local unsigned inb(void *desc, unsigned char **buf)
-{
-    load();
-    *buf = in_next;
-    return in_left;
-}
-
-/* output buffers and window for infchk() and unlzw() */
-#define OUTSIZE 32768U      /* must be at least 32K for inflateBack() window */
-local unsigned char out_buf[OUTSIZE];
-
-#ifndef NOTHREAD
-/* output data for parallel write and check */
-local unsigned char out_copy[OUTSIZE];
-local size_t out_len;
-
-/* outb threads states */
-local lock *outb_write_more = NULL;
-local lock *outb_check_more;
-
-/* output write thread */
-local void outb_write(void *dummy)
-{
-    size_t len;
-
-    Trace((&quot;-- launched decompress write thread&quot;));
-    do {
-        possess(outb_write_more);
-        wait_for(outb_write_more, TO_BE, 1);
-        len = out_len;
-        if (len &amp;&amp; decode == 1)
-            writen(outd, out_copy, len);
-        Trace((&quot;-- decompress wrote %lu bytes&quot;, len));
-        twist(outb_write_more, TO, 0);
-    } while (len);
-    Trace((&quot;-- exited decompress write thread&quot;));
-}
-
-/* output check thread */
-local void outb_check(void *dummy)
-{
-    size_t len;
-
-    Trace((&quot;-- launched decompress check thread&quot;));
-    do {
-        possess(outb_check_more);
-        wait_for(outb_check_more, TO_BE, 1);
-        len = out_len;
-        out_check = CHECK(out_check, out_copy, len);
-        Trace((&quot;-- decompress checked %lu bytes&quot;, len));
-        twist(outb_check_more, TO, 0);
-    } while (len);
-    Trace((&quot;-- exited decompress check thread&quot;));
-}
-#endif
-
-/* call-back output function for inflateBack() -- wait for the last write and
-   check calculation to complete, copy the write buffer, and then alert the
-   write and check threads and return for more decompression while that's
-   going on (or just write and check if no threads or if proc == 1) */
-local int outb(void *desc, unsigned char *buf, unsigned len)
-{
-#ifndef NOTHREAD
-    static thread *wr, *ch;
-
-    if (procs &gt; 1) {
-        /* if first time, initialize state and launch threads */
-        if (outb_write_more == NULL) {
-            outb_write_more = new_lock(0);
-            outb_check_more = new_lock(0);
-            wr = launch(outb_write, NULL);
-            ch = launch(outb_check, NULL);
-        }
-
-        /* wait for previous write and check threads to complete */
-        possess(outb_check_more);
-        wait_for(outb_check_more, TO_BE, 0);
-        possess(outb_write_more);
-        wait_for(outb_write_more, TO_BE, 0);
-
-        /* copy the output and alert the worker bees */
-        out_len = len;
-        out_tot += len;
-        memcpy(out_copy, buf, len);
-        twist(outb_write_more, TO, 1);
-        twist(outb_check_more, TO, 1);
-
-        /* if requested with len == 0, clean up -- terminate and join write and
-           check threads, free lock */
-        if (len == 0) {
-            join(ch);
-            join(wr);
-            free_lock(outb_check_more);
-            free_lock(outb_write_more);
-            outb_write_more = NULL;
-        }
-
-        /* return for more decompression while last buffer is being written
-           and having its check value calculated -- we wait for those to finish
-           the next time this function is called */
-        return 0;
-    }
-#endif
-
-    /* if just one process or no threads, then do it without threads */
-    if (len) {
-        if (decode == 1)
-            writen(outd, buf, len);
-        out_check = CHECK(out_check, buf, len);
-        out_tot += len;
-    }
-    return 0;
-}
-
-/* inflate for decompression or testing -- decompress from ind to outd unless
-   decode != 1, in which case just test ind, and then also list if list != 0;
-   look for and decode multiple, concatenated gzip and/or zlib streams;
-   read and check the gzip, zlib, or zip trailer */
-local void infchk(void)
-{
-    int ret, cont;
-    unsigned long check, len;
-    z_stream strm;
-    unsigned tmp2;
-    unsigned long tmp4;
-    off_t clen;
-
-    cont = 0;
-    do {
-        /* header already read -- set up for decompression */
-        in_tot = in_left;               /* track compressed data length */
-        out_tot = 0;
-        out_check = CHECK(0L, Z_NULL, 0);
-        strm.zalloc = Z_NULL;
-        strm.zfree = Z_NULL;
-        strm.opaque = Z_NULL;
-        ret = inflateBackInit(&amp;strm, 15, out_buf);
-        if (ret != Z_OK)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-
-        /* decompress, compute lengths and check value */
-        strm.avail_in = in_left;
-        strm.next_in = in_next;
-        ret = inflateBack(&amp;strm, inb, NULL, outb, NULL);
-        if (ret != Z_STREAM_END)
-            bail(&quot;corrupted input -- invalid deflate data: &quot;, in);
-        in_left = strm.avail_in;
-        in_next = strm.next_in;
-        inflateBackEnd(&amp;strm);
-        outb(NULL, NULL, 0);        /* finish off final write and check */
-
-        /* compute compressed data length */
-        clen = in_tot - in_left;
-
-        /* read and check trailer */
-        if (form &gt; 1) {             /* zip local trailer (if any) */
-            if (form == 3) {        /* data descriptor follows */
-                /* read original version of data descriptor*/
-                zip_crc = GET4();
-                zip_clen = GET4();
-                zip_ulen = GET4();
-                if (in_eof)
-                    bail(&quot;corrupted zip entry -- missing trailer: &quot;, in);
-
-                /* if crc doesn't match, try info-zip variant with sig */
-                if (zip_crc != out_check) {
-                    if (zip_crc != 0x08074b50UL || zip_clen != out_check)
-                        bail(&quot;corrupted zip entry -- crc32 mismatch: &quot;, in);
-                    zip_crc = zip_clen;
-                    zip_clen = zip_ulen;
-                    zip_ulen = GET4();
-                }
-
-                /* if second length doesn't match, try 64-bit lengths */
-                if (zip_ulen != (out_tot &amp; LOW32)) {
-                    unsigned long dummy = 0;
-                    zip_ulen = GET4();
-                    dummy = GET4();
-                }
-                if (in_eof)
-                    bail(&quot;corrupted zip entry -- missing trailer: &quot;, in);
-            }
-            if (zip_clen != (clen &amp; LOW32) || zip_ulen != (out_tot &amp; LOW32))
-                bail(&quot;corrupted zip entry -- length mismatch: &quot;, in);
-            check = zip_crc;
-        }
-        else if (form == 1) {       /* zlib (big-endian) trailer */
-            check = GET() &lt;&lt; 24;
-            check += GET() &lt;&lt; 16;
-            check += GET() &lt;&lt; 8;
-            check += GET();
-            if (in_eof)
-                bail(&quot;corrupted zlib stream -- missing trailer: &quot;, in);
-            if (check != out_check)
-                bail(&quot;corrupted zlib stream -- adler32 mismatch: &quot;, in);
-        }
-        else {                      /* gzip trailer */
-            check = GET4();
-            len = GET4();
-            if (in_eof)
-                bail(&quot;corrupted gzip stream -- missing trailer: &quot;, in);
-            if (check != out_check)
-                bail(&quot;corrupted gzip stream -- crc32 mismatch: &quot;, in);
-            if (len != (out_tot &amp; LOW32))
-                bail(&quot;corrupted gzip stream -- length mismatch: &quot;, in);
-        }
-
-        /* show file information if requested */
-        if (list) {
-            in_tot = clen;
-            show_info(8, check, out_tot, cont);
-            cont = 1;
-        }
-
-        /* if a gzip or zlib entry follows a gzip or zlib entry, decompress it
-           (don't replace saved header information from first entry) */
-    } while (form &lt; 2 &amp;&amp; (ret = get_header(0)) == 8 &amp;&amp; form &lt; 2);
-    if (ret != -1 &amp;&amp; form &lt; 2)
-        fprintf(stderr, &quot;%s OK, has trailing junk which was ignored\n&quot;, in);
-}
-
-/* --- decompress Unix compress (LZW) input --- */
-
-/* memory for unlzw() --
-   the first 256 entries of prefix[] and suffix[] are never used, could
-   have offset the index, but it's faster to waste the memory */
-unsigned short prefix[65536];           /* index to LZW prefix string */
-unsigned char suffix[65536];            /* one-character LZW suffix */
-unsigned char match[65280 + 2];         /* buffer for reversed match */
-
-/* throw out what's left in the current bits byte buffer (this is a vestigial
-   aspect of the compressed data format derived from an implementation that
-   made use of a special VAX machine instruction!) */
-#define FLUSHCODE() \
-    do { \
-        left = 0; \
-        rem = 0; \
-        if (chunk &gt; in_left) { \
-            chunk -= in_left; \
-            if (load() == 0) \
-                break; \
-            if (chunk &gt; in_left) { \
-                chunk = in_left = 0; \
-                break; \
-            } \
-        } \
-        in_left -= chunk; \
-        in_next += chunk; \
-        chunk = 0; \
-    } while (0)
-
-/* Decompress a compress (LZW) file from ind to outd.  The compress magic
-   header (two bytes) has already been read and verified. */
-local void unlzw(void)
-{
-    int got;                    /* byte just read by GET() */
-    int chunk;                  /* bytes left in current chunk */
-    int left;                   /* bits left in rem */
-    unsigned rem;               /* unused bits from input */
-    int bits;                   /* current bits per code */
-    unsigned code;              /* code, table traversal index */
-    unsigned mask;              /* mask for current bits codes */
-    int max;                    /* maximum bits per code for this stream */
-    int flags;                  /* compress flags, then block compress flag */
-    unsigned end;               /* last valid entry in prefix/suffix tables */
-    unsigned temp;              /* current code */
-    unsigned prev;              /* previous code */
-    unsigned final;             /* last character written for previous code */
-    unsigned stack;             /* next position for reversed string */
-    unsigned outcnt;            /* bytes in output buffer */
-    unsigned char *p;
-
-    /* process remainder of compress header -- a flags byte */
-    out_tot = 0;
-    flags = GET();
-    if (in_eof)
-        bail(&quot;missing lzw data: &quot;, in);
-    if (flags &amp; 0x60)
-        bail(&quot;unknown lzw flags set: &quot;, in);
-    max = flags &amp; 0x1f;
-    if (max &lt; 9 || max &gt; 16)
-        bail(&quot;lzw bits out of range: &quot;, in);
-    if (max == 9)                           /* 9 doesn't really mean 9 */
-        max = 10;
-    flags &amp;= 0x80;                          /* true if block compress */
-
-    /* clear table */
-    bits = 9;
-    mask = 0x1ff;
-    end = flags ? 256 : 255;
-
-    /* set up: get first 9-bit code, which is the first decompressed byte, but
-       don't create a table entry until the next code */
-    got = GET();
-    if (in_eof)                             /* no compressed data is ok */
-        return;
-    final = prev = (unsigned)got;           /* low 8 bits of code */
-    got = GET();
-    if (in_eof || (got &amp; 1) != 0)           /* missing a bit or code &gt;= 256 */
-        bail(&quot;invalid lzw code: &quot;, in);
-    rem = (unsigned)got &gt;&gt; 1;               /* remaining 7 bits */
-    left = 7;
-    chunk = bits - 2;                       /* 7 bytes left in this chunk */
-    out_buf[0] = (unsigned char)final;      /* write first decompressed byte */
-    outcnt = 1;
-
-    /* decode codes */
-    stack = 0;
-    for (;;) {
-        /* if the table will be full after this, increment the code size */
-        if (end &gt;= mask &amp;&amp; bits &lt; max) {
-            FLUSHCODE();
-            bits++;
-            mask &lt;&lt;= 1;
-            mask++;
-        }
-
-        /* get a code of length bits */
-        if (chunk == 0)                     /* decrement chunk modulo bits */
-            chunk = bits;
-        code = rem;                         /* low bits of code */
-        got = GET();
-        if (in_eof) {                       /* EOF is end of compressed data */
-            /* write remaining buffered output */
-            out_tot += outcnt;
-            if (outcnt &amp;&amp; decode == 1)
-                writen(outd, out_buf, outcnt);
-            return;
-        }
-        code += (unsigned)got &lt;&lt; left;      /* middle (or high) bits of code */
-        left += 8;
-        chunk--;
-        if (bits &gt; left) {                  /* need more bits */
-            got = GET();
-            if (in_eof)                     /* can't end in middle of code */
-                bail(&quot;invalid lzw code: &quot;, in);
-            code += (unsigned)got &lt;&lt; left;  /* high bits of code */
-            left += 8;
-            chunk--;
-        }
-        code &amp;= mask;                       /* mask to current code length */
-        left -= bits;                       /* number of unused bits */
-        rem = (unsigned)got &gt;&gt; (8 - left);  /* unused bits from last byte */
-
-        /* process clear code (256) */
-        if (code == 256 &amp;&amp; flags) {
-            FLUSHCODE();
-            bits = 9;                       /* initialize bits and mask */
-            mask = 0x1ff;
-            end = 255;                      /* empty table */
-            continue;                       /* get next code */
-        }
-
-        /* special code to reuse last match */
-        temp = code;                        /* save the current code */
-        if (code &gt; end) {
-            /* Be picky on the allowed code here, and make sure that the code
-               we drop through (prev) will be a valid index so that random
-               input does not cause an exception.  The code != end + 1 check is
-               empirically derived, and not checked in the original uncompress
-               code.  If this ever causes a problem, that check could be safely
-               removed.  Leaving this check in greatly improves pigz's ability
-               to detect random or corrupted input after a compress header.
-               In any case, the prev &gt; end check must be retained. */
-            if (code != end + 1 || prev &gt; end)
-                bail(&quot;invalid lzw code: &quot;, in);
-            match[stack++] = (unsigned char)final;
-            code = prev;
-        }
-
-        /* walk through linked list to generate output in reverse order */
-        p = match + stack;
-        while (code &gt;= 256) {
-            *p++ = suffix[code];
-            code = prefix[code];
-        }
-        stack = p - match;
-        match[stack++] = (unsigned char)code;
-        final = code;
-
-        /* link new table entry */
-        if (end &lt; mask) {
-            end++;
-            prefix[end] = (unsigned short)prev;
-            suffix[end] = (unsigned char)final;
-        }
-
-        /* set previous code for next iteration */
-        prev = temp;
-
-        /* write output in forward order */
-        while (stack &gt; OUTSIZE - outcnt) {
-            while (outcnt &lt; OUTSIZE)
-                out_buf[outcnt++] = match[--stack];
-            out_tot += outcnt;
-            if (decode == 1)
-                writen(outd, out_buf, outcnt);
-            outcnt = 0;
-        }
-        p = match + stack;
-        do {
-            out_buf[outcnt++] = *--p;
-        } while (p &gt; match);
-        stack = 0;
-
-        /* loop for next code with final and prev as the last match, rem and
-           left provide the first 0..7 bits of the next code, end is the last
-           valid table entry */
-    }
-}
-
-/* --- file processing --- */
-
-/* extract file name from path */
-local char *justname(char *path)
-{
-    char *p;
-
-    p = path + strlen(path);
-    while (--p &gt;= path)
-        if (*p == '/')
-            break;
-    return p + 1;
-}
-
-/* Copy file attributes, from -&gt; to, as best we can.  This is best effort, so
-   no errors are reported.  The mode bits, including suid, sgid, and the sticky
-   bit are copied (if allowed), the owner's user id and group id are copied
-   (again if allowed), and the access and modify times are copied. */
-local void copymeta(char *from, char *to)
-{
-    struct stat st;
-    struct timeval times[2];
-
-    /* get all of from's Unix meta data, return if not a regular file */
-    if (stat(from, &amp;st) != 0 || (st.st_mode &amp; S_IFMT) != S_IFREG)
-        return;
-
-    /* set to's mode bits, ignore errors */
-    chmod(to, st.st_mode &amp; 07777);
-
-    /* copy owner's user and group, ignore errors */
-    chown(to, st.st_uid, st.st_gid);
-
-    /* copy access and modify times, ignore errors */
-    times[0].tv_sec = st.st_atime;
-    times[0].tv_usec = 0;
-    times[1].tv_sec = st.st_mtime;
-    times[1].tv_usec = 0;
-    utimes(to, times);
-}
-
-/* set the access and modify times of fd to t */
-local void touch(char *path, time_t t)
-{
-    struct timeval times[2];
-
-    times[0].tv_sec = t;
-    times[0].tv_usec = 0;
-    times[1].tv_sec = t;
-    times[1].tv_usec = 0;
-    utimes(path, times);
-}
-
-/* process provided input file, or stdin if path is NULL -- process() can
-   call itself for recursive directory processing */
-local void process(char *path)
-{
-    int method = -1;                /* get_header() return value */
-    size_t len;                     /* length of base name (minus suffix) */
-    struct stat st;                 /* to get file type and mod time */
-
-    /* open input file with name in, descriptor ind -- set name and mtime */
-    if (path == NULL) {
-        strcpy(in, &quot;&lt;stdin&gt;&quot;);
-        ind = 0;
-        name = NULL;
-        mtime = headis &amp; 2 ?
-                (fstat(ind, &amp;st) ? time(NULL) : st.st_mtime) : 0;
-        len = 0;
-    }
-    else {
-        /* set input file name (already set if recursed here) */
-        if (path != in) {
-            strncpy(in, path, sizeof(in));
-            if (in[sizeof(in) - 1])
-                bail(&quot;name too long: &quot;, path);
-        }
-        len = strlen(in);
-
-        /* only process regular files, but allow symbolic links if -f,
-           recurse into directory if -r */
-        if (lstat(in, &amp;st)) {
-#ifdef EOVERFLOW
-            if (errno == EOVERFLOW || errno == EFBIG)
-                bail(in,
-                    &quot; too large -- pigz not compiled with large file support&quot;);
-#endif
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s does not exist -- skipping\n&quot;, in);
-            return;
-        }
-        if ((st.st_mode &amp; S_IFMT) != S_IFREG &amp;&amp;
-            (st.st_mode &amp; S_IFMT) != S_IFLNK &amp;&amp;
-            (st.st_mode &amp; S_IFMT) != S_IFDIR) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s is a special file or device -- skipping\n&quot;,
-                        in);
-            return;
-        }
-        if ((st.st_mode &amp; S_IFMT) == S_IFLNK &amp;&amp; !force) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s is a symbolic link -- skipping\n&quot;, in);
-            return;
-        }
-        if ((st.st_mode &amp; S_IFMT) == S_IFDIR &amp;&amp; !recurse) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s is a directory -- skipping\n&quot;, in);
-            return;
-        }
-
-        /* recurse into directory (assumes Unix) */
-        if ((st.st_mode &amp; S_IFMT) == S_IFDIR) {
-            char *roll, *item, *cut, *base, *bigger;
-            size_t len, hold;
-            DIR *here;
-            struct dirent *next;
-
-            /* accumulate list of entries (need to do this, since readdir()
-               behavior not defined if directory modified between calls) */
-            here = opendir(in);
-            if (here == NULL)
-                return;
-            hold = 512;
-            roll = malloc(hold);
-            if (roll == NULL)
-                bail(&quot;not enough memory&quot;, &quot;&quot;);
-            *roll = 0;
-            item = roll;
-            while ((next = readdir(here)) != NULL) {
-                if (next-&gt;d_name[0] == 0 ||
-                    (next-&gt;d_name[0] == '.' &amp;&amp; (next-&gt;d_name[1] == 0 ||
-                     (next-&gt;d_name[1] == '.' &amp;&amp; next-&gt;d_name[2] == 0))))
-                    continue;
-                len = strlen(next-&gt;d_name) + 1;
-                if (item + len + 1 &gt; roll + hold) {
-                    do {                    /* make roll bigger */
-                        hold &lt;&lt;= 1;
-                    } while (item + len + 1 &gt; roll + hold);
-                    bigger = realloc(roll, hold);
-                    if (bigger == NULL) {
-                        free(roll);
-                        bail(&quot;not enough memory&quot;, &quot;&quot;);
-                    }
-                    item = bigger + (item - roll);
-                    roll = bigger;
-                }
-                strcpy(item, next-&gt;d_name);
-                item += len;
-                *item = 0;
-            }
-            closedir(here);
-
-            /* run process() for each entry in the directory */
-            cut = base = in + strlen(in);
-            if (base &gt; in &amp;&amp; base[-1] != '/') {
-                if (base - in &gt;= sizeof(in))
-                    bail(&quot;path too long&quot;, in);
-                *base++ = '/';
-            }
-            item = roll;
-            while (*item) {
-                strncpy(base, item, sizeof(in) - (base - in));
-                if (in[sizeof(in) - 1]) {
-                    strcpy(in + (sizeof(in) - 4), &quot;...&quot;);
-                    bail(&quot;path too long: &quot;, in);
-                }
-                process(in);
-                item += strlen(item) + 1;
-            }
-            *cut = 0;
-
-            /* release list of entries */
-            free(roll);
-            return;
-        }
-
-        /* don't compress .gz (or provided suffix) files, unless -f */
-        if (!(force || list || decode) &amp;&amp; len &gt;= strlen(sufx) &amp;&amp;
-                strcmp(in + len - strlen(sufx), sufx) == 0) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s ends with %s -- skipping\n&quot;, in, sufx);
-            return;
-        }
-
-        /* only decompress or list files with compressed suffix */
-        if (list || decode) {
-            int suf = compressed_suffix(in);
-            if (suf == 0) {
-                if (verbosity &gt; 0)
-                    fprintf(stderr,
-                            &quot;%s does not have compressed suffix -- skipping\n&quot;,
-                            in);
-                return;
-            }
-            len -= suf;
-        }
-
-        /* open input file */
-        ind = open(in, O_RDONLY, 0);
-        if (ind &lt; 0)
-            bail(&quot;read error on &quot;, in);
-
-        /* prepare gzip header information for compression */
-        name = headis &amp; 1 ? justname(in) : NULL;
-        mtime = headis &amp; 2 ? st.st_mtime : 0;
-    }
-    SET_BINARY_MODE(ind);
-
-    /* if decoding or testing, try to read gzip header */
-    hname = NULL;
-    if (decode) {
-        in_init();
-        method = get_header(1);
-        if (method != 8 &amp;&amp; method != 256) {
-            RELEASE(hname);
-            if (ind != 0)
-                close(ind);
-            if (method != -1 &amp;&amp; verbosity &gt; 0)
-                fprintf(stderr,
-                    method &lt; 0 ? &quot;%s is not compressed -- skipping\n&quot; :
-                        &quot;%s has unknown compression method -- skipping\n&quot;,
-                    in);
-            return;
-        }
-
-        /* if requested, test input file (possibly a special list) */
-        if (decode == 2) {
-            if (method == 8)
-                infchk();
-            else {
-                unlzw();
-                if (list) {
-                    in_tot -= 3;
-                    show_info(method, 0, out_tot, 0);
-                }
-            }
-            RELEASE(hname);
-            if (ind != 0)
-                close(ind);
-            return;
-        }
-    }
-
-    /* if requested, just list information about input file */
-    if (list) {
-        list_info();
-        RELEASE(hname);
-        if (ind != 0)
-            close(ind);
-        return;
-    }
-
-    /* create output file out, descriptor outd */
-    if (path == NULL || pipeout) {
-        /* write to stdout */
-        out = malloc(strlen(&quot;&lt;stdout&gt;&quot;) + 1);
-        if (out == NULL)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-        strcpy(out, &quot;&lt;stdout&gt;&quot;);
-        outd = 1;
-        if (!decode &amp;&amp; !force &amp;&amp; isatty(outd))
-            bail(&quot;trying to write compressed data to a terminal&quot;,
-                 &quot; (use -f to force)&quot;);
-    }
-    else {
-        char *to;
-
-        /* use header name for output when decompressing with -N */
-        to = in;
-        if (decode &amp;&amp; (headis &amp; 1) != 0 &amp;&amp; hname != NULL) {
-            to = hname;
-            len = strlen(hname);
-        }
-
-        /* create output file and open to write */
-        out = malloc(len + (decode ? 0 : strlen(sufx)) + 1);
-        if (out == NULL)
-            bail(&quot;not enough memory&quot;, &quot;&quot;);
-        memcpy(out, to, len);
-        strcpy(out + len, decode ? &quot;&quot; : sufx);
-        outd = open(out, O_CREAT | O_TRUNC | O_WRONLY |
-                         (force ? 0 : O_EXCL), 0666);
-
-        /* if exists and not -f, give user a chance to overwrite */
-        if (outd &lt; 0 &amp;&amp; errno == EEXIST &amp;&amp; isatty(0) &amp;&amp; verbosity) {
-            int ch, reply;
-
-            fprintf(stderr, &quot;%s exists -- overwrite (y/n)? &quot;, out);
-            fflush(stderr);
-            reply = -1;
-            do {
-                ch = getchar();
-                if (reply &lt; 0 &amp;&amp; ch != ' ' &amp;&amp; ch != '\t')
-                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
-            } while (ch != EOF &amp;&amp; ch != '\n' &amp;&amp; ch != '\r');
-            if (reply == 1)
-                outd = open(out, O_CREAT | O_TRUNC | O_WRONLY,
-                            0666);
-        }
-
-        /* if exists and no overwrite, report and go on to next */
-        if (outd &lt; 0 &amp;&amp; errno == EEXIST) {
-            if (verbosity &gt; 0)
-                fprintf(stderr, &quot;%s exists -- skipping\n&quot;, out);
-            RELEASE(out);
-            RELEASE(hname);
-            if (ind != 0)
-                close(ind);
-            return;
-        }
-
-        /* if some other error, give up */
-        if (outd &lt; 0)
-            bail(&quot;write error on &quot;, out);
-    }
-    SET_BINARY_MODE(outd);
-    RELEASE(hname);
-
-    /* process ind to outd */
-    if (verbosity &gt; 1)
-        fprintf(stderr, &quot;%s to %s &quot;, in, out);
-    if (decode) {
-        if (method == 8)
-            infchk();
-        else
-            unlzw();
-    }
-#ifndef NOTHREAD
-    else if (procs &gt; 1)
-        parallel_compress();
-#endif
-    else
-        single_compress(0);
-    if (verbosity &gt; 1) {
-        putc('\n', stderr);
-        fflush(stderr);
-    }
-
-    /* finish up, copy attributes, set times, delete original */
-    if (ind != 0)
-        close(ind);
-    if (outd != 1) {
-        if (close(outd))
-            bail(&quot;write error on &quot;, out);
-        outd = -1;              /* now prevent deletion on interrupt */
-        if (ind != 0) {
-            copymeta(in, out);
-            if (!keep)
-                unlink(in);
-        }
-        if (decode &amp;&amp; (headis &amp; 2) != 0 &amp;&amp; stamp)
-            touch(out, stamp);
-    }
-    RELEASE(out);
-}
-
-local char *helptext[] = {
-&quot;Usage: pigz [options] [files ...]&quot;,
-&quot;  will compress files in place, adding the suffix '.gz'.  If no files are&quot;,
-#ifdef NOTHREAD
-&quot;  specified, stdin will be compressed to stdout.  pigz does what gzip does.&quot;,
-#else
-&quot;  specified, stdin will be compressed to stdout.  pigz does what gzip does,&quot;,
-&quot;  but spreads the work over multiple processors and cores when compressing.&quot;,
-#endif
-&quot;&quot;,
-&quot;Options:&quot;,
-&quot;  -0 to -9, --fast, --best   Compression levels, --fast is -1, --best is -9&quot;,
-&quot;  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)&quot;,
-#ifndef NOTHREAD
-&quot;  -p, --processes n    Allow up to n compression threads (default 8)&quot;,
-#endif
-&quot;  -i, --independent    Compress blocks independently for damage recovery&quot;,
-&quot;  -R, --rsyncable      Input-determined block locations for rsync&quot;,
-&quot;  -d, --decompress     Decompress the compressed input&quot;,
-&quot;  -t, --test           Test the integrity of the compressed input&quot;,
-&quot;  -l, --list           List the contents of the compressed input&quot;,
-&quot;  -f, --force          Force overwrite, compress .gz, links, and to terminal&quot;,
-&quot;  -r, --recursive      Process the contents of all subdirectories&quot;,
-&quot;  -s, --suffix .sss    Use suffix .sss instead of .gz (for compression)&quot;,
-&quot;  -z, --zlib           Compress to zlib (.zz) instead of gzip format&quot;,
-&quot;  -K, --zip            Compress to PKWare zip (.zip) single entry format&quot;,
-&quot;  -k, --keep           Do not delete original file after processing&quot;,
-&quot;  -c, --stdout         Write all processed output to stdout (won't delete)&quot;,
-&quot;  -N, --name           Store/restore file name and mod time in/from header&quot;,
-&quot;  -n, --no-name        Do not store or restore file name in/from header&quot;,
-&quot;  -T, --no-time        Do not store or restore mod time in/from header&quot;,
-&quot;  -q, --quiet          Print no messages, even on error&quot;,
-#ifdef DEBUG
-&quot;  -v, --verbose        Provide more verbose output (-vv to debug)&quot;
-#else
-&quot;  -v, --verbose        Provide more verbose output&quot;
-#endif
-};
-
-/* display the help text above */
-local void help(void)
-{
-    int n;
-
-    if (verbosity == 0)
-        return;
-    for (n = 0; n &lt; sizeof(helptext) / sizeof(char *); n++)
-        fprintf(stderr, &quot;%s\n&quot;, helptext[n]);
-    fflush(stderr);
-    exit(0);
-}
-
-/* set option defaults */
-local void defaults(void)
-{
-    level = Z_DEFAULT_COMPRESSION;
-#ifdef NOTHREAD
-    procs = 1;
-#else
-    procs = 8;
-#endif
-    size = 131072UL;
-    rsync = 0;                      /* don't do rsync blocking */
-    dict = 1;                       /* initialize dictionary each thread */
-    verbosity = 1;                  /* normal message level */
-    headis = 3;                     /* store/restore name and timestamp */
-    pipeout = 0;                    /* don't force output to stdout */
-    sufx = &quot;.gz&quot;;                   /* compressed file suffix */
-    decode = 0;                     /* compress */
-    list = 0;                       /* compress */
-    keep = 0;                       /* delete input file once compressed */
-    force = 0;                      /* don't overwrite, don't compress links */
-    recurse = 0;                    /* don't go into directories */
-    form = 0;                       /* use gzip format */
-}
-
-/* long options conversion to short options */
-local char *longopts[][2] = {
-    {&quot;LZW&quot;, &quot;Z&quot;}, {&quot;ascii&quot;, &quot;a&quot;}, {&quot;best&quot;, &quot;9&quot;}, {&quot;bits&quot;, &quot;Z&quot;},
-    {&quot;blocksize&quot;, &quot;b&quot;}, {&quot;decompress&quot;, &quot;d&quot;}, {&quot;fast&quot;, &quot;1&quot;}, {&quot;force&quot;, &quot;f&quot;},
-    {&quot;help&quot;, &quot;h&quot;}, {&quot;independent&quot;, &quot;i&quot;}, {&quot;keep&quot;, &quot;k&quot;}, {&quot;license&quot;, &quot;L&quot;},
-    {&quot;list&quot;, &quot;l&quot;}, {&quot;name&quot;, &quot;N&quot;}, {&quot;no-name&quot;, &quot;n&quot;}, {&quot;no-time&quot;, &quot;T&quot;},
-    {&quot;processes&quot;, &quot;p&quot;}, {&quot;quiet&quot;, &quot;q&quot;}, {&quot;recursive&quot;, &quot;r&quot;}, {&quot;rsyncable&quot;, &quot;R&quot;},
-    {&quot;silent&quot;, &quot;q&quot;}, {&quot;stdout&quot;, &quot;c&quot;}, {&quot;suffix&quot;, &quot;s&quot;}, {&quot;test&quot;, &quot;t&quot;},
-    {&quot;to-stdout&quot;, &quot;c&quot;}, {&quot;uncompress&quot;, &quot;d&quot;}, {&quot;verbose&quot;, &quot;v&quot;},
-    {&quot;version&quot;, &quot;V&quot;}, {&quot;zip&quot;, &quot;K&quot;}, {&quot;zlib&quot;, &quot;z&quot;}};
-#define NLOPTS (sizeof(longopts) / (sizeof(char *) &lt;&lt; 1))
-
-/* either new buffer size, new compression level, or new number of processes --
-   get rid of old buffers and threads to force the creation of new ones with
-   the new settings */
-local void new_opts(void)
-{
-    single_compress(1);
-#ifndef NOTHREAD
-    finish_jobs();
-#endif
-}
-
-/* process an option, return true if a file name and not an option */
-local int option(char *arg)
-{
-    static int get = 0;
-
-    /* if no argument, check status of get */
-    if (arg == NULL) {
-        if (get)
-            bail(&quot;missing option argument for -&quot;,
-                 get &amp; 1 ? &quot;b&quot; : (get &amp; 2 ? &quot;p&quot; : &quot;s&quot;));
-        return 0;
-    }
-
-    /* process long option or short options */
-    if (*arg == '-') {
-        if (get)
-            bail(&quot;require parameter after -&quot;,
-                 get &amp; 1 ? &quot;b&quot; : (get &amp; 2 ? &quot;p&quot; : &quot;s&quot;));
-        arg++;
-
-        /* a single dash will be interpreted as stdin */
-        if (*arg == 0)
-            return 1;
-
-        /* process long option */
-        if (*arg == '-') {
-            int j;
-
-            arg++;
-            for (j = NLOPTS - 1; j &gt;= 0; j--)
-                if (strcmp(arg, longopts[j][0]) == 0) {
-                    arg = longopts[j][1];
-                    break;
-                }
-            if (j &lt; 0)
-                bail(&quot;invalid option: &quot;, arg - 2);
-        }
-
-        /* process short options */
-        do {
-            switch (*arg) {
-            case '0': case '1': case '2': case '3': case '4':
-            case '5': case '6': case '7': case '8': case '9':
-                level = *arg - '0';
-                new_opts();
-                break;
-            case 'K':  form = 2;  sufx = &quot;.zip&quot;;  break;
-            case 'L':
-                fputs(VERSION, stderr);
-                fputs(&quot;Copyright (C) 2007 Mark Adler\n&quot;, stderr);
-                fputs(&quot;Subject to the terms of the zlib license.\n&quot;,
-                      stderr);
-                fputs(&quot;No warranty is provided or implied.\n&quot;, stderr);
-                exit(0);
-            case 'N':  headis = 3;  break;
-            case 'T':  headis &amp;= ~2;  break;
-            case 'R':  rsync = 1;
-                bail(&quot;rsyncable not implemented yet&quot;, &quot;&quot;);
-            case 'V':  fputs(VERSION, stderr);  exit(0);
-            case 'Z':
-                bail(&quot;invalid option: LZW output not supported&quot;, &quot;&quot;);
-            case 'a':
-                bail(&quot;invalid option: ascii conversion not supported&quot;, &quot;&quot;);
-            case 'b':  get |= 1;  break;
-            case 'c':  pipeout = 1;  break;
-            case 'd':  decode = 1;  headis = 0;  break;
-            case 'f':  force = 1;  break;
-            case 'h':  help();  break;
-            case 'i':  dict = 0;  break;
-            case 'k':  keep = 1;  break;
-            case 'l':  list = 1;  break;
-            case 'n':  headis &amp;= ~1;  break;
-            case 'p':  get |= 2;  break;
-            case 'q':  verbosity = 0;  break;
-            case 'r':  recurse = 1;  break;
-            case 's':  get |= 4;  break;
-            case 't':  decode = 2;  break;
-            case 'v':  verbosity++;  break;
-            case 'z':  form = 1;  sufx = &quot;.zz&quot;;  break;
-            default:
-                arg[1] = 0;
-                bail(&quot;invalid option: -&quot;, arg);
-            }
-        } while (*++arg);
-        return 0;
-    }
-
-    /* process option parameter for -b, -p, or -s */
-    if (get) {
-        if (get != 1 &amp;&amp; get != 2 &amp;&amp; get != 4)
-            bail(&quot;you need to separate &quot;,
-                 get == 3 ? &quot;-b and -p&quot; :
-                            (get == 5 ? &quot;-b and -s&quot; : &quot;-p and -s&quot;));
-        if (get == 1) {
-            size = (size_t)(atol(arg)) &lt;&lt; 10;   /* chunk size */
-            if (size &lt; DICT)
-                bail(&quot;block size too small (must be &gt;= 32K)&quot;, &quot;&quot;);
-            if (size + (size &gt;&gt; 11) + 10 &lt; (size &gt;&gt; 11) + 10 ||
-                (ssize_t)(size + (size &gt;&gt; 11) + 10) &lt; 0)
-                bail(&quot;block size too large&quot;, &quot;&quot;);
-            new_opts();
-        }
-        else if (get == 2) {
-            procs = atoi(arg);                  /* # processes */
-            if (procs &lt; 1)
-                bail(&quot;need at least one process&quot;, &quot;&quot;);
-            if ((2 + (procs &lt;&lt; 1)) &lt; 1)
-                bail(&quot;too many processes&quot;, &quot;&quot;);
-#ifdef NOTHREAD
-            if (procs &gt; 1)
-                bail(&quot;this pigz compiled without threads&quot;, &quot;&quot;);
-#endif
-            new_opts();
-        }
-        else if (get == 4)
-            sufx = arg;                         /* gz suffix */
-        get = 0;
-        return 0;
-    }
-
-    /* neither an option nor parameter */
-    return 1;
-}
-
-/* catch termination signal */
-local void cut_short(int sig)
-{
-    Trace((&quot;termination by user&quot;));
-    if (outd != -1 &amp;&amp; out != NULL)
-        unlink(out);
-    log_dump();
-    _exit(1);
-}
-
-/* Process arguments, compress in the gzip format.  Note that procs must be at
-   least two in order to provide a dictionary in one work unit for the other
-   work unit, and that size must be at least 32K to store a full dictionary. */
-int main(int argc, char **argv)
-{
-    int n;                          /* general index */
-    unsigned long done;             /* number of named files processed */
-    char *opts, *p;                 /* environment default options, marker */
-
-    /* prepare for interrupts and logging */
-    signal(SIGINT, cut_short);
-#ifndef NOTHREAD
-    yarn_prefix = &quot;pigz&quot;;           /* prefix for yarn error messages */
-    yarn_abort = cut_short;         /* call on thread error */
-#endif
-#ifdef DEBUG
-    gettimeofday(&amp;start, NULL);     /* starting time for log entries */
-    log_init();                     /* initialize logging */
-#endif
-
-    /* set all options to defaults */
-    defaults();
-
-    /* process user environment variable defaults */
-    opts = getenv(&quot;GZIP&quot;);
-    if (opts != NULL) {
-        while (*opts) {
-            while (*opts == ' ' || *opts == '\t')
-                opts++;
-            p = opts;
-            while (*p &amp;&amp; *p != ' ' &amp;&amp; *p != '\t')
-                p++;
-            n = *p;
-            *p = 0;
-            if (option(opts))
-                bail(&quot;cannot provide files in GZIP environment variable&quot;, &quot;&quot;);
-            opts = p + (n ? 1 : 0);
-        }
-        option(NULL);
-    }
-
-    /* if no command line arguments and stdout is a terminal, show help */
-    if (argc &lt; 2 &amp;&amp; isatty(1))
-        help();
-
-    /* process command-line arguments */
-    done = 0;
-    for (n = 1; n &lt; argc; n++)
-        if (option(argv[n])) {          /* true if file name, process it */
-            if (done == 1 &amp;&amp; pipeout &amp;&amp; !decode &amp;&amp; !list &amp;&amp; form &gt; 1) {
-                fprintf(stderr, &quot;warning: output is concatenated zip files &quot;);
-                fprintf(stderr, &quot;-- pigz will not be able to extract\n&quot;);
-            }
-            process(strcmp(argv[n], &quot;-&quot;) ? argv[n] : NULL);
-            done++;
-        }
-    option(NULL);
-
-    /* list stdin or compress stdin to stdout if no file names provided */
-    if (done == 0)
-        process(NULL);
-
-    /* done -- release resources, show log */
-    new_opts();
-    log_dump();
-    return 0;
-}
diff --git a/tools/pigz/yarn.c b/tools/pigz/yarn.c
deleted file mode 100644
index 0562e70..0000000
--- a/tools/pigz/yarn.c
+++ /dev/null
@@ -1,365 +0,0 @@
-/* yarn.c -- generic thread operations implemented using pthread functions
- * Copyright (C) 2008 Mark Adler
- * Version 1.1  26 Oct 2008  Mark Adler
- * For conditions of distribution and use, see copyright notice in yarn.h
- */
-
-/* Basic thread operations implemented using the POSIX pthread library.  All
-   pthread references are isolated within this module to allow alternate
-   implementations with other thread libraries.  See yarn.h for the description
-   of these operations. */
-
-/* Version history:
-   1.0    19 Oct 2008  First version
-   1.1    26 Oct 2008  No need to set the stack size -- remove
-                       Add yarn_abort() function for clean-up on error exit
- */
-
-/* for thread portability */
-#define _POSIX_PTHREAD_SEMANTICS
-#define _REENTRANT
-
-/* external libraries and entities referenced */
-#include &lt;stdio.h&gt;      /* fprintf(), stderr */
-#include &lt;stdlib.h&gt;     /* exit(), malloc(), free(), NULL */
-#include &lt;pthread.h&gt;    /* pthread_t, pthread_create(), pthread_join(), */
-    /* pthread_attr_t, pthread_attr_init(), pthread_attr_destroy(),
-       PTHREAD_CREATE_JOINABLE, pthread_attr_setdetachstate(),
-       pthread_self(), pthread_equal(),
-       pthread_mutex_t, PTHREAD_MUTEX_INITIALIZER, pthread_mutex_init(),
-       pthread_mutex_lock(), pthread_mutex_unlock(), pthread_mutex_destroy(),
-       pthread_cond_t, PTHREAD_COND_INITIALIZER, pthread_cond_init(),
-       pthread_cond_broadcast(), pthread_cond_wait(), pthread_cond_destroy() */
-#include &lt;errno.h&gt;      /* ENOMEM, EAGAIN, EINVAL */
-
-/* interface definition */
-#include &quot;yarn.h&quot;
-
-/* constants */
-#define local static            /* for non-exported functions and globals */
-
-/* error handling external globals, resettable by application */
-char *yarn_prefix = &quot;yarn&quot;;
-void (*yarn_abort)(int) = NULL;
-
-
-/* immediately exit -- use for errors that shouldn't ever happen */
-local void fail(int err)
-{
-    fprintf(stderr, &quot;%s: %s (%d) -- aborting\n&quot;, yarn_prefix,
-            err == ENOMEM ? &quot;out of memory&quot; : &quot;internal pthread error&quot;, err);
-    if (yarn_abort != NULL)
-        yarn_abort(err);
-    exit(err == ENOMEM || err == EAGAIN ? err : EINVAL);
-}
-
-/* memory handling routines provided by user -- if none are provided, malloc()
-   and free() are used, which are therefore assumed to be thread-safe */
-typedef void *(*malloc_t)(size_t);
-typedef void (*free_t)(void *);
-local malloc_t my_malloc_f = malloc;
-local free_t my_free = free;
-
-/* use user-supplied allocation routines instead of malloc() and free() */
-void yarn_mem(malloc_t lease, free_t vacate)
-{
-    my_malloc_f = lease;
-    my_free = vacate;
-}
-
-/* memory allocation that cannot fail (from the point of view of the caller) */
-local void *my_malloc(size_t size)
-{
-    void *block;
-
-    if ((block = my_malloc_f(size)) == NULL)
-        fail(ENOMEM);
-    return block;
-}
-
-/* -- lock functions -- */
-
-struct lock_s {
-    pthread_mutex_t mutex;
-    pthread_cond_t cond;
-    long value;
-};
-
-lock *new_lock(long initial)
-{
-    int ret;
-    lock *bolt;
-
-    bolt = my_malloc(sizeof(struct lock_s));
-    if ((ret = pthread_mutex_init(&amp;(bolt-&gt;mutex), NULL)) ||
-        (ret = pthread_cond_init(&amp;(bolt-&gt;cond), NULL)))
-        fail(ret);
-    bolt-&gt;value = initial;
-    return bolt;
-}
-
-void possess(lock *bolt)
-{
-    int ret;
-
-    if ((ret = pthread_mutex_lock(&amp;(bolt-&gt;mutex))) != 0)
-        fail(ret);
-}
-
-void release(lock *bolt)
-{
-    int ret;
-
-    if ((ret = pthread_mutex_unlock(&amp;(bolt-&gt;mutex))) != 0)
-        fail(ret);
-}
-
-void twist(lock *bolt, enum twist_op op, long val)
-{
-    int ret;
-
-    if (op == TO)
-        bolt-&gt;value = val;
-    else if (op == BY)
-        bolt-&gt;value += val;
-    if ((ret = pthread_cond_broadcast(&amp;(bolt-&gt;cond))) ||
-        (ret = pthread_mutex_unlock(&amp;(bolt-&gt;mutex))))
-        fail(ret);
-}
-
-#define until(a) while(!(a))
-
-void wait_for(lock *bolt, enum wait_op op, long val)
-{
-    int ret;
-
-    switch (op) {
-    case TO_BE:
-        until (bolt-&gt;value == val)
-            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
-                fail(ret);
-        break;
-    case NOT_TO_BE:
-        until (bolt-&gt;value != val)
-            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
-                fail(ret);
-        break;
-    case TO_BE_MORE_THAN:
-        until (bolt-&gt;value &gt; val)
-            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
-                fail(ret);
-        break;
-    case TO_BE_LESS_THAN:
-        until (bolt-&gt;value &lt; val)
-            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
-                fail(ret);
-    }
-}
-
-long peek_lock(lock *bolt)
-{
-    return bolt-&gt;value;
-}
-
-void free_lock(lock *bolt)
-{
-    int ret;
-    if ((ret = pthread_cond_destroy(&amp;(bolt-&gt;cond))) ||
-        (ret = pthread_mutex_destroy(&amp;(bolt-&gt;mutex))))
-        fail(ret);
-    my_free(bolt);
-}
-
-/* -- thread functions (uses lock functions above) -- */
-
-struct thread_s {
-    pthread_t id;
-    int done;                   /* true if this thread has exited */
-    thread *next;               /* for list of all launched threads */
-};
-
-/* list of threads launched but not joined, count of threads exited but not
-   joined (incremented by ignition() just before exiting) */
-local lock threads_lock = {
-    PTHREAD_MUTEX_INITIALIZER,
-    PTHREAD_COND_INITIALIZER,
-    0                           /* number of threads exited but not joined */
-};
-local thread *threads = NULL;       /* list of extant threads */
-
-/* structure in which to pass the probe and its payload to ignition() */
-struct capsule {
-    void (*probe)(void *);
-    void *payload;
-};
-
-/* mark the calling thread as done and alert join_all() */
-local void reenter(void *dummy)
-{
-    thread *match, **prior;
-    pthread_t me;
-
-    /* find this thread in the threads list by matching the thread id */
-    me = pthread_self();
-    possess(&amp;(threads_lock));
-    prior = &amp;(threads);
-    while ((match = *prior) != NULL) {
-        if (pthread_equal(match-&gt;id, me))
-            break;
-        prior = &amp;(match-&gt;next);
-    }
-    if (match == NULL)
-        fail(EINVAL);
-
-    /* mark this thread as done and move it to the head of the list */
-    match-&gt;done = 1;
-    if (threads != match) {
-        *prior = match-&gt;next;
-        match-&gt;next = threads;
-        threads = match;
-    }
-
-    /* update the count of threads to be joined and alert join_all() */
-    twist(&amp;(threads_lock), BY, +1);
-}
-
-/* all threads go through this routine so that just before the thread exits,
-   it marks itself as done in the threads list and alerts join_all() so that
-   the thread resources can be released -- use cleanup stack so that the
-   marking occurs even if the thread is cancelled */
-local void *ignition(void *arg)
-{
-    struct capsule *capsule = arg;
-
-    /* run reenter() before leaving */
-    pthread_cleanup_push(reenter, NULL);
-
-    /* execute the requested function with argument */
-    capsule-&gt;probe(capsule-&gt;payload);
-    my_free(capsule);
-
-    /* mark this thread as done and let join_all() know */
-    pthread_cleanup_pop(1);
-
-    /* exit thread */
-    return NULL;
-}
-
-/* not all POSIX implementations create threads as joinable by default, so that
-   is made explicit here */
-thread *launch(void (*probe)(void *), void *payload)
-{
-    int ret;
-    thread *th;
-    struct capsule *capsule;
-    pthread_attr_t attr;
-
-    /* construct the requested call and argument for the ignition() routine
-       (allocated instead of automatic so that we're sure this will still be
-       there when ignition() actually starts up -- ignition() will free this
-       allocation) */
-    capsule = my_malloc(sizeof(struct capsule));
-    capsule-&gt;probe = probe;
-    capsule-&gt;payload = payload;
-
-    /* assure this thread is in the list before join_all() or ignition() looks
-       for it */
-    possess(&amp;(threads_lock));
-
-    /* create the thread and call ignition() from that thread */
-    th = my_malloc(sizeof(struct thread_s));
-    if ((ret = pthread_attr_init(&amp;attr)) ||
-        (ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE)) ||
-        (ret = pthread_create(&amp;(th-&gt;id), &amp;attr, ignition, capsule)) ||
-        (ret = pthread_attr_destroy(&amp;attr)))
-        fail(ret);
-
-    /* put the thread in the threads list for join_all() */
-    th-&gt;done = 0;
-    th-&gt;next = threads;
-    threads = th;
-    release(&amp;(threads_lock));
-    return th;
-}
-
-void join(thread *ally)
-{
-    int ret;
-    thread *match, **prior;
-
-    /* wait for thread to exit and return its resources */
-    if ((ret = pthread_join(ally-&gt;id, NULL)) != 0)
-        fail(ret);
-
-    /* find the thread in the threads list */
-    possess(&amp;(threads_lock));
-    prior = &amp;(threads);
-    while ((match = *prior) != NULL) {
-        if (match == ally)
-            break;
-        prior = &amp;(match-&gt;next);
-    }
-    if (match == NULL)
-        fail(EINVAL);
-
-    /* remove thread from list and update exited count, free thread */
-    if (match-&gt;done)
-        threads_lock.value--;
-    *prior = match-&gt;next;
-    release(&amp;(threads_lock));
-    my_free(ally);
-}
-
-/* This implementation of join_all() only attempts to join threads that have
-   announced that they have exited (see ignition()).  When there are many
-   threads, this is faster than waiting for some random thread to exit while a
-   bunch of other threads have already exited. */
-int join_all(void)
-{
-    int ret, count;
-    thread *match, **prior;
-
-    /* grab the threads list and initialize the joined count */
-    count = 0;
-    possess(&amp;(threads_lock));
-
-    /* do until threads list is empty */
-    while (threads != NULL) {
-        /* wait until at least one thread has reentered */
-        wait_for(&amp;(threads_lock), NOT_TO_BE, 0);
-
-        /* find the first thread marked done (should be at or near the top) */
-        prior = &amp;(threads);
-        while ((match = *prior) != NULL) {
-            if (match-&gt;done)
-                break;
-            prior = &amp;(match-&gt;next);
-        }
-        if (match == NULL)
-            fail(EINVAL);
-
-        /* join the thread (will be almost immediate), remove from the threads
-           list, update the reenter count, and free the thread */
-        if ((ret = pthread_join(match-&gt;id, NULL)) != 0)
-            fail(ret);
-        threads_lock.value--;
-        *prior = match-&gt;next;
-        my_free(match);
-        count++;
-    }
-
-    /* let go of the threads list and return the number of threads joined */
-    release(&amp;(threads_lock));
-    return count;
-}
-
-/* cancel and join the thread -- the thread will cancel when it gets to a file
-   operation, a sleep or pause, or a condition wait */
-void destruct(thread *off_course)
-{
-    int ret;
-
-    if ((ret = pthread_cancel(off_course-&gt;id)) != 0)
-        fail(ret);
-    join(off_course);
-}
diff --git a/tools/pigz/yarn.h b/tools/pigz/yarn.h
deleted file mode 100644
index 7d99c7a..0000000
--- a/tools/pigz/yarn.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* yarn.h -- generic interface for thread operations
- * Copyright (C) 2008 Mark Adler
- * Version 1.1  26 Oct 2008  Mark Adler
- */
-
-/*
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler
-  <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
- */
-
-/* Basic thread operations
-
-   This interface isolates the local operating system implementation of threads
-   from the application in order to facilitate platform independent use of
-   threads.  All of the implementation details are deliberately hidden.
-
-   Assuming adequate system resources and proper use, none of these functions
-   can fail.  As a result, any errors encountered will cause an exit() to be
-   executed.
-
-   These functions allow the simple launching and joining of threads, and the
-   locking of objects and synchronization of changes of objects.  The latter is
-   implemented with a single lock type that contains an integer value.  The
-   value can be ignored for simple exclusive access to an object, or the value
-   can be used to signal and wait for changes to an object.
-
-   -- Arguments --
-
-   thread *thread;          identifier for launched thread, used by join
-   void probe(void *);      pointer to function &quot;probe&quot;, run when thread starts
-   void *payload;           single argument passed to the probe function
-   lock *lock;              a lock with a value -- used for exclusive access to
-                            an object and to synchronize threads waiting for
-                            changes to an object
-   long val;                value to set lock, increment lock, or wait for
-   int n;                   number of threads joined
-
-   -- Thread functions --
-
-   thread = launch(probe, payload) - launch a thread -- exit via probe() return
-   join(thread) - join a thread and by joining end it, waiting for the thread
-        to exit if it hasn't already -- will free the resources allocated by
-        launch() (don't try to join the same thread more than once)
-   n = join_all() - join all threads launched by launch() that are not joined
-        yet and free the resources allocated by the launches, usually to clean
-        up when the thread processing is done -- join_all() returns an int with
-        the count of the number of threads joined (join_all() should only be
-        called from the main thread, and should only be called after any calls
-        of join() have completed)
-   destruct(thread) - terminate the thread in mid-execution and join it
-        (depending on the implementation, the termination may not be immediate,
-        but may wait for the thread to execute certain thread or file i/o
-        operations)
-
-   -- Lock functions --
-
-   lock = new_lock(val) - create a new lock with initial value val (lock is
-        created in the released state)
-   possess(lock) - acquire exclusive possession of a lock, waiting if necessary
-   twist(lock, [TO | BY], val) - set lock to or increment lock by val, signal
-        all threads waiting on this lock and then release the lock -- must
-        possess the lock before calling (twist releases, so don't do a
-        release() after a twist() on the same lock)
-   wait_for(lock, [TO_BE | NOT_TO_BE | TO_BE_MORE_THAN | TO_BE_LESS_THAN], val)
-        - wait on lock value to be, not to be, be greater than, or be less than
-        val -- must possess the lock before calling, will possess the lock on
-        return but the lock is released while waiting to permit other threads
-        to use twist() to change the value and signal the change (so make sure
-        that the object is in a usable state when waiting)
-   release(lock) - release a possessed lock (do not try to release a lock that
-        the current thread does not possess)
-   val = peek_lock(lock) - return the value of the lock (assumes that lock is
-        already possessed, no possess or release is done by peek_lock())
-   free_lock(lock) - free the resources allocated by new_lock() (application
-        must assure that the lock is released before calling free_lock())
-
-   -- Memory allocation ---
-
-   yarn_mem(better_malloc, better_free) - set the memory allocation and free
-        routines for use by the yarn routines where the supplied routines have
-        the same interface and operation as malloc() and free(), and may be
-        provided in order to supply thread-safe memory allocation routines or
-        for any other reason -- by default malloc() and free() will be used
-
-   -- Error control --
-
-   yarn_name - a char pointer to a string that will be the prefix for any error
-        messages that these routines generate before exiting -- if not changed
-        by the application, &quot;yarn&quot; will be used
-   yarn_abort - an external function that will be executed when there is an
-        internal yarn error, due to out of memory or misuse -- this function
-        may exit to abort the application, or if it returns, the yarn error
-        handler will exit (set to NULL by default for no action)
- */
-
-extern char *yarn_prefix;
-extern void (*yarn_abort)(int);
-
-void yarn_mem(void *(*)(size_t), void (*)(void *));
-
-typedef struct thread_s thread;
-thread *launch(void (*)(void *), void *);
-void join(thread *);
-int join_all(void);
-void destruct(thread *);
-
-typedef struct lock_s lock;
-lock *new_lock(long);
-void possess(lock *);
-void release(lock *);
-enum twist_op { TO, BY };
-void twist(lock *, enum twist_op, long);
-enum wait_op {
-    TO_BE, /* or */ NOT_TO_BE, /* that is the question */
-    TO_BE_MORE_THAN, TO_BE_LESS_THAN };
-void wait_for(lock *, enum wait_op, long);
-long peek_lock(lock *);
-void free_lock(lock *);


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001409.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. e9aa9581fd6490c4934ce669f01c347fc03b7b95
</A></li>
	<LI>Next message: <A HREF="001411.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 63a3c26563a32517a0f4eed66c619ab72a79a973
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1410">[ date ]</a>
              <a href="thread.html#1410">[ thread ]</a>
              <a href="subject.html#1410">[ subject ]</a>
              <a href="author.html#1410">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
