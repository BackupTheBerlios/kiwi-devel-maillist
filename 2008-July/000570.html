<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] r1481 - in kiwi-head: . rpm system/boot	system/boot/ix86 system/boot/ix86/isoboot	system/boot/ix86/netboot system/boot/ix86/oemboot	system/boot/ix86/usbboot system/boot/ix86/vmxboot	system/boot/ix86/xenboot system/boot/ppc
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1481%20-%20in%20kiwi-head%3A%20.%20rpm%20system/boot%0A%09system/boot/ix86%20system/boot/ix86/isoboot%0A%09system/boot/ix86/netboot%20system/boot/ix86/oemboot%0A%09system/boot/ix86/usbboot%20system/boot/ix86/vmxboot%0A%09system/boot/ix86/xenboot%20system/boot/ppc&In-Reply-To=%3C200807241042.m6OAgMVg029138%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000565.html">
   <LINK REL="Next"  HREF="000566.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] r1481 - in kiwi-head: . rpm system/boot	system/boot/ix86 system/boot/ix86/isoboot	system/boot/ix86/netboot system/boot/ix86/oemboot	system/boot/ix86/usbboot system/boot/ix86/vmxboot	system/boot/ix86/xenboot system/boot/ppc</H1>
    <B>marcus_schaefer at mail.berlios.de</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1481%20-%20in%20kiwi-head%3A%20.%20rpm%20system/boot%0A%09system/boot/ix86%20system/boot/ix86/isoboot%0A%09system/boot/ix86/netboot%20system/boot/ix86/oemboot%0A%09system/boot/ix86/usbboot%20system/boot/ix86/vmxboot%0A%09system/boot/ix86/xenboot%20system/boot/ppc&In-Reply-To=%3C200807241042.m6OAgMVg029138%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] r1481 - in kiwi-head: . rpm system/boot	system/boot/ix86 system/boot/ix86/isoboot	system/boot/ix86/netboot system/boot/ix86/oemboot	system/boot/ix86/usbboot system/boot/ix86/vmxboot	system/boot/ix86/xenboot system/boot/ppc">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Thu Jul 24 12:42:22 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000565.html">[Kiwi-devel] r1480 - in kiwi-head/doc: . LaTex examples/suse-11.0
</A></li>
        <LI>Next message: <A HREF="000566.html">[Kiwi-devel] r1482 - kiwi-head/system/boot
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#570">[ date ]</a>
              <a href="thread.html#570">[ thread ]</a>
              <a href="subject.html#570">[ subject ]</a>
              <a href="author.html#570">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: marcus_schaefer
Date: 2008-07-24 12:41:47 +0200 (Thu, 24 Jul 2008)
New Revision: 1481

Added:
   kiwi-head/system/boot/ix86/
   kiwi-head/system/boot/ix86/.md5
   kiwi-head/system/boot/ix86/isoboot/
   kiwi-head/system/boot/ix86/netboot/
   kiwi-head/system/boot/ix86/netboot/suse-linuxrc
   kiwi-head/system/boot/ix86/oemboot/
   kiwi-head/system/boot/ix86/oemboot/suse-linuxrc
   kiwi-head/system/boot/ix86/usbboot/
   kiwi-head/system/boot/ix86/usbboot/suse-linuxrc
   kiwi-head/system/boot/ix86/vmxboot/
   kiwi-head/system/boot/ix86/vmxboot/suse-linuxrc
   kiwi-head/system/boot/ix86/xenboot/
   kiwi-head/system/boot/ix86/xenboot/suse-linuxrc
   kiwi-head/system/boot/ppc/
   kiwi-head/system/boot/ppc/.md5
Removed:
   kiwi-head/system/boot/.md5
   kiwi-head/system/boot/isoboot/
   kiwi-head/system/boot/ix86/netboot/suse-linuxrc
   kiwi-head/system/boot/ix86/oemboot/suse-linuxrc
   kiwi-head/system/boot/ix86/usbboot/suse-linuxrc
   kiwi-head/system/boot/ix86/vmxboot/suse-linuxrc
   kiwi-head/system/boot/ix86/xenboot/suse-linuxrc
   kiwi-head/system/boot/netboot/
   kiwi-head/system/boot/oemboot/
   kiwi-head/system/boot/usbboot/
   kiwi-head/system/boot/vmxboot/
   kiwi-head/system/boot/xenboot/
Modified:
   kiwi-head/Makefile
   kiwi-head/rpm/kiwi.changes
   kiwi-head/rpm/kiwi.spec
Log:

- update boot structure to allow other archs too



Modified: kiwi-head/Makefile
===================================================================
--- kiwi-head/Makefile	2008-07-24 10:20:31 UTC (rev 1480)
+++ kiwi-head/Makefile	2008-07-24 10:41:47 UTC (rev 1481)
@@ -4,6 +4,7 @@
 #
 # Makefile for OpenSuSE - KIWI Image System
 # ---
+arch      = `uname -m | grep -q ^i &amp;&amp; echo ix86 || uname -m`
 buildroot = /
 syslinux  = /usr/share/syslinux
 bindlib   = lib
@@ -44,8 +45,8 @@
 	#============================================
 	# create checksum files for boot images...
 	#--------------------------------------------
-	(cd system/boot &amp;&amp; ./.md5)
-	(cd system/boot &amp;&amp; find -type f | grep -v -E &quot;.svn|.test&quot; | xargs chmod u-w)
+	(cd system/boot/${arch} &amp;&amp; ./.md5)
+	(cd system/boot/${arch} &amp;&amp; find -type f | grep -v -E &quot;.svn|.test&quot; | xargs chmod u-w)
 
 	#============================================
 	# build tools
@@ -118,7 +119,7 @@
 	#============================================
 	# Install image descriptions
 	#--------------------------------------------
-	cp -a system/boot/* ${KIWIIMAGE}
+	cp -a system/boot/${arch}/* ${KIWIIMAGE}
 
 	#============================================
 	# Install kiwi repo

Modified: kiwi-head/rpm/kiwi.changes
===================================================================
--- kiwi-head/rpm/kiwi.changes	2008-07-24 10:20:31 UTC (rev 1480)
+++ kiwi-head/rpm/kiwi.changes	2008-07-24 10:41:47 UTC (rev 1481)
@@ -6,6 +6,7 @@
 - fixed KIWIMigrate according to current scheme (bnc #411088)
 - allow redirection of the log messages to a console set
   by the kernel parameter kiwistderr=... (bnc #411304)
+- added suse-11.0 examples and reorganized the doc tree
 - fixed KIWISatSolver queue code and binding
 
 -------------------------------------------------------------------

Modified: kiwi-head/rpm/kiwi.spec
===================================================================
--- kiwi-head/rpm/kiwi.spec	2008-07-24 10:20:31 UTC (rev 1480)
+++ kiwi-head/rpm/kiwi.spec	2008-07-24 10:41:47 UTC (rev 1481)
@@ -346,8 +346,6 @@
 		$RPM_BUILD_ROOT/srv/tftpboot/pxelinux.cfg/default
 fi
 %else
-	# no boot image descriptions for non x86 archs
-	rm -rf $RPM_BUILD_ROOT/%{_datadir}/kiwi/image/*
 	# no PXE boot setup for non x86 archs
 	rm -rf $RPM_BUILD_ROOT/srv/tftpboot
 	rm -rf $RPM_BUILD_ROOT/etc/permissions.d/kiwi

Deleted: kiwi-head/system/boot/.md5
===================================================================
--- kiwi-head/system/boot/.md5	2008-07-24 10:20:31 UTC (rev 1480)
+++ kiwi-head/system/boot/.md5	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,10 +0,0 @@
-#!/bin/bash
-
-for dir in `find -type d`;do
-	if [ -f $dir/config.xml ];then
-		pushd $dir &amp;&gt;/dev/null
-		find -L -type f | grep -v .svn | grep -v .checksum.md5 |\
-			xargs md5sum &gt; .checksum.md5
-		popd &amp;&gt;/dev/null
-	fi
-done

Copied: kiwi-head/system/boot/ix86/.md5 (from rev 1473, kiwi-head/system/boot/.md5)


Property changes on: kiwi-head/system/boot/ix86/.md5
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mergeinfo
   + 

Copied: kiwi-head/system/boot/ix86/isoboot (from rev 1473, kiwi-head/system/boot/isoboot)


Property changes on: kiwi-head/system/boot/ix86/isoboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: kiwi-head/system/boot/ix86/netboot (from rev 1473, kiwi-head/system/boot/netboot)


Property changes on: kiwi-head/system/boot/ix86/netboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: kiwi-head/system/boot/ix86/netboot/suse-linuxrc
===================================================================
--- kiwi-head/system/boot/netboot/suse-linuxrc	2008-07-23 09:16:44 UTC (rev 1473)
+++ kiwi-head/system/boot/ix86/netboot/suse-linuxrc	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,818 +0,0 @@
-#!/bin/bash
-#================
-# FILE          : linuxrc
-#----------------
-# PROJECT       : OpenSuSE KIWI Image System
-# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
-#               :
-# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
-#               :
-# BELONGS TO    : Operating System images
-#               :
-# DESCRIPTION   : This file is changed to become the real
-#               : linuxrc script which is used to prepare the
-#               : operating system for the main image
-#               :
-#               :
-# STATUS        : BETA
-#----------------
-#======================================
-# Exports (General)
-#--------------------------------------
-export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
-export IFS_ORIG=$IFS
-export ARCH=`arch`
-export DEBUG=0
-
-#======================================
-# Exports (Booting)
-#--------------------------------------
-export DOMURD_MODULES=&quot;xennet xenblk&quot;
-export INITRD_MODULES=&quot;reiserfs&quot;
-export LOCAL_BOOT=&quot;no&quot;
-export KERNEL_LIST
-
-#======================================
-# Exports (Alias)
-#--------------------------------------
-export SYSALIAS=&quot;undefined&quot;
-export NAME=0
-
-#======================================
-# Exports (Partitioning)
-#--------------------------------------
-export PART_FILE=&quot;/etc/partition.table&quot;
-export PART_MOUNT
-export PART_DEV
-export PART_COUNT=0
-export PART_NUMBER=0
-export PART_NEED_EXTENDED=0
-export PART_NEED_FILL=0
-export NO_FILE_SYSTEM=0
-
-#======================================
-# Exports (Status)
-#--------------------------------------
-export SYSTEM_INTEGRITY
-export SYSTEM_MD5STATUS
-
-#======================================
-# Functions
-#--------------------------------------
-. /include
-
-#======================================
-# Beautify Startup
-#--------------------------------------
-echo &quot;Loading KIWI Boot-System...&quot;
-echo &quot;---------------------------&quot;
-
-#======================================
-# 1) Mounting local file systems
-#--------------------------------------
-mountSystemFilesystems &amp;&gt;/dev/null
-closeKernelConsole
-
-#======================================
-# 2) Prepare module load support 
-#--------------------------------------
-touch /etc/modules.conf
-touch /lib/modules/*/modules.dep
-runHook init
-
-#======================================
-# 3) run udevd
-#--------------------------------------
-udevStart
-
-#======================================
-# 4) start boot shell
-#--------------------------------------
-startBlogD
-startShell
-errorLogStart
-openKernelConsole
-
-#======================================
-# 5) Include proc/cmdline information
-#--------------------------------------
-includeKernelParameters
-if [ ! -z $IMAGE ];then
-	# /.../
-	# if the image information is already in place at this stage
-	# it comes from the cmdline data which means we are not booting
-	# from the network but want to boot the local system
-	# ----
-	LOCAL_BOOT=&quot;yes&quot;
-fi
-
-#======================================
-# 6) Obtain/load network module
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	loaded=0
-	probeNetworkCard
-	IFS=&quot;:&quot;
-	for i in $networkModule;do
-		if [ ! -z $i ];then
-			modprobe $i 2&gt;/dev/null
-			if test $? = 0;then
-				loaded=1
-			fi
-		fi
-	done
-	IFS=$IFS_ORIG
-	if test $loaded = 0;then
-		systemException \
-			&quot;Network module: Failed to load network module !&quot; \
-		&quot;reboot&quot;
-	fi
-fi
-
-#======================================
-# 7) Setup network interface and DNS
-#--------------------------------------
-runHook prenetwork
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	setupNetwork
-fi
-runHook postnetwork
-
-#======================================
-# 8) get TFTP Server IP/name
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	checkServer
-	if [ -z $SERVER ];then
-		SERVER=tftp.$DOMAIN
-	fi
-	Echo &quot;Checking Server name: $SERVER&quot;
-	if ! ping -c 1 $SERVER &gt;/dev/null 2&gt;&amp;1;then
-		Echo &quot;Server: $SERVER not found&quot;
-		if [ -z &quot;$SERVERTYPE&quot; ] || [ &quot;$SERVERTYPE&quot; = &quot;tftp&quot; ]; then
-			if [ ! -z &quot;$DHCPSIADDR&quot; ];then
-				Echo &quot;Using: $DHCPSIADDR from dhcpcd-info&quot;
-				SERVER=$DHCPSIADDR
-			elif [ ! -z &quot;$DHCPSID&quot; ];then
-				Echo &quot;Using: $DHCPSID from dhcpcd-info&quot;
-				SERVER=$DHCPSID
-			else
-				systemException \
-					&quot;Can't assign SERVER IP/name... fatal !&quot; \
-				&quot;reboot&quot;
-			fi
-		fi
-	fi
-fi
-
-#======================================
-# 9) Load configuration
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	CONFIG=/etc/config.netclient
-	#======================================
-	# Connection/access check for SERVER
-	#--------------------------------------
-	Echo &quot;Checking for config file: config.$DHCPCHADDR&quot;
-	fetchFile KIWI/config.$DHCPCHADDR $CONFIG
-	#======================================
-	# Check alternative config names
-	#--------------------------------------
-	if test ! -s $CONFIG;then
-		searchAlternativeConfig
-	fi
-	#======================================
-	# No config found register new client
-	#--------------------------------------
-	if test ! -s $CONFIG;then
-		#======================================
-		# Register new network client
-		#--------------------------------------
-		Echo &quot;Registering new network client...&quot;
-		if test $NAME -ne 0;then
-		if test $NAME -eq -1;then
-			Echo -n &quot;Enter Alias Name for this system: &quot; &amp;&amp; \
-			read SYSALIAS
-		else
-			Echo -n &quot;Enter Alias Name [timeout in $NAME sec]: &quot; &amp;&amp; \
-			read -t $NAME SYSALIAS
-		fi
-		fi
-		hwinfo --all --log=hwinfo.$DHCPCHADDR &gt;/dev/null
-		echo &quot;NCNAME=$SYSALIAS&quot;   &gt;&gt; hwtype.$DHCPCHADDR
-		echo &quot;CRNAME=$SYSALIAS&quot;   &gt;&gt; hwtype.$DHCPCHADDR
-		echo &quot;IPADDR=$IPADDR&quot;     &gt;&gt; hwtype.$DHCPCHADDR
-		echo &quot;ARCHITECTURE=$ARCH&quot; &gt;&gt; hwtype.$DHCPCHADDR
-		#========================================
-		# Try to get BIOS data if tools are there
-		#----------------------------------------
-		if [ -f /sbin/posbios ];then
-			HWBIOS=`/sbin/posbios -b`
-			echo &quot;HWBIOS=$HWBIOS&quot; &gt;&gt; hwtype.$DHCPCHADDR
-			HWTYPE=`/sbin/posbios -ms`
-			echo &quot;HWTYPE=$HWTYPE&quot; &gt;&gt; hwtype.$DHCPCHADDR
-		fi
-		putFile hwtype.$DHCPCHADDR upload/hwtype.$DHCPCHADDR
-		putFile hwinfo.$DHCPCHADDR upload/hwinfo.$DHCPCHADDR
-		echo
-		Echo &quot;Registered as: $DHCPCHADDR&quot;
-		Echo &quot;Waiting for configuration...&quot;
-		sleep 60
-
-		#======================================
-		# Try to get config again
-		#--------------------------------------
-		while test ! -s $CONFIG;do
-			Echo &quot;Lookup network client config file again...&quot;
-			Echo &quot;Checking for config file: config.$DHCPCHADDR&quot;
-			dhcpcd -n
-			fetchFile KIWI/config.$DHCPCHADDR $CONFIG
-			if test ! -s $CONFIG;then
-				searchAlternativeConfig
-			fi
-			test -s $CONFIG || {
-				Echo &quot;Couldn't get image configuration&quot;
-				Echo &quot;sleeping [60 sec]...&quot;
-				sleep 60
-			}
-		done
-	fi
-	importFile &lt; $CONFIG
-fi
-
-#======================================
-# 10) Load Device modules
-#--------------------------------------
-runHook preprobe
-probeDevices
-runHook postprobe
-
-export systemIntegrity=&quot;unknown&quot;
-#======================================
-# 11) Is this a diskful station
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-if [ ! -z &quot;$PART&quot; ] &amp;&amp; [ -z &quot;$NFSROOT&quot; ] &amp;&amp; [ -z &quot;$NBDROOT&quot; ];then
-	#======================================
-	# Check for possible extended partition
-	#--------------------------------------
-	checkExtended
-	#======================================
-	# Check for installed system
-	#--------------------------------------
-	count=0
-	IFS=&quot;,&quot; ; for i in $IMAGE;do
-	case $count in
-	0) {
-		field=0
-		IFS=&quot;;&quot; ; for n in $i;do
-		case $field in
-			0) imageDevice=$n ; field=1 ;;
-			1) imageName=$n   ; field=2 ;;
-			2) imageVersion=$n; field=3
-		esac
-		done
-		count=1
-		waitForStorageDevice $DISK
-		if ! sfdisk -s $DISK &amp;&gt;/dev/null;then
-			systemException \
-				&quot;Disk $DISK doesn't appear... fatal !&quot; \
-			&quot;reboot&quot;
-		fi
-		updateNeeded initialize
-		if linuxPartition $DISK;then
-			if mountSystem $imageDevice;then
-				updateNeeded
-				umountSystem
-				systemIntegrity=`getSystemIntegrity 1`
-				if [ $systemIntegrity = &quot;fine&quot; ];then
-					Echo &quot;Base system is up to date, activating disk system...&quot;
-				fi
-			else
-				Echo -b &quot;Image Update for image [ $imageName ] needed&quot;
-				Echo -b &quot;Image mount failed&quot;
-				RELOAD_IMAGE=&quot;yes&quot;
-				systemIntegrity=&quot;clean&quot;
-			fi
-		else
-			systemIntegrity=&quot;clean&quot;
-		fi
-	}
-	;;
-	*)
-		# handle other images here...
-	;;
-	esac
-	done
-	#======================================
-	# Create partition table if needed
-	#--------------------------------------
-	if test $systemIntegrity = &quot;clean&quot;;then
-		runHook prepartition
-		Echo &quot;Creating partition table...&quot;
-		partitionCount
-		createSwap
-		createPartition
-		writePartitionTable $DISK
-		IFS=&quot;:&quot; ; for i in $PART_DEV;do
-		if test ! -z &quot;$i&quot;;then
-			createFileSystem $i
-		fi
-		done
-		mkswap ${DISK}1 &gt;/dev/null 2&gt;&amp;1
-		runHook postpartition
-	fi
-fi
-fi
-
-#======================================
-# 12) Download network client image
-#--------------------------------------
-runHook predownload
-if [ -z &quot;$NFSROOT&quot; ] &amp;&amp; [ -z &quot;$NBDROOT&quot; ];then
-	count=0
-	IFS=&quot;,&quot; ; for i in $IMAGE;do
-		imageZipped=&quot;uncompressed&quot;
-		count=$(($count + 1))
-		field=0
-		IFS=&quot;;&quot; ; for n in $i;do
-		case $field in
-			0) imageDevice=$n ; field=1 ;;
-			1) imageName=$n   ; field=2 ;;
-			2) imageVersion=$n; field=3 ;;
-			3) imageServer=$n ; field=4 ;;
-			4) imageBlkSize=$n; field=5 ;;
-			5) imageZipped=$n ;
-		esac
-		done
-		if [ $count = 1 ];then
-			imageRootDevice=$imageDevice
-			imageRootName=$imageName
-		fi
-		if [ $count = 2 ];then
-			imageNextRootDevice=$imageDevice
-		fi
-		if [ $LOCAL_BOOT = &quot;yes&quot; ];then
-			continue
-		fi
-		if test `getSystemIntegrity $count` = &quot;fine&quot;;then
-			continue
-		fi
-		imageName=&quot;image/$imageName-$imageVersion&quot;
-		imageMD5s=&quot;$imageName.md5&quot;
-		[ -z &quot;$imageServer&quot; ]  &amp;&amp; imageServer=$SERVER
-		[ -z &quot;$imageBlkSize&quot; ] &amp;&amp; imageBlkSize=8192
-		while true;do
-			# /.../
-			# get image md5sum to be able to check for the size
-			# requirements if we are loading into RAM
-			# ---
-			fetchFile $imageMD5s /etc/image.md5 uncomp $imageServer
-			if test $loadCode != 0 || ! loadOK &quot;$loadStatus&quot;; then
-				systemException \
-					&quot;Download of $imageMD5s failed: $loadStatus&quot; \
-				&quot;reboot&quot;
-			fi
-			IFS=&quot; &quot;
-			read sum1 blocks blocksize zblocks zblocksize &lt; /etc/image.md5
-			if ! validateSize;then
-				systemException \
-					&quot;Not enough space available for this image&quot; \
-				&quot;reboot&quot;
-			fi
-			# /.../
-			# now load the image into the imageDevice
-			# ---
-			multicast=on
-			if test &quot;$imageZipped&quot; = &quot;compressed&quot;; then
-				Echo &quot;Compressed image found: Disable multicast download&quot;
-				multicast=&quot;off&quot;
-			fi
-			Echo &quot;Loading $imageName [$imageDevice BS:$imageBlkSize Byte]...&quot;
-			fetchFile $imageName $imageDevice $imageZipped $imageServer
-			if test $loadCode != 0 || ! loadOK &quot;$loadStatus&quot;;then
-				systemException \
-					&quot;Download of $imageName failed: $loadStatus&quot; \
-				&quot;reboot&quot;
-			fi
-			# /.../
-			# check the md5sum of the downloaded data records
-			# ----
-			Echo &quot;Download complete, checking data...&quot;
-			dd if=$imageDevice bs=1024 2&gt;/dev/null |\
-				head --bytes=$((blocks * blocksize)) |\
-				md5sum - &gt; /etc/ireal.md5
-			read sum2 dumy &lt; /etc/ireal.md5
-			if test $sum1 = $sum2;then
-				Echo &quot;Image checksum test: fine :-)&quot;
-				break
-			fi
-			Echo &quot;Image checksum test failed:&quot;
-			Echo &quot;Possible reasons:&quot;
-			echo 
-			Echo -b &quot;1) Physical ethernet connection lost:&quot;
-			Echo -b &quot;   please check cable&quot;
-			echo
-			Echo -b &quot;2) Data corruption while loading the image:&quot;
-			Echo -b &quot;   will give it a new try...&quot;
-			echo
-			Echo -b &quot;3) wrong checksum file created for the image:&quot;
-			Echo -b &quot;   check with the md5sum command if the image on the&quot;
-			Echo -b &quot;   TFTP server provides the same md5 sum as included&quot;
-			Echo -b &quot;   within the appropriate .md5 file for this image&quot;
-			echo
-			if test -z $DISK;then
-			Echo -b &quot;4) ramdisk size is too small for the image:&quot;
-			Echo -b &quot;   check the ramdisk_size parameter of the PXE&quot;
-			Echo -b &quot;   configuration file on the TFTP server&quot;
-			else
-			Echo -b &quot;4) partition size is too small for the image:&quot;
-			Echo -b &quot;   check the PART line in the image config file on the&quot;
-			Echo -b &quot;   TFTP server&quot;
-			fi
-			echo
-			Echo &quot;Retry to load image...&quot;
-			sleep 15
-		done
-		echo $imageDevice | grep -q ram
-		haveDataInRam=$?
-		if test ! -z $DISK &amp;&amp; test $haveDataInRam != 0;then
-			probeFileSystem $imageDevice
-			if test &quot;$FSTYPE&quot; = &quot;reiserfs&quot;;then
-				Echo &quot;Resize Reiser filesystem to full partition space...&quot;
-				resize_reiserfs $imageDevice
-				INITRD_MODULES=&quot;$INITRD_MODULES reiserfs&quot;
-			fi
-			if test &quot;$FSTYPE&quot; = &quot;ext2&quot;;then
-				Echo &quot;Resize EXT2 filesystem to full partition space...&quot;
-				resize2fs -f -F -p $imageDevice
-				Echo &quot;Checking EXT2 filesystem...&quot;
-				e2fsck -f $imageDevice -y
-				INITRD_MODULES=&quot;$INITRD_MODULES ext2&quot;
-			fi
-			if test &quot;$FSTYPE&quot; = &quot;ext3&quot;;then
-				Echo &quot;Resize EXT3 filesystem to full partition space...&quot;
-				resize2fs -f -F -p $imageDevice
-				Echo &quot;Checking EXT3 filesystem...&quot;
-				e2fsck -f $imageDevice -y
-				INITRD_MODULES=&quot;$INITRD_MODULES ext3&quot;
-			fi
-		fi
-		if test ! -z $DISK &amp;&amp; test $haveDataInRam = 0;then
-			Echo &quot;Including RAM device data to disk...&quot;
-			RELOAD_CONFIG=&quot;yes&quot;
-			mkdir -p /config
-			mountSystem
-			rm -rf /mnt/lost+found
-			cp -a /mnt/* /config &amp;&amp; rm -f /mnt/*
-			umountSystem
-		fi
-		rm -f /etc/ireal.md5
-		rm -f /etc/image.md5
-	done
-else
-	#======================================
-	# 12.1) Check for NFS root
-	#--------------------------------------
-	if [ ! -z &quot;$NFSROOT&quot; ];then
-		IFS=&quot;,&quot; ; for i in $NFSROOT;do
-			field=0
-			IFS=&quot;;&quot; ; for n in $i;do
-			case $field in
-				0) nfsRootServer=$n ; field=1 ;;
-				1) nfsRootDevice=$n ; field=2
-			esac
-			done
-		done
-		Echo &quot;Mounting NFS root system: $nfsRootServer:$nfsRootDevice...&quot;
-		imageRootDevice=&quot;-o nolock,rw $nfsRootServer:$nfsRootDevice&quot;
-		if [ ! -z &quot;$COMBINED_IMAGE&quot; ] || [ ! -z &quot;$UNIONFS_CONFIG&quot; ];then
-			imageRootDevice=&quot;-o nolock,ro $nfsRootServer:$nfsRootDevice&quot;
-		fi
-		imageRootName=&quot;NFSRoot-System&quot;
-		systemIntegrity=&quot;clean&quot;
-		export FSTYPE=nfs
-	fi
-	#======================================
-	# 12.2) Check for NBD root
-	#--------------------------------------
-	if [ ! -z &quot;$NBDROOT&quot; ];then
-		if ! modprobe nbd;then
-			systemException &quot;Failed to load network blk device module&quot; &quot;reboot&quot;
-		fi
-		IFS=&quot;,&quot; ; for i in $NBDROOT;do
-			field=0
-			IFS=&quot;;&quot; ; for n in $i;do
-			case $field in
-				0) nbdServer=$n     ; field=1 ;;
-				1) nbdPort=$n       ; field=2 ;;
-				2) nbdDevice=$n     ; field=3 ;;
-				3) nbdswapPort=$n   ; field=4 ;;
-				4) nbdswapDevice=$n ; field=5
-			esac
-			done
-		done
-		if [ -z &quot;$nbdDevice&quot; ];then
-			nbdDevice=&quot;/dev/nbd0&quot;
-		fi
-		if [ -z &quot;$nbdswapDevice&quot; ];then
-			nbdswapDevice=&quot;/dev/nbd1&quot;
-		fi
-		if [ -z &quot;$nbdPort&quot; ];then
-			nbdPort=&quot;2000&quot;
-		fi
-		if [ -z &quot;$nbdswapPort&quot; ];then
-			nbdswapPort=&quot;9210&quot;
-		fi
-		waitForBlockDevice $nbdDevice
-		if [ ! -b $nbdDevice ];then
-			systemException &quot;Device $nbdDevice doesn't appear&quot; &quot;reboot&quot;
-		fi
-		# /.../
-		# try to get swap from the server if we dont have
-		# enough ram (less than 62MB)
-		# ----
-		min_ram=63488
-		real_ram=$(cat /proc/meminfo |grep MemTotal|tr -d &quot; [a-z][A-Z]:&quot;)
-		if [ ${real_ram} -lt ${min_ram} ];then
-			Echo &quot;NBD: memory is below required 62M&quot;
-			Echo &quot;NBD: Mounting swap: $nbdServer $nbdswapPort [$nbdswapDevice]&quot;
-			if [ ! -b $nbdswapDevice ];then
-				systemException &quot;Device $nbdswapDevice doesn't appear&quot; &quot;reboot&quot;
-			fi
-			if ! /usr/sbin/nbd-client $nbdServer $nbdswapPort $nbdswapDevice
-			then
-				systemException &quot;Failed to setup $nbdswapDevice device&quot; &quot;reboot&quot;
-			fi
-			Echo &quot;NBD: Waiting for server to create swap space...&quot;
-			sleep 3
-			/sbin/swapon $nbdswapDevice || true
-		fi
-		Echo &quot;Mounting NBD root system: $nbdServer $nbdPort [$nbdDevice]...&quot;
-		if ! /usr/sbin/nbd-client $nbdServer $nbdPort $nbdDevice;then
-			systemException &quot;Failed to setup $nbdDevice device&quot; &quot;reboot&quot;
-		fi
-		imageRootDevice=$nbdDevice
-		probeFileSystem $imageRootDevice
-		Echo &quot;Filesystem of remote root system is: $FSTYPE&quot;
-		if [ -z &quot;$COMBINED_IMAGE&quot; ];then
-			if isFSTypeReadOnly;then
-				export UNIONFS_CONFIG=&quot;/dev/ram1,&quot;$imageRootDevice&quot;,aufs&quot;
-			fi
-		fi
-		imageRootName=&quot;NBDRoot-System&quot;
-		systemIntegrity=&quot;clean&quot;
-	fi
-fi
-runHook postdownload
-#======================================
-# 13) Check for RELOAD_CONFIG
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test ! -z $DISK;then
-	if test ! -z $RELOAD_CONFIG;then
-		systemIntegrity_save=$systemIntegrity
-		systemIntegrity=&quot;clean&quot;
-	fi
-	fi
-fi
-
-#======================================
-# 14) Mount OS image to /mnt
-#--------------------------------------
-runHook premount
-if ! mountSystem;then
-	systemException &quot;Failed to mount root filesystem&quot; &quot;reboot&quot;
-fi
-validateRootTree
-runHook postmount
-
-#======================================
-# 15) Import fixed configuration files
-#--------------------------------------
-runHook preconfig
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		mkdir -p /config
-		#======================================
-		# Get files from CONF value
-		#--------------------------------------
-		IFS=&quot;,&quot; ; for i in $CONF;do
-			field=0
-			IFS=&quot;;&quot; ; for n in $i;do
-			case $field in
-				0) configSource=$n ; field=1 ;;
-				1) configDest=$n   ; field=2 ;;
-				2) configServer=$n ; field=3 ;;
-				3) configBlkSize=$n;
-			esac
-			done
-			Echo &quot;Import configuration file: $configDest&quot;
-			dirs=`dirname  $configDest`
-			mkdir -p /config/$dirs
-			fetchFile $configSource /config/$configDest uncomp $configServer
-		done
-		#======================================
-		# Check for KIWI_INITRD
-		#--------------------------------------
-		if [ ! -z $KIWI_INITRD ];then
-			Echo &quot;Import KIWI initrd file: $KIWI_INITRD&quot;
-			rm -f /mnt/boot/initrd* &amp;&amp; mkdir -p /mnt/boot &gt;/dev/null 2&gt;&amp;1
-			fetchFile $KIWI_INITRD /mnt/boot/initrd
-			if [ ! -z $KIWI_KERNEL ];then
-				Echo &quot;Import KIWI kernel file: $KIWI_KERNEL&quot;
-				fetchFile $KIWI_KERNEL /mnt/boot/vmlinuz
-			fi
-			KIWI_INITRD_PARAMS=&quot;IMAGE=\&quot;$IMAGE\&quot;&quot;
-			if [ ! -z $COMBINED_IMAGE ]; then
-				SPLIT=&quot;COMBINED_IMAGE=$COMBINED_IMAGE&quot;
-				KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS $SPLIT&quot;
-			fi
-			if [ ! -z &quot;$UNIONFS_CONFIG&quot; ]; then
-				UNIONED=&quot;UNIONFS_CONFIG=$UNIONFS_CONFIG&quot;
-				KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS $UNIONED&quot;
-			fi
-		fi
-	fi
-fi
-runHook postconfig
-
-#======================================
-# 16) check filesystem and kernels
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		probeFileSystem $imageRootDevice
-		kernelList /mnt
-	fi
-fi
-
-#======================================
-# 17) make initrd available on unionfs
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test ! -z &quot;$UNIONFS_CONFIG&quot; &amp;&amp; test $systemIntegrity = &quot;clean&quot;;then
-		# /.../
-		# have to do this so that /boot gets copied to the
-		# ext2 partition, which is necessary for the bootloader to
-		# be able to find the data in there (it can't read squashfs
-		# or cromfs)
-		# ----
-		cp -a /mnt/boot /dev/shm/boot2
-		rm -rf /mnt/boot
-		mv /dev/shm/boot2 /mnt/boot
-	fi
-fi
-
-#======================================
-# 18) Create system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		setupDefaultPXENetwork /config
-		setupDefaultFstab /config
-		updateRootDeviceFstab /config &quot;$imageRootDevice&quot;
-		if test ! -z $DISK;then
-			updateSwapDeviceFstab /config ${DISK}1
-			updateOtherDeviceFstab /config
-			if ! test -z $COMBINED_IMAGE; then
-				gnum=`echo $imageNextRootDevice | sed -e &quot;s/.*\([0-9]\)/\1/&quot;`
-				gnum=`expr $gnum - 1`
-				setupBootLoader \
-					/mnt /config $gnum $imageNextRootDevice NET ${DISK}1
-			else
-				setupBootLoader /mnt /config 1 ${DISK}2 NET ${DISK}1
-			fi
-			setupKernelModules /config
-		fi
-	fi
-fi
-
-#======================================
-# 19) If image is new, notify
-#--------------------------------------
-runHook prenotify
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;; then
-		count=0
-		IFS=&quot;,&quot; ; for i in $IMAGE;do
-			count=$(($count + 1))
-			field=0
-			IFS=&quot;;&quot; ; for n in $i;do
-			case $field in
-				0) field=1 ;;
-				1) imageName=$n   ; field=2 ;;
-				2) imageVersion=$n; field=3 ;;
-				3) imageServer=$n ; field=4 ;;
-				4) imageBlkSize=$n; field=5 ;;
-				5) imageZipped=$n ;
-			esac
-			done
-			Echo &quot;Notify of new image: image/$imageName&quot;
-			echo &quot;image/$imageName&quot; &gt; bootversion.$DHCPCHADDR
-			echo &quot;$imageVersion&quot;   &gt;&gt; bootversion.$DHCPCHADDR
-			putFile bootversion.$DHCPCHADDR upload/bootversion.$DHCPCHADDR
-			rm -f bootversion.$DHCPCHADDR
-		done
-	fi
-fi
-runHook postnotify
-
-#======================================
-# 20) send DHCP_RELEASE, reset cache
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ] &amp;&amp; [ -z &quot;$NFSROOT&quot; ] &amp;&amp; [ -z &quot;$NBDROOT&quot; ];then
-	dhcpcd -k
-fi
-
-#======================================
-# 21) copy system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		cd /config
-		find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
-		find . -type f | while read f ; do  cp -a $f /mnt/$f ; done
-		cd /
-		rm -rf /config
-	fi
-fi
-
-echo 256 &gt; /proc/sys/kernel/real-root-dev
-#======================================
-# 22) umount system filesystems
-#--------------------------------------
-umountSystemFilesystems
-
-#======================================
-# 23) copy initrd files to image
-#--------------------------------------
-importBranding
-cp /preinit /mnt
-cp /include /mnt
-
-#======================================
-# 24) check if reboot is required
-#--------------------------------------
-kernelCheck /mnt
-
-#======================================
-# 25 kill boot shell
-#--------------------------------------
-killShell
-killBlogD
-
-#======================================
-# 26 Activate new root
-#--------------------------------------
-runHook preactivate
-Echo &quot;Activating Image: [$imageRootName]&quot;
-reopenKernelConsole
-/sbin/udevsettle --timeout=30
-mount --move /dev /mnt/dev
-udevKill
-
-#======================================
-# 27) call preinit phase
-#--------------------------------------
-Echo &quot;Calling preinit phase...&quot;
-cd /mnt
-/mnt/sbin/pivot_root . mnt &gt;/dev/null 2&gt;&amp;1
-if test $? != 0;then
-	PIVOT=false
-	cleanInitrd &amp;&amp; mount --move . / &amp;&amp; chroot . ./preinit
-	chroot . rm -f  ./preinit
-	chroot . rm -f  ./include
-	chroot . rm -rf ./image
-else
-	PIVOT=true
-	./preinit
-	rm -f  ./preinit
-	rm -f  ./include
-	rm -rf ./image
-fi
-#======================================
-# 28) reboot system if specified
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test ! -z $REBOOT_IMAGE;then
-		Echo &quot;Rebooting System to activate new kernel...&quot;
-		reboot -f -i &gt;/dev/null 2&gt;&amp;1
-	fi
-fi
-
-#======================================
-# 29) Unmount initrd / system init
-#--------------------------------------
-echo &quot; &quot;
-echo &quot;Booting into final System...&quot;
-echo &quot;----------------------------&quot;
-export IFS=$IFS_ORIG
-mount -n -o remount,rw / 2&gt;/dev/null
-if [ $PIVOT = &quot;true&quot; ];then
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec umount -n -l /mnt
-else
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec chroot . /sbin/init $@
-fi

Copied: kiwi-head/system/boot/ix86/netboot/suse-linuxrc (from rev 1474, kiwi-head/system/boot/netboot/suse-linuxrc)

Copied: kiwi-head/system/boot/ix86/oemboot (from rev 1473, kiwi-head/system/boot/oemboot)


Property changes on: kiwi-head/system/boot/ix86/oemboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: kiwi-head/system/boot/ix86/oemboot/suse-linuxrc
===================================================================
--- kiwi-head/system/boot/oemboot/suse-linuxrc	2008-07-23 09:16:44 UTC (rev 1473)
+++ kiwi-head/system/boot/ix86/oemboot/suse-linuxrc	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,1144 +0,0 @@
-#!/bin/bash
-#================
-# FILE          : linuxrc
-#----------------
-# PROJECT       : OpenSuSE KIWI Image System
-# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
-#               :
-# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
-#               :
-# BELONGS TO    : Operating System images
-#               :
-# DESCRIPTION   : This file is changed to become the real
-#               : linuxrc script which is used to prepare the
-#               : operating system for the main image
-#               :
-#               :
-# STATUS        : BETA
-#----------------
-#======================================
-# Exports (General)...
-#--------------------------------------
-export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
-export IFS_ORIG=$IFS
-export DEBUG=0
-
-#======================================
-# Exports (Booting)
-#--------------------------------------
-export DOMURD_MODULES=&quot;xennet xenblk&quot;
-export INITRD_MODULES=&quot;reiserfs&quot;
-export LOCAL_BOOT=no
-export systemIntegrity=&quot;clean&quot;
-
-#======================================
-# Exports (Configuration)
-#--------------------------------------
-export VMX_SYSTEM=&quot;/config.vmxsystem&quot;
-export LIVECD_CONFIG=$VMX_SYSTEM
-export OEM_PARTITION_CONFIG=&quot;/config.oempartition&quot;
-
-#======================================
-# Functions...
-#--------------------------------------
-. /include
-
-#======================================
-# Beautify Startup
-#--------------------------------------
-echo &quot;Loading KIWI OEM Boot-System...&quot;
-echo &quot;-------------------------------&quot;
-
-#======================================
-# 1) Mounting local file systems
-#--------------------------------------
-mountSystemFilesystems &amp;&gt;/dev/null
-closeKernelConsole
-
-#======================================
-# 2) Prepare module load support 
-#--------------------------------------
-touch /etc/modules.conf
-touch /lib/modules/*/modules.dep
-
-#======================================
-# 3) run udevd
-#--------------------------------------
-udevStart
-
-#======================================
-# 4) start boot shell
-#--------------------------------------
-startBlogD
-startShell
-errorLogStart
-openKernelConsole
-
-#======================================
-# 5) Include proc/cmdline information
-#--------------------------------------
-includeKernelParameters
-if \
-	[ ! -z $UNIONFS_CONFIG ] || [ &quot;$COMBINED_IMAGE&quot; = &quot;local&quot; ] ||\
-	[ ! -z $KIWI_RECOVERY ]
-then
-	# /.../
-	# if the unionfs/combined information is already in place at this
-	# stage it comes from the cmdline data which means we are not
-	# booting from CD/DVD USB stick but want to boot the local system
-	# This also applies if we use an oem system with the recovery
-	# feature enabled
-	# ----
-	export LOCAL_BOOT=&quot;yes&quot;   
-fi
-
-#======================================
-# 6) Including required kernel modules
-#--------------------------------------
-probeDevices
-for module in ehci-hcd uhci-hcd usb_storage sg sd_mod BusLogic;do
-	modprobe $module &gt;/dev/null 2&gt;&amp;1
-done
-
-#======================================
-# 7) Search disks, prefer removable one
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if [ ! -f $VMX_SYSTEM ];then
-		# /.../
-		# installed system: Check for a root device to mount and
-		# prefer a USB stick if there is any. Otherwise check for
-		# first partition of a disk device. During first boot of
-		# the installed system there is only one partition and this
-		# initrd is going to be replaced by a later mkinitrd call
-		# for unified systems the kiwi initrd is used and the
-		# kernel parameters of this initrd defines the missing
-		# information. Additionally the partition table is different
-		# for unified systems. Therefore we check if the second
-		# partition is a squashfs/cromfs partition and change the root
-		# partition name accordingly
-		# ----
-		if [ -f $OEM_PARTITION_CONFIG ];then
-			Echo &quot;Including oem partition info file&quot;
-			importFile &lt; $OEM_PARTITION_CONFIG
-		fi
-		Echo &quot;Searching for disk and root partition&quot;
-		USBStickDevice
-		if [ $stickFound = 0 ];then
-			deviceFound=0
-			for deviceRoot in /dev/sda1 /dev/hda1;do
-				if mount $deviceRoot /mnt &amp;&gt;/dev/null;then
-					deviceFound=1
-					umount /mnt
-					break
-				fi
-			done
-			if [ $deviceFound = 0 ];then
-				systemException \
-					&quot;Couldn't find any disk device... abort&quot; \
-				&quot;reboot&quot;
-			fi
-			export deviceDisk=`echo $deviceRoot | tr -d [0-9]`
-			export deviceSwap=&quot;$deviceDisk&quot;2
-			if [ -z &quot;$OEM_WITHOUTHOME&quot; ];then
-				export deviceHome=&quot;$deviceDisk&quot;3
-			fi
-		else
-			Echo &quot;USB stick found, prefer root on stick&quot;
-			export deviceDisk=$stickRoot
-			export deviceSwap=&quot;$deviceDisk&quot;2
-			if [ -z &quot;$OEM_WITHOUTHOME&quot; ];then
-				export deviceHome=&quot;$deviceDisk&quot;3
-			fi
-		fi
-		probeFileSystem &quot;$deviceDisk&quot;1
-		if isFSTypeReadOnly;then
-			if [ -z &quot;$COMBINED_IMAGE&quot; ];then
-				Echo &quot;Unified system detected, adapting root partition&quot;
-				export UNIONFS_CONFIG=&quot;$deviceDisk&quot;2,&quot;$deviceDisk&quot;1,aufs
-			fi
-			export deviceRoot=&quot;$deviceDisk&quot;1
-			export deviceSwap=&quot;$deviceDisk&quot;3
-		else
-			export deviceRoot=&quot;$deviceDisk&quot;1
-		fi
-		Echo &quot;Using root partition $deviceRoot on disk $deviceDisk&quot;
-	else
-		# /.../
-		# installation mode: find a usable disk to install the image
-		# on. The image is a virtual disk with one partition
-		# ----
-		Echo &quot;Searching harddrive for installation&quot;
-		Echo &quot;Waiting for devices to settle...&quot;
-		# ...
-		# sleep for a while as I don't know a device to listen on
-		# I should be sure all possible devices exist. If there is
-		# a better way to make sure _now_ is the best time to search
-		# a disk please fixme
-		# ---
-		sleep 5
-		hwinfo=&quot;/usr/sbin/hwinfo --disk&quot;
-		export deviceDisks=`$hwinfo |\
-			grep &quot;Device File:&quot; | cut -f2 -d: | cut -f1 -d&quot;(&quot;`
-		export deviceDisks=`echo $deviceDisks`
-		if [ -z $deviceDisks ];then
-			systemException \
-				&quot;No hard disk device(s) found... abort&quot; \
-			&quot;reboot&quot;
-		fi
-		Echo &quot;Found following hard disk device(s)&quot;
-		count=0
-		for i in $deviceDisks;do
-			Echo -b &quot;Disk $count -&gt; $i&quot;
-			deviceArray[$count]=$i
-			count=`expr $count + 1`
-		done
-		while true;do
-			Echo -n &quot;Enter device name to select disk for installation: &quot;
-			read deviceInput
-			count=0
-			for deviceDisk in $deviceDisks;do
-				if [ ${deviceArray[$count]} = $deviceInput ];then
-					break 2
-				fi
-				count=`expr $count + 1`
-			done
-			Echo &quot;Given device is not in the list !&quot;
-		done
-		Echo &quot;Entering installation mode for disk: $deviceDisk&quot;
-	fi
-fi
-
-#======================================
-# 8) Check for vmx system
-#--------------------------------------
-if [ -f $VMX_SYSTEM ] &amp;&amp; [ $LOCAL_BOOT = &quot;no&quot; ];then
-	#======================================
-	# 8.1) import vmx configuration file
-	#--------------------------------------
-	importFile &lt; $VMX_SYSTEM
-	#======================================
-	# 8.2) check version of installed OS
-	#--------------------------------------
-	deviceRoot=&quot;$deviceDisk&quot;2
-	probeFileSystem $deviceRoot
-	if test &quot;$FSTYPE&quot; = &quot;unknown&quot;;then
-		deviceRoot=&quot;$deviceDisk&quot;1
-		probeFileSystem $deviceRoot
-	fi
-	if [ -z &quot;$COMBINED_IMAGE&quot; ];then
-		if isFSTypeReadOnly;then
-			export UNIONFS_CONFIG=&quot;$deviceDisk&quot;2,&quot;$deviceDisk&quot;1,aufs
-		fi
-	fi
-	Echo &quot;Try mounting installed system to check version&quot;
-	mountSystem $deviceRoot; updateNeeded
-	umountSystem
-	if test `getSystemIntegrity 1` = &quot;fine&quot;;then
-		Echo &quot;Base system is up to date... reboot&quot;
-		/sbin/reboot -f -i &gt;/dev/null 2&gt;&amp;1
-	fi
-	#======================================
-	# 8.3) mount CD/DVD/USB stick
-	#--------------------------------------
-	USBStickDevice
-	if [ $stickFound = 0 ];then
-		Echo &quot;Search for USB stick failed, checking CD/DVD drive&quot;
-		CDMount
-	else
-		Echo &quot;Found Stick: $stickDevice -&gt; $stickSerial&quot;
-		mkdir -p /cdrom &amp;&amp; mount $stickDevice /cdrom
-	fi
-	#======================================
-	# 8.4) install disk system
-	#--------------------------------------
-	# /.../
-	# install virtual disk image from the CD/DVD onto the
-	# real disk. All data on the disk will be lost
-	# ----
-	imageZipped=&quot;uncompressed&quot;
-	imageDevice=$deviceDisk
-	field=0
-	IFS=&quot;;&quot; ; for n in $IMAGE;do
-	case $field in
-		0) field=1 ;; 
-		1) imageName=$n   ; field=2 ;;
-		2) imageVersion=$n;
-	esac
-	done
-	imageName=&quot;/cdrom/$imageName&quot;
-	echo $imageName | grep -qE &quot;.gz$&quot;
-	if [ $? = 0 ];then
-		imageZipped=&quot;compressed&quot;
-	fi
-	IFS=&quot; &quot;
-	if test &quot;$imageZipped&quot; = &quot;compressed&quot;; then
-		Echo &quot;Compressed image found&quot;
-		test ! -p /dev/compressed_image &amp;&amp; mkfifo /dev/compressed_image
-		cat /dev/compressed_image | gzip -d &gt; $imageDevice 2&gt;/dev/null &amp;
-		imageDevice_orig=$imageDevice
-		imageName_orig=$imageName
-		imageDevice=&quot;/dev/compressed_image&quot;
-		imageName=&quot;$imageName.gz&quot;
-	fi
-	Echo &quot;Loading $imageName [$imageDevice]...&quot;
-	if ! dd bs=32k if=$imageName of=$imageDevice &gt;/dev/null 2&gt;&amp;1; then
-		systemException \
-			&quot;Failed to install image: $imageName -&gt; $imageDevice&quot; \
-		&quot;reboot&quot;
-	fi
-	if test &quot;$imageZipped&quot; = &quot;compressed&quot;; then
-		imageDevice=$imageDevice_orig
-		imageName=$imageName_orig
-		rm -f /dev/compressed_image
-	fi
-	#======================================
-	# 8.5) Umount the CD/DVD
-	#--------------------------------------
-	umount /cdrom
-	#======================================
-	# 8.6) reread partition table
-	#--------------------------------------
-	blockdev --rereadpt $deviceDisk
-	deviceTest=&quot;$deviceDisk&quot;1
-	waitForStorageDevice $deviceTest
-	if ! sfdisk -s $deviceTest &amp;&gt;/dev/null;then
-		systemException \
-			&quot;Partition $deviceTest doesn't appear... fatal !&quot; \
-		&quot;reboot&quot;
-	fi
-	#======================================
-	# 8.7) find new root partition
-	#--------------------------------------
-	unset UNIONFS_CONFIG
-	deviceRoot=&quot;$deviceDisk&quot;1
-	probeFileSystem $deviceRoot
-	Echo &quot;Filesystem of root system is: $FSTYPE -&gt; $deviceRoot&quot;
-	if [ -z &quot;$COMBINED_IMAGE&quot; ];then
-		if isFSTypeReadOnly;then
-			export UNIONFS_CONFIG=&quot;$deviceDisk&quot;2,&quot;$deviceDisk&quot;1,aufs
-		fi
-	fi
-	#======================================
-	# 8.8) Create md5 version info file
-	#--------------------------------------
-	unset RELOAD_IMAGE
-	if ! mountSystem $deviceRoot;then
-		systemException \
-			&quot;Couldn't mount installed system... abort&quot; \
-		&quot;reboot&quot;
-	fi
-	updateNeeded initialize
-	field=0
-	IFS=&quot;;&quot; ; for n in $IMAGE;do
-	case $field in
-		0) field=1 ;;
-		1) imageName=$n   ; field=2 ;;
-		2) imageVersion=$n
-	esac
-	done
-	atversion=&quot;$imageName-$imageVersion&quot;
-	versionFile=&quot;/mnt/etc/ImageVersion-$atversion&quot;
-	md5sum=`getSystemMD5Status 1`
-	echo &quot;$atversion $md5sum&quot; &gt; $versionFile
-	umountSystem
-	#======================================
-	# 8.9) reboot system
-	#--------------------------------------
-	if [ $stickFound = 0 ];then
-		Echo &quot;NOTE: Please remove the installation CD before reboot !&quot;
-		CDEject
-	else
-		Echo &quot;NOTE: Please unplug the USB stick before reboot !&quot;
-	fi
-	systemException \
-		&quot;System installation has finished&quot; \
-	&quot;reboot&quot;
-fi
-
-#======================================
-# 9) Probe filesystem of disk device
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	probeFileSystem $deviceRoot
-	if [ $FSTYPE = &quot;unknown&quot; ];then
-		systemException \
-			&quot;Couldn't determine filesystem type... abort&quot; \
-		&quot;reboot&quot;
-	fi
-fi
-
-#======================================
-# 10) repartition the disk device
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	#======================================
-	# 10.1 calculate amount of swap space
-	#--------------------------------------
-	mem_size=`grep MemTotal: /proc/meminfo | tr -dc '[0-9]'`
-	swapsize=$(( $mem_size *2 / 1024 ))
-	recoMByte=0
-	if [ ! -z &quot;$OEM_SWAPSIZE&quot; ];then
-		swapsize=$OEM_SWAPSIZE
-	fi
-	if [ ! -z &quot;$OEM_WITHOUTSWAP&quot; ];then
-		swapsize=0
-	fi
-	if [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-		mkdir -p /reco-root
-		if ! mount $deviceRoot /reco-root &gt;/dev/null;then
-			systemException &quot;Failed to mount root device&quot; &quot;reboot&quot;
-		fi
-		if [ ! -f /reco-root/recovery.tar.gz ];then
-			systemException &quot;Can't find recovery archive&quot; &quot;reboot&quot;
-		fi
-		recoBytes=`du --bytes /reco-root/recovery.tar.gz | cut -f1`
-		recoMByte=`expr $recoBytes / 1048576`
-		recoMByte=`expr $recoMByte \* 15 / 10`
-		umount /reco-root &amp;&amp; rmdir /reco-root
-	fi
-	Echo &quot;Filesystem of root system is: $FSTYPE -&gt; $deviceRoot&quot;
-	if test ! -z $COMBINED_IMAGE;then
-		#====================================== 
-		# 10.2 no recovery support in this mode
-		#--------------------------------------
-		unset OEM_RECOVERY
-		#====================================== 
-		# 10.2 check for read-write partition
-		#--------------------------------------
-		if ! sfdisk -s &quot;$deviceDisk&quot;2 &amp;&gt;/dev/null;then
-			Echo &quot;No read-write partition in this split image&quot;
-			DONT_PARTITION=1
-		fi
-		#======================================
-		# 10.3 calculate new partition 3 size
-		#--------------------------------------
-		if [ -z &quot;$DONT_PARTITION&quot; ];then
-			swapXMBytes=$swapsize
-			diskXMBytes=`sfdisk -s $deviceDisk`
-			diskXMBytes=`expr $diskXMBytes / 1000`
-			disk1MBytes=`sfdisk -s &quot;$deviceDisk&quot;1`
-			disk1MBytes=`expr $disk1MBytes / 1000`
-			disk2MBytes=`sfdisk -s &quot;$deviceDisk&quot;2`
-			disk2MBytes=`expr $disk2MBytes / 1000`
-			diskXLBytes=`expr $diskXMBytes - $disk1MBytes - $disk2MBytes`
-			diskXABytes=`expr $diskXLBytes - $swapXMBytes`
-			if [ $diskXABytes -lt 50 ];then
-				# /.../
-				# Very small disk which we will not re-partition
-				# ----
-				Echo &quot;Disk is too small, will not re-partition it&quot;
-				DONT_PARTITION=1
-			else
-				disk2MBytes=`expr $disk2MBytes + $diskXABytes`
-			fi
-		fi
-		if [ -z &quot;$DONT_PARTITION&quot; ];then
-			#======================================
-			# 10.4 write new partition table
-			#--------------------------------------
-			# /.../
-			# Explanation of the fdisk commands used within the
-			# here document below:
-			# ----
-			# d               # delete xda partition
-			# 2               # [ 2 ]
-			# n               # create xda partition at same place than xda2
-			# p               # primary
-			# 2               # [ 2 ]
-			#                 # accept old xda3 start block
-			# +&quot;disk2MBytes&quot;M # accept new RW device size of disk blocks - swap
-			# n               # create xda swap partition
-			# p               # primary
-			# 3               # [ 3 ]
-			#                 # accept start block
-			#                 # accept end block
-			# t               # change swap system id
-			# 3               # [ 3 ]
-			# 82              # Linux Swap
-			# w               # write partition table
-			# ----
-			input=/part.input
-			rm -f $input
-			for cmd in d 2 n p 2 . +&quot;$disk2MBytes&quot;M n p 3 . . t 3 82 w;do
-				if [ $cmd = &quot;.&quot; ];then
-					echo &gt;&gt; $input
-					continue
-				fi
-				echo $cmd &gt;&gt; $input
-			done
-			Echo &quot;Repartition the disk according to current geometry&quot;
-			fdisk $deviceDisk &lt; $input &gt;/dev/null 2&gt;&amp;1
-			if test $? != 0; then
-				systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
-			fi
-		fi
-		#======================================
-		# 10.5 Update new device names
-		#--------------------------------------
-		export deviceRoot=&quot;$deviceDisk&quot;1
-		export deviceSwap=&quot;$deviceDisk&quot;3
-		export deviceIOWR=&quot;$deviceDisk&quot;2
-
-		#======================================
-		# 10.6 Activate swap space
-		#--------------------------------------
-		if sfdisk -s $deviceSwap &amp;&gt;/dev/null;then
-			Echo &quot;Activating swap space on $deviceSwap&quot;
-			if ! mkswap $deviceSwap &gt;/dev/null 2&gt;&amp;1;then
-				systemException &quot;Failed to create swap signature&quot; &quot;reboot&quot;
-			fi
-		fi
-	else
-		if ! isFSTypeReadOnly;then
-			#======================================
-			# 10.2 write new partition table
-			#--------------------------------------
-			# /.../
-			# Explanation of the fdisk commands used within the
-			# here document below:
-			# ----
-			# d              # delete xda partition [ 1 ]
-			# n              # create xda partition at same place than xda1
-			# p              # primary
-			# 2              # [ 2 ]
-			# 1              # accept old xda1 start block for xda2
-			# +10240M        # accept new root device size of 10GB
-			# n              # create xda swap partition
-			# p              # primary
-			# 1              # [ 1 ]
-			#                # accept start block
-			# +&quot;$swapsize&quot;M  # accept new swapsize
-			# n              # create xda3 home partition
-			# p              # primary
-			# 3              # [ 3 ]
-			#                # accept start block
-			#                # accept end block, complete disk
-			# t              # change swap system id
-			# 1              # [ 1 ]
-			# 82             # Linux Swap
-			# w              # write partition table
-			# ----
-			input=/part.input
-			rm -f $input
-			diskXMBytes=`sfdisk -s $deviceDisk`
-			diskPMBytes=`sfdisk -s $deviceDisk&quot;1&quot;`
-			diskPMBytes=`expr $diskPMBytes / 1000`
-			diskXMBytes=`expr $diskXMBytes / 1000`
-			disk1MBytes=10240
-			# /.../
-			# set OEM_SYSTEMSIZE if available, else try to
-			# use 10GB system size
-			# ----
-			if [ ! -z &quot;$OEM_SYSTEMSIZE&quot; ];then
-				disk1MBytes=$OEM_SYSTEMSIZE
-			fi
-			# /.../
-			# prevent /home and recovery partition if requested
-			# system size is bigger than the whole disk
-			# ----
-			if [ $disk1MBytes -gt $diskXMBytes ];then
-				export OEM_WITHOUTHOME=1
-				unset OEM_RECOVERY
-				recoMByte=0
-			fi
-			# /.../
-			# recalculate system size if no /home partition
-			# will be used. size is whole disk minus swap
-			# minus recovery
-			# ----
-			if [ ! -z &quot;$OEM_WITHOUTHOME&quot; ];then
-				disk1MBytes=`expr $diskXMBytes - $swapsize - $recoMByte`
-			fi
-			# /.../
-			# check if requested system size is bigger than
-			# the existing system partition
-			# ----
-			if [ $disk1MBytes -lt $diskPMBytes ];then
-				# /.../
-				# Requested system partition size is smaller than
-				# existing partition, will not re-partition
-				# ----
-				Echo &quot;Current system partition is bigger than requested size&quot;
-				Echo &quot;Disk won't be re-partitioned&quot;
-				OEM_WITHOUTHOME=1
-				DONT_PARTITION=1
-				unset OEM_RECOVERY
-			fi
-			if [ -z &quot;$DONT_PARTITION&quot; ];then
-				if [ ! -z &quot;$OEM_WITHOUTHOME&quot; ];then
-					#======================================
-					# 10.2.1 without /home partition
-					#--------------------------------------
-					if [ -z &quot;$OEM_WITHOUTSWAP&quot; ];then
-						#======================================
-						# 10.2.1.1 with swap partition
-						#--------------------------------------
-						if [ -z &quot;$OEM_RECOVERY&quot; ];then
-							#======================================
-							# 10.2.1.1.1 without recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 1 . . \
-								t 1 82 w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						else
-							#======================================
-							# 10.2.1.1.2 with recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 4 . +&quot;$recoMByte&quot;M \
-								n p 1 . . \
-								t 1 82 w
-						do
-							if [ $cmd = &quot;.&quot; ];then
-								echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						fi
-					else
-						#======================================
-						# 10.2.1.2 without swap partition
-						#--------------------------------------
-						if [ -z &quot;$OEM_RECOVERY&quot; ];then
-							#======================================
-							# 10.2.1.2.1 without recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 . . w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						else
-							#======================================
-							# 10.2.1.2.2 with recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 4 . . w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						fi
-					fi
-				else
-					#======================================
-					# 10.2.2 with /home partition
-					#--------------------------------------
-					if [ -z &quot;$OEM_WITHOUTSWAP&quot; ];then
-						#======================================
-						# 10.2.2.1 with swap partition
-						#--------------------------------------
-						if [ -z &quot;$OEM_RECOVERY&quot; ];then
-							#======================================
-							# 10.2.2.1.1 without recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 1 . +&quot;$swapsize&quot;M \
-								n p 3 . . \
-								t 1 82 w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						else
-							#======================================
-							# 10.2.2.1.2 with recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 1 . +&quot;$swapsize&quot;M \
-								n p 4 . +&quot;$recoMByte&quot;M \
-								n p 3 . . \
-								t 1 82 w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						fi
-					else
-						#======================================
-						# 10.2.2.2 without swap partition
-						#--------------------------------------
-						if [ -z &quot;$OEM_RECOVERY&quot; ];then
-							#======================================
-							# 10.2.2.2.1 without recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 3 . . w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						else
-							#======================================
-							# 10.2.2.2.2 with recovery partition
-							#--------------------------------------
-							for cmd in \
-								d n p 2 1 +&quot;$disk1MBytes&quot;M \
-								n p 4 . +&quot;$recoMByte&quot;M \
-								n p 3 . . w
-							do
-								if [ $cmd = &quot;.&quot; ];then
-									echo &gt;&gt; $input
-									continue
-								fi
-								echo $cmd &gt;&gt; $input
-							done
-						fi
-					fi
-				fi
-				Echo &quot;Repartition the disk according to current geometry&quot;
-				fdisk $deviceDisk &lt; $input &gt;/dev/null 2&gt;&amp;1
-				if test $? != 0; then
-					systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
-				fi
-			fi
-			#======================================
-			# 10.3 Update new device names
-			#--------------------------------------
-			if [ -z &quot;$DONT_PARTITION&quot; ];then
-				export deviceRoot=&quot;$deviceDisk&quot;2
-				export deviceSwap=&quot;$deviceDisk&quot;1
-			else
-				export deviceRoot=&quot;$deviceDisk&quot;1
-			fi
-			if [ -z &quot;$OEM_WITHOUTHOME&quot; ];then
-				export deviceHome=&quot;$deviceDisk&quot;3
-			fi
-			if [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-				export deviceRecovery=&quot;$deviceDisk&quot;4
-			fi
-			#======================================
-			# 10.4 Activate swap space
-			#--------------------------------------
-			if sfdisk -s $deviceSwap &amp;&gt;/dev/null;then
-				Echo &quot;Activating swap space on $deviceSwap&quot;
-				if ! mkswap $deviceSwap &gt;/dev/null 2&gt;&amp;1;then
-					systemException &quot;Failed to create swap signature&quot; &quot;reboot&quot;
-				fi
-			fi
-			#======================================
-			# 10.5 Create home file system
-			#--------------------------------------
-			if [ -z &quot;$OEM_WITHOUTHOME&quot; ];then
-				Echo &quot;Creating Home filesystem on $deviceHome&quot;
-				if ! mke2fs -j -q $deviceHome &gt;/dev/null 2&gt;&amp;1;then
-					systemException &quot;Failed to create Home fs&quot; &quot;reboot&quot;
-				fi
-			fi
-			#======================================
-			# 10.6 Create recovery file system
-			#--------------------------------------
-			if [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-				Echo &quot;Creating Recovery filesystem on $deviceRecovery&quot;
-				if ! mke2fs -j -q $deviceRecovery &gt;/dev/null 2&gt;&amp;1;then
-					systemException &quot;Failed to create Recovery fs&quot; &quot;reboot&quot;
-				fi
-			fi
-			#======================================
-			# 10.7 Setup recovery contents
-			#--------------------------------------
-			if [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-				Echo &quot;Setting up recovery archive...&quot;
-				mkdir -p /reco-root
-				if ! mount $deviceRoot /reco-root &gt;/dev/null;then
-					systemException &quot;Failed to mount root device&quot; &quot;reboot&quot;
-				fi
-				mkdir -p /reco-save
-				if ! mount $deviceRecovery /reco-save &gt;/dev/null;then
-					systemException &quot;Failed to mount recovery device&quot; &quot;reboot&quot;
-				fi
-				if ! mv /reco-root/recovery.tar.gz /reco-save &gt;/dev/null;then
-					systemException &quot;Failed to move recovery archive&quot; &quot;reboot&quot;
-				fi
-				mkdir /reco-save/boot
-				if ! cp /reco-root/boot/initrd.vmx /reco-save/boot/initrd;then
-					systemException &quot;Failed to copy recovery initrd&quot; &quot;reboot&quot;
-				fi
-				if ! cp /reco-root/boot/linux.vmx /reco-save/boot/vmlinuz;then
-					systemException &quot;Failed to copy recovery kernel&quot; &quot;reboot&quot;
-				fi
-				umount /reco-save &amp;&amp; rmdir /reco-save
-				umount /reco-root &amp;&amp; rmdir /reco-root
-			fi
-		else
-			#====================================== 
-			# 10.2 no recovery support in this mode
-			#--------------------------------------
-			unset OEM_RECOVERY
-			#======================================
-			# 10.2 calculate end block - swapspace
-			#--------------------------------------
-			swapXMBytes=$swapsize
-			diskXMBytes=`sfdisk -s $deviceDisk`
-			diskXMBytes=`expr $diskXMBytes / 1000`
-			disk1MBytes=`sfdisk -s &quot;$deviceDisk&quot;1`
-			disk1MBytes=`expr $disk1MBytes / 1000`
-			disk2MBytes=`expr $diskXMBytes - $disk1MBytes - $swapsize`
-			if [ $disk2MBytes -lt 100 ];then
-				# /.../
-				# Very small disk which we will not re-partition
-				# ----
-				Echo &quot;Disk is too small, will not re-partition it&quot;
-				DONT_PARTITION=1
-			fi
-			if [ -z &quot;$DONT_PARTITION&quot; ];then
-				#======================================
-				# 10.3 write new partition table
-				#--------------------------------------
-				# /.../
-				# Explanation of the fdisk commands used within the
-				# here document below:
-				# ----
-				# d               # delete xda partition
-				# 2               # [ 2 ]
-				# n               # create xda partition at same place than xda2
-				# p               # primary
-				# 2               # [ 2 ]
-				#                 # accept old xda2 start block
-				# +&quot;disk2MBytes&quot;M # accept new RW device size
-				# n               # create xda swap partition
-				# p               # primary
-				# 3               # [ 3 ]
-				#                 # accept start block
-				#                 # accept end block
-				# t               # change swap system id
-				# 3               # [ 3 ]
-				# 82              # Linux Swap
-				# w               # write partition table
-				# ----
-				input=/part.input
-				rm -f $input
-				for cmd in d 2 n p 2 . +&quot;$disk2MBytes&quot;M n p 3 . . t 3 82 w;do
-					if [ $cmd = &quot;.&quot; ];then
-						echo &gt;&gt; $input
-						continue
-					fi
-					echo $cmd &gt;&gt; $input
-				done
-				Echo &quot;Repartition the disk according to current geometry&quot;
-				fdisk $deviceDisk &lt; $input &gt;/dev/null 2&gt;&amp;1
-				if test $? != 0; then
-					systemException &quot;Failed to create partition table&quot; &quot;reboot&quot;
-				fi
-			fi
-			#======================================
-			# 10.4 Update new device names
-			#--------------------------------------
-			export deviceRoot=&quot;$deviceDisk&quot;1
-			export deviceSwap=&quot;$deviceDisk&quot;3
-			export deviceIOWR=&quot;$deviceDisk&quot;2
-
-			#======================================
-			# 10.5 Activate swap space
-			#--------------------------------------
-			if sfdisk -s $deviceSwap &amp;&gt;/dev/null;then
-				Echo &quot;Activating swap space on $deviceSwap&quot;
-				if ! mkswap $deviceSwap &gt;/dev/null 2&gt;&amp;1;then
-					systemException &quot;Failed to create swap signature&quot; &quot;reboot&quot;
-				fi
-			fi
-		fi
-	fi
-fi
-
-#======================================
-# 11) Resize filesystem to full space
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	deviceResize=$deviceRoot
-	if [ ! -z $COMBINED_IMAGE ];then
-		deviceResize=$deviceIOWR
-		KIWI_INITRD_PARAMS=&quot;COMBINED_IMAGE=local&quot;
-		export KIWI_INITRD_PARAMS
-	fi
-	if isFSTypeReadOnly &amp;&amp; [ -z &quot;$COMBINED_IMAGE&quot; ];then
-		deviceResize=$deviceIOWR
-		export UNIONFS_CONFIG=&quot;$deviceDisk&quot;2,&quot;$deviceDisk&quot;1,aufs
-		KIWI_INITRD_PARAMS=&quot;UNIONFS_CONFIG=\&quot;$UNIONFS_CONFIG\&quot;&quot;
-		KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS deviceRoot=\&quot;$deviceRoot\&quot;&quot;
-		export KIWI_INITRD_PARAMS
-	fi
-	if [ ! -z &quot;$deviceResize&quot; ] &amp;&amp; sfdisk -s $deviceResize &amp;&gt;/dev/null;then
-		if [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-			KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS LOCAL_BOOT=yes&quot;
-			KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS deviceRoot=$deviceRoot&quot;
-			KIWI_INITRD_PARAMS=&quot;$KIWI_INITRD_PARAMS deviceRecovery=$deviceRecovery&quot;
-			export KIWI_INITRD_PARAMS
-		fi
-		if [ &quot;$FSTYPE&quot; = &quot;reiserfs&quot; ];then
-			Echo &quot;Resize Reiser filesystem to full partition space...&quot;
-			resize_reiserfs -q $deviceResize
-			INITRD_MODULES=&quot;$INITRD_MODULES reiserfs&quot;
-		fi
-		if [ &quot;$FSTYPE&quot; = &quot;ext2&quot; ];then
-			Echo &quot;Resize EXT2 filesystem to full partition space...&quot;
-			resize2fs -f -F -p $deviceResize
-			Echo &quot;Checking EXT2 filesystem...&quot;
-			e2fsck -y -f $deviceResize
-			INITRD_MODULES=&quot;$INITRD_MODULES ext2&quot;
-		fi
-		if [ &quot;$FSTYPE&quot; = &quot;ext3&quot; ];then
-			Echo &quot;Resize EXT3 filesystem to full partition space...&quot;
-			resize2fs -f -F -p $deviceResize
-			Echo &quot;Checking EXT3 filesystem...&quot;
-			e2fsck -y -f $deviceResize
-			INITRD_MODULES=&quot;$INITRD_MODULES ext3&quot;
-		fi
-	fi
-fi
-
-#======================================
-# 12) Mount system
-#--------------------------------------
-if ! mountSystem $deviceRoot;then
-	systemException &quot;Failed to mount root filesystem&quot; &quot;reboot&quot;
-fi
-validateRootTree
-
-#======================================
-# 13) Recover system if requested
-#--------------------------------------
-if [ ! -z &quot;$KIWI_RECOVERY&quot; ];then
-	Echo -n &quot;Do you want to start the System-Recovery ? [y/n]: &quot;; read runReco
-	if [ ! $runReco = &quot;y&quot; ];then
-		systemException &quot;System-Recovery not started&quot; &quot;reboot&quot;
-	fi
-	Echo &quot;Starting System-Recovery...&quot;
-	#======================================
-	# 13.1) mount recovery partition
-	#--------------------------------------
-	mkdir -p /reco-save
-	if ! mount $deviceRecovery /reco-save &gt;/dev/null;then
-		systemException &quot;Failed to mount recovery device&quot; &quot;reboot&quot;
-	fi
-	#======================================
-	# 13.2) restore root archive
-	#--------------------------------------
-	Echo &quot;Restoring base operating system...&quot;
-	cd /mnt
-	if ! tar -xvf /reco-save/recovery.tar.gz 1&gt;&amp;2;then
-		systemException &quot;Failed to restore recovery archive&quot; &quot;reboot&quot;
-	fi
-	#======================================
-	# 13.3) restore boot files
-	#--------------------------------------
-	Echo &quot;Restoring boot files...&quot;
-	for i in etc/fstab etc/sysconfig/kernel etc/sysconfig/bootloader;do
-		if ! cp /reco-save/$i /mnt/$i;then
-			systemException &quot;Failed to restore $i&quot; &quot;reboot&quot;
-		fi
-	done
-	for i in `setupBootLoaderFiles`;do
-		if ! cp /reco-save/$i /mnt/$i;then
-			systemException &quot;Failed to restore $i&quot; &quot;reboot&quot;
-		fi
-	done
-	for i in /reco-save/boot/grub/*;do
-		if echo $i | grep -q .system;then
-			sysbase=`echo ${i%%.system}`
-			sysbase=`echo $sysbase | cut -f3- -d/`
-			cp $i /mnt/$sysbase
-		fi
-	done
-	#======================================
-	# 13.4) umount recovery and boot
-	#--------------------------------------
-	umount $deviceRecovery
-	deviceDisk=`echo $deviceRoot | tr -d &quot;[:digit:]&quot;`
-fi
-
-#======================================
-# 14) get installed kernels
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	kernelList /mnt
-fi
-
-#======================================
-# 15) Create system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	export HAVE_SWAP=0
-	setupDefaultFstab /config
-	if sfdisk -s $deviceSwap &amp;&gt;/dev/null;then
-		updateSwapDeviceFstab /config $deviceSwap
-		HAVE_SWAP=1
-	fi
-	if [ -z &quot;$UNIONFS_CONFIG&quot; ] &amp;&amp; [ -z &quot;$COMBINED_IMAGE&quot; ]; then
-		echo &quot;$deviceRoot / $FSTYPE defaults 0 0&quot; &gt;&gt; /config/etc/fstab
-		if [ -z &quot;$OEM_WITHOUTHOME&quot; ] &amp;&amp; [ -z &quot;$DONT_PARTITION&quot; ];then
-			if [ `ls /mnt/home/ | wc -l` != 0 ]; then
-				Echo &quot;Found non empty home/ directory !&quot;
-				Echo &quot;Moving home/ data to home partition $deviceHome&quot;
-				mount $deviceHome /mnt/mnt &amp;&amp; mv /mnt/home/* /mnt/mnt
-				umount /mnt/mnt
-			fi
-			Echo &quot;Activate home partition $deviceHome in fstab&quot;
-			echo &quot;$deviceHome /home ext3 defaults 0 0&quot; &gt;&gt; /config/etc/fstab
-		fi
-	fi
-	if [ -z &quot;$UNIONFS_CONFIG&quot; ] &amp;&amp; [ -z &quot;$COMBINED_IMAGE&quot; ]; then
-		Echo &quot;Creating boot loader configuration&quot;
-		if [ -z &quot;$OEM_BOOT_TITLE&quot; ];then
-			export OEM_BOOT_TITLE=&quot;OEM&quot;
-		fi
-		if [ ! -z $OEM_RECOVERY ];then
-			OEM_RECOVERY=${deviceDisk}4
-		fi
-		bootid=`echo $deviceRoot | tr -d &quot;[:alpha:]//&quot;`
-		bootid=`expr $bootid - 1`
-		setupBootLoader \
-			/mnt /config $bootid $deviceRoot $OEM_BOOT_TITLE $deviceSwap
-	fi
-	setupKernelModules /config
-fi
-
-#======================================
-# 16) copy system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	cd /config
-	find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
-	find . -type f | while read f ; do  cp $f /mnt/$f ; done
-	cd /
-	rm -rf /config
-fi
-
-#======================================
-# 17) copy recovery related files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ] &amp;&amp; [ ! -z &quot;$OEM_RECOVERY&quot; ];then
-	IFS=$IFS_ORIG
-	Echo &quot;Setting up recovery configuration files...&quot;
-	mkdir -p /reco-save
-	if ! mount $deviceRecovery /reco-save &gt;/dev/null;then
-		systemException &quot;Failed to mount recovery device&quot; &quot;reboot&quot;
-	fi
-	mkdir -p /reco-save/etc/sysconfig
-	if ! cp /mnt/etc/fstab /reco-save/etc;then
-		systemException &quot;Failed to copy recovery fstab&quot; &quot;reboot&quot;
-	fi
-	if ! cp /mnt/etc/sysconfig/kernel /reco-save/etc/sysconfig;then
-		systemException &quot;Failed to copy recovery sysconfig/kernel&quot; &quot;reboot&quot;
-	fi
-	if ! cp /mnt/etc/sysconfig/bootloader /reco-save/etc/sysconfig;then
-		systemException &quot;Failed to copy recovery sysconfig/bootloader&quot; &quot;reboot&quot;
-	fi
-	for i in `setupBootLoaderFiles`;do
-		bootdir=`dirname $i` &amp;&amp; mkdir -p /reco-save/$bootdir
-		if ! cp /mnt/$i /reco-save/$i;then
-			systemException &quot;Failed to copy recovery $i&quot; &quot;reboot&quot;
-		fi
-	done
-	Echo &quot;Installing boot loader into recovery partition&quot;
-	setupBootLoaderRecovery /mnt /reco-save OEM
-	umount /reco-save &amp;&amp; rmdir /reco-save
-	installBootLoaderRecovery
-fi
-
-#======================================
-# 18) setup real root device
-#--------------------------------------
-echo 256 &gt; /proc/sys/kernel/real-root-dev
-
-#======================================
-# 19) umount system filesystems
-#--------------------------------------
-umountSystemFilesystems
-
-#======================================
-# 20) copy initrd files to image
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	importBranding
-fi
-cp /preinit /mnt
-cp /include /mnt
-
-#======================================
-# 21) kill boot shell
-#--------------------------------------
-killShell
-killBlogD
-
-#======================================
-# 22) Activate new root
-#--------------------------------------
-Echo &quot;Activating Image: [$deviceDisk]&quot;
-reopenKernelConsole
-/sbin/udevsettle --timeout=30
-mount --move /dev /mnt/dev
-udevKill
-
-#======================================
-# 23) call preinit phase
-#--------------------------------------
-Echo &quot;Calling preinit phase...&quot;
-cd /mnt
-/mnt/sbin/pivot_root . mnt &gt;/dev/null 2&gt;&amp;1
-if test $? != 0;then
-	PIVOT=false
-	cleanInitrd &amp;&amp; mount --move . / &amp;&amp; chroot . ./preinit
-	chroot . rm -f  ./preinit
-	chroot . rm -f  ./include
-	chroot . rm -rf ./image
-else
-	PIVOT=true
-	./preinit
-	rm -f  ./preinit
-	rm -f  ./include
-	rm -rf ./image
-fi
-
-#======================================
-# 24 Unmount initrd / system init
-#--------------------------------------
-echo &quot; &quot;
-echo &quot;Booting into final System...&quot;
-echo &quot;----------------------------&quot;
-export IFS=$IFS_ORIG
-if [ ! -z &quot;$OEM_REBOOT&quot; ];then
-	mount -n -o remount,ro / 2&gt;/dev/null
-	Echo &quot;Reboot requested... rebooting now&quot;
-	/sbin/reboot -f -i &gt;/dev/null 2&gt;&amp;1
-fi
-mount -n -o remount,rw / 2&gt;/dev/null
-if [ $PIVOT = &quot;true&quot; ];then
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec umount -n -l /mnt
-else
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec chroot . /sbin/init $@
-fi
-

Copied: kiwi-head/system/boot/ix86/oemboot/suse-linuxrc (from rev 1474, kiwi-head/system/boot/oemboot/suse-linuxrc)

Copied: kiwi-head/system/boot/ix86/usbboot (from rev 1473, kiwi-head/system/boot/usbboot)


Property changes on: kiwi-head/system/boot/ix86/usbboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: kiwi-head/system/boot/ix86/usbboot/suse-linuxrc
===================================================================
--- kiwi-head/system/boot/usbboot/suse-linuxrc	2008-07-23 09:16:44 UTC (rev 1473)
+++ kiwi-head/system/boot/ix86/usbboot/suse-linuxrc	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,210 +0,0 @@
-#!/bin/bash
-#================
-# FILE          : linuxrc
-#----------------
-# PROJECT       : OpenSuSE KIWI Image System
-# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
-#               :
-# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
-#               :
-# BELONGS TO    : Operating System images
-#               :
-# DESCRIPTION   : This file is changed to become the real
-#               : linuxrc script which is used to prepare the
-#               : operating system for the main image
-#               :
-#               :
-# STATUS        : BETA
-#----------------
-#======================================
-# Exports (General)...
-#--------------------------------------
-export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
-export IFS_ORIG=$IFS
-export DEBUG=0
-
-#======================================
-# Exports (Booting)
-#--------------------------------------
-export LOCAL_BOOT=no
-export systemIntegrity=&quot;clean&quot;
-export stickFound=0
-
-#======================================
-# Functions...
-#--------------------------------------
-. /include
-
-#======================================
-# Beautify Startup
-#--------------------------------------
-echo &quot;Loading KIWI USB-Stick Boot-System...&quot;
-echo &quot;-------------------------------------&quot;
-
-#======================================
-# 1) Mounting local file systems
-#--------------------------------------
-mountSystemFilesystems &amp;&gt;/dev/null
-closeKernelConsole
-
-#======================================
-# 2) Prepare module load support 
-#--------------------------------------
-touch /etc/modules.conf
-touch /lib/modules/*/modules.dep
-
-#======================================
-# 3) run udevd
-#--------------------------------------
-udevStart
-
-#======================================
-# 4) start boot shell
-#--------------------------------------
-startBlogD
-startShell
-errorLogStart
-openKernelConsole
-
-#======================================
-# 5) Including required kernel modules
-#--------------------------------------
-includeKernelParameters
-probeDevices
-
-#======================================
-# 6) Load USB storage modules
-#--------------------------------------
-for module in ehci-hcd uhci-hcd usb_storage sg sd_mod BusLogic;do
-	modprobe $module &amp;&gt;/dev/null
-done
-
-#======================================
-# 7) Search USB stick device
-#--------------------------------------
-USBStickDevice
-if [ $stickFound = 0 ];then
-	systemException \
-		&quot;No USB stick found... abort&quot; \
-	&quot;reboot&quot;
-fi
-
-#======================================
-# 8) Probe filesystem of stick system
-#--------------------------------------
-probeFileSystem $stickDevice
-if [ $FSTYPE = &quot;unknown&quot; ];then
-	systemException \
-		&quot;Couldn't determine filesystem type... abort&quot; \
-	&quot;reboot&quot;
-fi
-
-#======================================
-# 9) Resize filesystem to full space
-#--------------------------------------
-Echo &quot;Filesystem of stick system is: $FSTYPE -&gt; $stickDevice&quot;
-if isFSTypeReadOnly;then
-	export UNIONFS_CONFIG=&quot;$stickRoot&quot;2,&quot;$stickRoot&quot;1,aufs
-fi
-
-#======================================
-# 10) Mount USB stick (system)
-#--------------------------------------
-if ! mountSystem $stickDevice;then
-	systemException &quot;Failed to mount root filesystem&quot; &quot;reboot&quot;
-fi
-validateRootTree
-
-#======================================
-# 11) Create system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		setupDefaultFstab /config
-		updateRootDeviceFstab /config $stickDevice
-	fi
-fi
-
-#======================================
-# 12) copy system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	if test $systemIntegrity = &quot;clean&quot;;then
-		cd /config
-		find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
-		find . -type f | while read f ; do  cp $f /mnt/$f ; done
-		cd /
-		rm -rf /config
-	fi
-fi
-
-#======================================
-# 13) setup real root device
-#--------------------------------------
-echo 256 &gt; /proc/sys/kernel/real-root-dev
-
-#======================================
-# 14) umount system filesystems
-#--------------------------------------
-umountSystemFilesystems
-
-#======================================
-# 15) copy initrd files to image
-#--------------------------------------
-if [ ! -f /mnt/boot/deployed ];then
-	touch /mnt/boot/deployed
-	importBranding
-fi
-cp /preinit /mnt
-cp /include /mnt
-
-#======================================
-# 16) kill boot shell
-#--------------------------------------
-killShell
-killBlogD
-
-#======================================
-# 17) Activate new root
-#--------------------------------------
-Echo &quot;Activating Image: [$stickSerial on -&gt; $stickDevice]&quot;
-reopenKernelConsole
-/sbin/udevsettle --timeout=30
-mount --move /dev /mnt/dev
-udevKill
-
-#======================================
-# 18) call preinit phase
-#--------------------------------------
-Echo &quot;Calling preinit phase...&quot;
-cd /mnt
-/mnt/sbin/pivot_root . mnt &gt;/dev/null 2&gt;&amp;1
-if test $? != 0;then
-	PIVOT=false
-	cleanInitrd &amp;&amp; mount --move . / &amp;&amp; chroot . ./preinit
-	chroot . rm -f  ./preinit
-	chroot . rm -f  ./include
-	chroot . rm -rf ./image
-else
-	PIVOT=true
-	./preinit
-	rm -f  ./preinit
-	rm -f  ./include
-	rm -rf ./image
-fi
-
-#======================================
-# 19) Unmount initrd / system init
-#--------------------------------------
-echo &quot; &quot;
-echo &quot;Booting into USB-Stick System...&quot;
-echo &quot;--------------------------------&quot;
-export IFS=$IFS_ORIG
-mount -n -o remount,rw / &amp;&gt;/dev/null
-if [ $PIVOT = &quot;true&quot; ];then
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec umount -n -l /mnt
-else
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec chroot . /sbin/init $@
-fi

Copied: kiwi-head/system/boot/ix86/usbboot/suse-linuxrc (from rev 1474, kiwi-head/system/boot/usbboot/suse-linuxrc)

Copied: kiwi-head/system/boot/ix86/vmxboot (from rev 1473, kiwi-head/system/boot/vmxboot)


Property changes on: kiwi-head/system/boot/ix86/vmxboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: kiwi-head/system/boot/ix86/vmxboot/suse-linuxrc
===================================================================
--- kiwi-head/system/boot/vmxboot/suse-linuxrc	2008-07-23 09:16:44 UTC (rev 1473)
+++ kiwi-head/system/boot/ix86/vmxboot/suse-linuxrc	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,278 +0,0 @@
-#!/bin/bash
-#================
-# FILE          : linuxrc
-#----------------
-# PROJECT       : OpenSuSE KIWI Image System
-# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
-#               :
-# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
-#               :
-# BELONGS TO    : Operating System images
-#               :
-# DESCRIPTION   : This file is changed to become the real
-#               : linuxrc script which is used to prepare the
-#               : operating system for the main image
-#               :
-#               :
-# STATUS        : BETA
-#----------------
-#======================================
-# Exports (General)
-#--------------------------------------
-export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
-export IFS_ORIG=$IFS
-export ARCH=`arch`
-export DEBUG=0
-
-#======================================
-# Exports (Booting)
-#--------------------------------------
-export DOMURD_MODULES=&quot;xennet xenblk&quot;
-export INITRD_MODULES=&quot;reiserfs&quot;
-export LOCAL_BOOT=&quot;no&quot;
-export systemIntegrity=&quot;clean&quot;
-export KERNEL_LIST
-
-#======================================
-# Exports (Alias)
-#--------------------------------------
-export SYSALIAS=&quot;undefined&quot;
-export NAME=0
-
-#======================================
-# Exports (Partitioning)
-#--------------------------------------
-export PART_FILE=&quot;/etc/partition.table&quot;
-export PART_MOUNT
-export PART_DEV
-export PART_COUNT=0
-export PART_NUMBER=0
-export PART_NEED_EXTENDED=0
-export PART_NEED_FILL=0
-export NO_FILE_SYSTEM=0
-
-#======================================
-# Exports (Status)
-#--------------------------------------
-export SYSTEM_INTEGRITY
-export SYSTEM_MD5STATUS
-
-#======================================
-# Functions
-#--------------------------------------
-. /include
-
-#======================================
-# Functions
-#--------------------------------------
-function VMFindSystem {
-	local haveSDA=0
-	local haveHDA=0
-	local devices=&quot;&quot;
-	waitForStorageDevice /dev/sda
-	if [ ! -e /dev/sda ];then
-		waitForStorageDevice /dev/hda
-		if [ -e /dev/hda ];then
-			haveHDA=1
-			devices=&quot;/dev/hda1 /dev/hda2&quot;
-		fi
-	else
-		haveSDA=1
-		devices=&quot;/dev/sda1 /dev/sda2&quot;
-	fi
-	if [ $haveSDA = 0 ] &amp;&amp; [ $haveHDA = 0 ];then
-		systemException \
-			&quot;Couldn't find any storage device... abort&quot; \
-		&quot;reboot&quot;
-	fi
-	for rdevice in $devices;do
-		imageRootDevice=$rdevice
-		imageDiskDevice=`echo $imageRootDevice | tr -d [0-9]`
-		if kiwiMount $imageRootDevice &quot;/mnt&quot; &amp;&gt;/dev/null;then
-			umount /mnt
-			break
-		fi
-	done
-}
-#======================================
-# Beautify Startup
-#--------------------------------------
-echo &quot;Loading KIWI VMX Boot-System...&quot;
-echo &quot;-------------------------------&quot;
-
-#======================================
-# 1) Mounting local file systems
-#--------------------------------------
-mountSystemFilesystems &amp;&gt;/dev/null
-closeKernelConsole
-
-#======================================
-# 2) Prepare module load support 
-#--------------------------------------
-touch /etc/modules.conf
-touch /lib/modules/*/modules.dep
-
-#======================================
-# 3) run udevd
-#--------------------------------------
-udevStart
-
-#======================================
-# 4) start boot shell
-#--------------------------------------
-startBlogD
-startShell
-errorLogStart
-openKernelConsole
-
-#======================================
-# 5) Include proc/cmdline information
-#--------------------------------------
-includeKernelParameters
-if [ ! -z $UNIONFS_CONFIG ] || [ &quot;$COMBINED_IMAGE&quot; = &quot;local&quot; ];then
-	# /.../
-	# if the unionfs/combined information is already in place at this
-	# stage it comes from the cmdline data which means we are not
-	# booting the first time
-	# ----
-	export LOCAL_BOOT=&quot;yes&quot;
-fi
-
-#======================================
-# 6) Including required kernel modules
-#--------------------------------------
-probeDevices
-
-#======================================
-# 7) Mount VM (boot)
-#--------------------------------------
-VMFindSystem
-
-#======================================
-# 8) Get filesystem type
-#--------------------------------------
-probeFileSystem $imageRootDevice
-if [ $FSTYPE = &quot;unknown&quot; ];then
-	systemException \
-		&quot;Couldn't determine filesystem type... abort&quot; \
-	&quot;reboot&quot;
-fi
-
-#======================================
-# 9) Check filesystem
-#--------------------------------------
-Echo &quot;Filesystem of VMX system is: $FSTYPE -&gt; $imageRootDevice&quot;
-if isFSTypeReadOnly;then
-	export UNIONFS_CONFIG=&quot;$imageDiskDevice&quot;2,&quot;$imageDiskDevice&quot;1,aufs
-fi
-
-#======================================
-# 10) Mount VM (boot)
-#--------------------------------------
-if ! mountSystem $imageRootDevice;then
-	systemException &quot;Failed to mount root filesystem&quot; &quot;reboot&quot;
-fi
-validateRootTree
-
-#======================================
-# 11) Get kernel list for local boot
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	kernelList /mnt
-fi
-
-#======================================
-# 11) Create system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	setupDefaultFstab /config
-	updateRootDeviceFstab /config $imageRootDevice
-	if [ -z &quot;$UNIONFS_CONFIG&quot; ]; then
-		setupBootLoader /mnt /config 0 $imageRootDevice VMX
-	else
-		export KIWI_INITRD_PARAMS=&quot;UNIONFS_CONFIG=\&quot;$UNIONFS_CONFIG\&quot;&quot;
-		setupBootLoader /mnt /config 1 $imageRootDevice VMX
-	fi
-	setupKernelModules /config
-fi
-
-#======================================
-# 12) copy system dependant files
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	cd /config
-	find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
-	find . -type f | while read f ; do  cp $f /mnt/$f ; done
-	cd /
-	rm -rf /config
-fi
-
-#======================================
-# 13) setup real root device
-#--------------------------------------
-echo 256 &gt; /proc/sys/kernel/real-root-dev
-
-#======================================
-# 14) umount system filesystems
-#--------------------------------------
-umountSystemFilesystems
-
-#======================================
-# 15) copy initrd files to image
-#--------------------------------------
-if [ $LOCAL_BOOT = &quot;no&quot; ];then
-	importBranding
-fi
-cp /preinit /mnt
-cp /include /mnt
-
-#======================================
-# 16) kill boot shell
-#--------------------------------------
-killShell
-killBlogD
-
-#======================================
-# 17) Activate new root
-#--------------------------------------
-Echo &quot;Activating Image: [$imageRootDevice]&quot;
-reopenKernelConsole
-/sbin/udevsettle --timeout=30
-mount --move /dev /mnt/dev
-udevKill
-
-#======================================
-# 18) call preinit phase
-#--------------------------------------
-Echo &quot;Calling preinit phase...&quot;
-cd /mnt
-/mnt/sbin/pivot_root . mnt &gt;/dev/null 2&gt;&amp;1
-if test $? != 0;then
-	PIVOT=false
-	cleanInitrd &amp;&amp; mount --move . / &amp;&amp; chroot . ./preinit
-	chroot . rm -f  ./preinit
-	chroot . rm -f  ./include
-	chroot . rm -rf ./image
-else
-	PIVOT=true
-	./preinit
-	rm -f  ./preinit
-	rm -f  ./include
-	rm -rf ./image
-fi
-
-#======================================
-# 19) Unmount initrd / system init
-#--------------------------------------
-echo &quot; &quot;
-echo &quot;Booting into final System...&quot;
-echo &quot;----------------------------&quot;
-export IFS=$IFS_ORIG
-mount -n -o remount,rw / 2&gt;/dev/null
-if [ $PIVOT = &quot;true&quot; ];then
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec umount -n -l /mnt
-else
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec chroot . /sbin/init $@
-fi

Copied: kiwi-head/system/boot/ix86/vmxboot/suse-linuxrc (from rev 1474, kiwi-head/system/boot/vmxboot/suse-linuxrc)

Copied: kiwi-head/system/boot/ix86/xenboot (from rev 1473, kiwi-head/system/boot/xenboot)


Property changes on: kiwi-head/system/boot/ix86/xenboot
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: kiwi-head/system/boot/ix86/xenboot/suse-linuxrc
===================================================================
--- kiwi-head/system/boot/xenboot/suse-linuxrc	2008-07-23 09:16:44 UTC (rev 1473)
+++ kiwi-head/system/boot/ix86/xenboot/suse-linuxrc	2008-07-24 10:41:47 UTC (rev 1481)
@@ -1,207 +0,0 @@
-#!/bin/bash
-#================
-# FILE          : linuxrc
-#----------------
-# PROJECT       : OpenSuSE KIWI Image System
-# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
-#               :
-# AUTHOR        : Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;
-#               :
-# BELONGS TO    : Operating System images
-#               :
-# DESCRIPTION   : This file is changed to become the real
-#               : linuxrc script which is used to prepare the
-#               : operating system for the main image
-#               :
-#               :
-# STATUS        : BETA
-#----------------
-#======================================
-# Exports (General)...
-#--------------------------------------
-export PATH=&quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;
-export IFS_ORIG=$IFS
-export DEBUG=0
-export systemIntegrity=clean
-
-#======================================
-# Functions...
-#--------------------------------------
-. /include
-
-#======================================
-# Functions...
-#--------------------------------------
-VMFindSystem () {
-	local haveSDA=0
-	local haveHDA=0
-	local devices=&quot;&quot;
-	waitForStorageDevice /dev/sda1
-	if [ ! -e /dev/sda1 ];then
-		waitForStorageDevice /dev/hda1
-		if [ -e /dev/hda1 ];then
-			haveHDA=1
-			devices=&quot;/dev/hda1 /dev/hda&quot;
-		fi
-	else
-		haveSDA=1
-		devices=&quot;/dev/sda1 /dev/sda&quot;
-	fi
-	if [ $haveSDA = 0 ] &amp;&amp; [ $haveHDA = 0 ];then
-		systemException \
-			&quot;Couldn't find any storage device... abort&quot; \
-		&quot;reboot&quot;
-	fi
-	for rdevice in $devices;do
-		imageRootDevice=$rdevice
-		if kiwiMount $imageRootDevice &quot;/mnt&quot; &amp;&gt;/dev/null;then
-			umount /mnt
-			break
-		fi
-	done
-}
-#======================================
-# Beautify Startup
-#--------------------------------------
-echo &quot;Loading KIWI Xen Boot-System...&quot;
-echo &quot;-------------------------------&quot;
-
-#======================================
-# 1) Mounting local file systems
-#--------------------------------------
-mountSystemFilesystems &amp;&gt;/dev/null
-closeKernelConsole
-
-#======================================
-# 2) Prepare module load support 
-#--------------------------------------
-touch /etc/modules.conf
-touch /lib/modules/*/modules.dep
-
-#======================================
-# 3) run udevd
-#--------------------------------------
-udevStart
-
-#======================================
-# 4) start boot shell
-#--------------------------------------
-startBlogD
-startShell
-errorLogStart
-openKernelConsole
-
-#======================================
-# 5) Including required kernel modules
-#--------------------------------------
-Echo &quot;Including required kernel modules...&quot;
-includeKernelParameters
-for module in xennet xenblk reiserfs ext2 ext3 loop ipv6;do
-	modprobe $module &gt;/dev/null 2&gt;&amp;1
-done
-
-#======================================
-# 6) Mount VM (boot)
-#--------------------------------------
-VMFindSystem
-
-#======================================
-# 7) Get filesystem type
-#--------------------------------------
-probeFileSystem $imageRootDevice
-if [ $FSTYPE = &quot;unknown&quot; ];then
-	systemException \
-		&quot;Couldn't determine filesystem type... abort&quot; \
-	&quot;reboot&quot;
-fi
-
-#======================================
-# 8) Mount VM (boot)
-#--------------------------------------
-if ! mountSystem $imageRootDevice;then
-	systemException &quot;Failed to mount root filesystem&quot; &quot;reboot&quot;
-fi
-validateRootTree
-
-#======================================
-# 9) Create system dependant files
-#--------------------------------------
-setupDefaultFstab /config
-updateRootDeviceFstab /config $imageRootDevice
-
-#======================================
-# 10) copy system dependant files
-#--------------------------------------
-cd /config
-find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
-find . -type f | while read f ; do  cp $f /mnt/$f ; done
-cd /
-rm -rf /config
-
-#======================================
-# 11) setup real root device
-#--------------------------------------
-echo 256 &gt; /proc/sys/kernel/real-root-dev
-
-#======================================
-# 12) umount system filesystems
-#--------------------------------------
-umountSystemFilesystems
-
-#======================================
-# 13) copy initrd files to image
-#--------------------------------------
-importBranding
-cp /preinit /mnt
-cp /include /mnt
-
-#======================================
-# 14) kill boot shell
-#--------------------------------------
-killShell
-killBlogD
-
-#======================================
-# 15) Activate new root
-#--------------------------------------
-Echo &quot;Activating Image: [$imageRootDevice]&quot;
-reopenKernelConsole
-/sbin/udevsettle --timeout=30
-mount --move /dev /mnt/dev
-udevKill
-
-#======================================
-# 16) call preinit phase
-#--------------------------------------
-Echo &quot;Calling preinit phase...&quot;
-cd /mnt
-/mnt/sbin/pivot_root . mnt &gt;/dev/null 2&gt;&amp;1
-if test $? != 0;then
-	PIVOT=false
-	cleanInitrd &amp;&amp; mount --move . / &amp;&amp; chroot . ./preinit
-	chroot . rm -f  ./preinit
-	chroot . rm -f  ./include
-	chroot . rm -rf ./image
-else
-	PIVOT=true
-	./preinit
-	rm -f  ./preinit
-	rm -f  ./include
-	rm -rf ./image
-fi
-
-#======================================
-# 17) Unmount initrd / system init
-#--------------------------------------
-echo &quot; &quot;
-echo &quot;Booting into Xen System...&quot;
-echo &quot;--------------------------&quot;
-export IFS=$IFS_ORIG
-mount -n -o remount,rw / &amp;&gt;/dev/null
-if [ $PIVOT = &quot;true&quot; ];then
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec umount -n -l /mnt
-else
-	exec &lt; dev/console &gt;dev/console 2&gt;&amp;1
-	exec chroot . /sbin/init $@
-fi

Copied: kiwi-head/system/boot/ix86/xenboot/suse-linuxrc (from rev 1474, kiwi-head/system/boot/xenboot/suse-linuxrc)

Copied: kiwi-head/system/boot/ppc/.md5 (from rev 1473, kiwi-head/system/boot/.md5)


Property changes on: kiwi-head/system/boot/ppc/.md5
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mergeinfo
   + 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000565.html">[Kiwi-devel] r1480 - in kiwi-head/doc: . LaTex examples/suse-11.0
</A></li>
	<LI>Next message: <A HREF="000566.html">[Kiwi-devel] r1482 - kiwi-head/system/boot
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#570">[ date ]</a>
              <a href="thread.html#570">[ thread ]</a>
              <a href="subject.html#570">[ subject ]</a>
              <a href="author.html#570">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
