<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] r1804 - in kiwi-head: rpm tools/pigz
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1804%20-%20in%20kiwi-head%3A%20rpm%20tools/pigz&In-Reply-To=%3C200811281055.mASAt08a002696%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000910.html">
   <LINK REL="Next"  HREF="000912.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] r1804 - in kiwi-head: rpm tools/pigz</H1>
    <B>marcus_schaefer at mail.berlios.de</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20r1804%20-%20in%20kiwi-head%3A%20rpm%20tools/pigz&In-Reply-To=%3C200811281055.mASAt08a002696%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] r1804 - in kiwi-head: rpm tools/pigz">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Fri Nov 28 11:55:00 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000910.html">[Kiwi-devel] r1803 - kiwi-head/modules
</A></li>
        <LI>Next message: <A HREF="000912.html">[Kiwi-devel] r1805 - in kiwi-head: modules rpm	system/boot/ix86/oemboot
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#911">[ date ]</a>
              <a href="thread.html#911">[ thread ]</a>
              <a href="subject.html#911">[ subject ]</a>
              <a href="author.html#911">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: marcus_schaefer
Date: 2008-11-28 11:54:48 +0100 (Fri, 28 Nov 2008)
New Revision: 1804

Added:
   kiwi-head/tools/pigz/README
   kiwi-head/tools/pigz/yarn.c
   kiwi-head/tools/pigz/yarn.h
Modified:
   kiwi-head/rpm/kiwi.changes
   kiwi-head/tools/pigz/Makefile
   kiwi-head/tools/pigz/pigz.c
Log:

- update pigz tool, used in suse studio only



Modified: kiwi-head/rpm/kiwi.changes
===================================================================
--- kiwi-head/rpm/kiwi.changes	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/rpm/kiwi.changes	2008-11-28 10:54:48 UTC (rev 1804)
@@ -1,4 +1,9 @@
 -------------------------------------------------------------------
+Fri Nov 28 11:54:03 CET 2008 - <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>
+
+- update pigz tool, used in suse studio only
+
+-------------------------------------------------------------------
 Thu Nov 27 10:31:27 CET 2008 - <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>
 
 - changed from sector based calculation to cylinder based

Modified: kiwi-head/tools/pigz/Makefile
===================================================================
--- kiwi-head/tools/pigz/Makefile	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/tools/pigz/Makefile	2008-11-28 10:54:48 UTC (rev 1804)
@@ -1,10 +1,28 @@
-OBJ = pigz
-CC  = gcc -Wall -fpic -O2
+CFLAGS=-Wall -O2
 
-all:${OBJ}
+pigz: pigz.o yarn.o
+	cc -o pigz pigz.o yarn.o -lpthread -lz
 
-pigz: pigz.c
-	${CC} ${CFLAGS} pigz.c -o pigz -lpthread -lz
+pigz.o: pigz.c yarn.h
 
+yarn.o: yarn.c yarn.h
+
+dev: pigz pigzt pigzn
+
+pigzt: pigzt.o yarnt.o
+	cc -o pigzt pigzt.o yarnt.o -lpthread -lz
+
+pigzt.o: pigz.c yarn.h
+	cc -Wall -O3 -DDEBUG -g -c -o pigzt.o pigz.c
+
+yarnt.o: yarn.c yarn.h
+	cc -Wall -O3 -DDEBUG -g -c -o yarnt.o yarn.c
+
+pigzn: pigzn.o
+	cc -o pigzn pigzn.o -lz
+
+pigzn.o: pigz.c
+	cc -Wall -O3 -DDEBUG -DNOTHREAD -g -c -o pigzn.o pigz.c
+
 clean:
-	rm -f pigz
+	rm -f *.o pigz pigzn pigzt

Added: kiwi-head/tools/pigz/README
===================================================================
--- kiwi-head/tools/pigz/README	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/tools/pigz/README	2008-11-28 10:54:48 UTC (rev 1804)
@@ -0,0 +1,48 @@
+pigz 2.1.4 (9 Nov 2008) by Mark Adler
+
+pigz, which stands for Parallel Implementation of GZip, is a fully functional
+replacement for gzip that exploits multiple processors and multiple cores to
+the hilt when compressing data.
+
+pigz was written by Mark Adler, and uses the zlib and pthread libraries.
+
+This version of pigz is written to be portable across Unix-style operating
+systems that provide the zlib and pthread libraries.
+
+Type &quot;make&quot; in this directory to build the &quot;pigz&quot; executable.  You can then
+install the executable wherever you like in your path (e.g. /usr/local/bin/).
+Type &quot;pigz&quot; to see the command help and all of the command options.
+
+The latest version of pigz can be found at <A HREF="http://zlib.net/pigz/">http://zlib.net/pigz/</A> .  You need
+zlib version 1.2.3 or later to compile pigz.  You can find the latest version
+of zlib at <A HREF="http://zlib.net/">http://zlib.net/</A> .  You can look in pigz.c for the change history.
+
+Questions, comments, bug reports, fixes, etc. can be emailed to Mark at his
+address in the license below.
+
+The license from pigz.c is copied here:
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the author be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Mark Adler
+  <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
+
+  Mark accepts donations for providing this software.  Donations are not
+  required or expected.  Any amount that you feel is appropriate would be
+  appreciated.  You can use this link:
+
+  <A HREF="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055">https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055</A>

Modified: kiwi-head/tools/pigz/pigz.c
===================================================================
--- kiwi-head/tools/pigz/pigz.c	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/tools/pigz/pigz.c	2008-11-28 10:54:48 UTC (rev 1804)
@@ -1,6 +1,6 @@
 /* pigz.c -- parallel implementation of gzip
- * Copyright (C) 2007 Mark Adler
- * Version 1.7  29 April 2007  Mark Adler
+ * Copyright (C) 2007, 2008 Mark Adler
+ * Version 2.1.4  9 Nov 2008  Mark Adler
  */
 
 /*
@@ -22,6 +22,13 @@
 
   Mark Adler
   <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
+
+  Mark accepts donations for providing this software.  Donations are not
+  required or expected.  Any amount that you feel is appropriate would be
+  appreciated.  You can use this link:
+
+  <A HREF="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055">https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=536055</A>
+
  */
 
 /* Version history:
@@ -67,71 +74,149 @@
                        Warn about trailing junk for gzip and zlib streams
                        Make listings consistent, ignore gzip extra flags
                        Add zip stream compression (--zip)
+   1.8    13 May 2007  Document --zip option in help output
+   2.0    19 Oct 2008  Complete rewrite of thread usage and synchronization
+                       Use polling threads and a pool of memory buffers
+                       Remove direct pthread library use, hide in yarn.c
+   2.0.1  20 Oct 2008  Check version of zlib at compile time, need &gt;= 1.2.3
+   2.1    24 Oct 2008  Decompress with read, write, inflate, and check threads
+                       Remove spurious use of ctime_r(), ctime() more portable
+                       Change application of job-&gt;calc lock to be a semaphore
+                       Detect size of off_t at run time to select %lu vs. %llu
+                       #define large file support macro even if not __linux__
+                       Remove _LARGEFILE64_SOURCE, _FILE_OFFSET_BITS is enough
+                       Detect file-too-large error and report, blame build
+                       Replace check combination routines with those from zlib
+   2.1.1  28 Oct 2008  Fix a leak for files with an integer number of blocks
+                       Update for yarn 1.1 (yarn_prefix and yarn_abort)
+   2.1.2  30 Oct 2008  Work around use of beta zlib in production systems
+   2.1.3   8 Nov 2008  Don't use zlib combination routines, put back in pigz
+   2.1.4   9 Nov 2008  Fix bug when decompressing very short files
  */
 
-#define VERSION &quot;pigz 1.7\n&quot;
+#define VERSION &quot;pigz 2.1.4\n&quot;
 
 /* To-do:
-    - add --rsyncable (or -R) [use my own algorithm, set min block size]
-    - rewrite parallelism to draw on reuseable threads from a thread pool
-    - make portable for Windows, VMS, etc. (see gzip source code)
-    - write a configure and Makefile to portably compile with pthread library
+    - add --rsyncable (or -R) [use my own algorithm, set min/max block size]
+    - make source portable for Windows, VMS, etc. (see gzip source code)
+    - make build portable (currently good for Unixish)
  */
 
 /*
-   pigz compresses from stdin to stdout using threads to make use of multiple
-   processors and cores.  The input is broken up into 128 KB chunks, and each
-   is compressed separately.  The CRC for each chunk is also calculated
-   separately.  The compressed chunks are written in order to the output, and
-   the overall CRC is calculated from the CRC's of the chunks.
+   pigz compresses using threads to make use of multiple processors and cores.
+   The input is broken up into 128 KB chunks with each compressed in parallel.
+   The individual check value for each chunk is also calculated in parallel.
+   The compressed data is written in order to the output, and a combined check
+   value is calculated from the individual check values.
 
-   The compressed data format generated is in the gzip or zlib format using the
-   deflate compression method.  The input (uncompressed) data is broken up into
-   blocks, where each block is compressed independently in its own thread.  The
-   compression produces partial raw deflate streams which are concatenated by
-   a single write thread and wrapped with the gzip or zlib header and trailer.
+   The compressed data format generated is in the gzip, zlib, or single-entry
+   zip format using the deflate compression method.  The compression produces
+   partial raw deflate streams which are concatenated by a single write thread
+   and wrapped with the appropriate header and trailer, where the trailer
+   contains the combined check value.
 
    Each partial raw deflate stream is terminated by an empty stored block
    (using the Z_SYNC_FLUSH option of zlib), in order to end that partial bit
    stream at a byte boundary.  That allows the partial streams to be
-   concantenated simply as sequences of bytes.  This adds a very small four or
+   concatenated simply as sequences of bytes.  This adds a very small four to
    five byte overhead to the output for each input chunk.
 
-   The default input block size is 128K, and can be changed with the -b option.
-   The number of compress threads is limited by default to 32, where that can
-   be changed with the -p option.  Specifiying -p 1 avoids the use of threads
-   entirely.
+   The default input block size is 128K, but can be changed with the -b option.
+   The number of compress threads is set by default to 8, which can be changed
+   using the -p option.  Specifying -p 1 avoids the use of threads entirely.
 
-   The input blocks, while compressed independently, do have the last 32K of
-   the previous block loaded as a preset dictionary to preserve the compression
+   The input blocks, while compressed independently, have the last 32K of the
+   previous block loaded as a preset dictionary to preserve the compression
    effectiveness of deflating in a single thread.  This can be turned off using
-   the --independent option, so that the blocks can be decompressed
+   the --independent or -i option, so that the blocks can be decompressed
    independently for partial error recovery or for random access.
 
+   Decompression can't be parallelized, at least not without specially prepared
+   deflate streams for that purpose.  As a result, pigz uses a single thread
+   (the main thread) for decompression, but will create three other threads for
+   reading, writing, and check calculation, which can speed up decompression
+   under some circumstances.  Parallel decompression can be turned off by
+   specifying one process (-dp 1 or -tp 1).
+
    pigz requires zlib 1.2.1 or later to allow setting the dictionary when doing
-   raw deflate.  pigz will compile and run with earlier versions of zlib, but
-   this will effectively force the --independent option, somewhat degrading
-   compression.
+   raw deflate.  Since zlib 1.2.3 corrects security vulnerabilities in zlib
+   version 1.2.1 and 1.2.2, conditionals check for zlib 1.2.3 or later during
+   the compilation of pigz.c.
 
-   pigz uses the POSIX pthread library for thread control and communication.
-   It can be compiled with NOTHREAD #defined to not use threads at all (in
-   which case pigz will not be able to live up to its name).
+   pigz uses the POSIX pthread library for thread control and communication,
+   through the yarn.h interface to yarn.c.  yarn.c can be replaced with
+   equivalent implementations using other thread libraries.  pigz can be
+   compiled with NOTHREAD #defined to not use threads at all (in which case
+   pigz will not be able to live up to the &quot;parallel&quot; in its name).
+ */
 
-   Inflation cannot be parallelized, at least not without specially prepared
-   deflate streams for that purpose.  For decompression, pigz only runs one
-   other thread for the check (CRC-32 or Adler-32) calculation, for a modest
-   improvement in speed.
+/*
+   Details of parallel compression implementation:
+
+   When doing parallel compression, pigz uses the main thread to read the input
+   in 'size' sized chunks (see -b), and puts those in a compression job list,
+   each with a sequence number to keep track of the ordering.  If it is not the
+   first chunk, then that job also points to the previous input buffer, from
+   which the last 32K will be used as a dictionary (unless -i is specified).
+   This sets a lower limit of 32K on 'size'.
+
+   pigz launches up to 'procs' compression threads (see -p).  Each compression
+   thread continues to look for jobs in the compression list and perform those
+   jobs until instructed to return.  When a job is pulled, the dictionary, if
+   provided, will be loaded into the deflate engine and then that input buffer
+   is dropped for reuse.  Then the input data is compressed into an output
+   buffer sized to assure that it can contain maximally expanded deflate data.
+   The job is then put into the write job list, sorted by the sequence number.
+   The compress thread however continues to calculate the check value on the
+   input data, either a CRC-32 or Adler-32, possibly in parallel with the write
+   thread writing the output data.  Once that's done, the compress thread drops
+   the input buffer and also releases the lock on the check value so that the
+   write thread can combine it with the previous check values.  The compress
+   thread has then completed that job, and goes to look for another.
+
+   All of the compress threads are left running and waiting even after the last
+   chunk is processed, so that they can support the next input to be compressed
+   (more than one input file on the command line).  Once pigz is done, it will
+   call all the compress threads home (that'll do pig, that'll do).
+
+   Before starting to read the input, the main thread launches the write thread
+   so that it is ready pick up jobs immediately.  The compress thread puts the
+   write jobs in the list in sequence sorted order, so that the first job in
+   the list is always has the lowest sequence number.  The write thread waits
+   for the next write job in sequence, and then gets that job.  The job still
+   holds its input buffer, from which the write thread gets the input buffer
+   length for use in check value combination.  Then the write thread drops that
+   input buffer to allow its reuse.  Holding on to the input buffer until the
+   write thread starts also has the benefit that the read and compress threads
+   can't get way ahead of the write thread and build up a large backlog of
+   unwritten compressed data.  The write thread will write the compressed data,
+   drop the output buffer, and then wait for the check value to be unlocked
+   by the compress thread.  Then the write thread combines the check value for
+   this chunk with the total check value for eventual use in the trailer.  If
+   this is not the last chunk, the write thread then goes back to look for the
+   next output chunk in sequence.  After the last chunk, the write thread
+   returns and joins the main thread.  Unlike the compress threads, a new write
+   thread is launched for each input stream.  The write thread writes the
+   appropriate header and trailer around the compressed data.
+
+   The input and output buffers are reused through their collection in pools.
+   Each buffer has a use count, which when decremented to zero returns the
+   buffer to the respective pool.  Each input buffer has up to three parallel
+   uses: as the input for compression, as the data for the check value
+   calculation, and as a dictionary for compression.  Each output buffer has
+   only one use, which is as the output of compression followed serially as
+   data to be written.  The input pool is limited in the number of buffers, so
+   that reading does not get way ahead of compression and eat up memory with
+   more input than can be used.  The limit is approximately two times the
+   number of compression threads.  In the case that reading is fast as compared
+   to compression, that number allows a second set of buffers to be read while
+   the first set of compressions are being performed.  The number of output
+   buffers is not directly limited, but is indirectly limited by the release of
+   input buffers to the same number.
  */
 
-/* add a dash of portability */
-#ifdef __linux__
-#  define _LARGEFILE64_SOURCE
-#  define _FILE_OFFSET_BITS 64
-#endif
-#ifndef NOTHREAD
-#  define _POSIX_PTHREAD_SEMANTICS
-#  define _REENTRANT
-#endif
+/* use large file functions if available */
+#define _FILE_OFFSET_BITS 64
 
 /* included headers and what is expected from each */
 #include &lt;stdio.h&gt;      /* fflush(), fprintf(), fputs(), getchar(), putc(), */
@@ -143,20 +228,9 @@
 #include &lt;string.h&gt;     /* memset(), memchr(), memcpy(), strcmp(), */
                         /* strcpy(), strncpy(), strlen(), strcat() */
 #include &lt;errno.h&gt;      /* errno, EEXIST */
-#include &lt;time.h&gt;       /* ctime(), ctime_r(), time(), time_t, mktime() */
+#include &lt;assert.h&gt;     /* assert() */
+#include &lt;time.h&gt;       /* ctime(), time(), time_t, mktime() */
 #include &lt;signal.h&gt;     /* signal(), SIGINT */
-#ifndef NOTHREAD
-#include &lt;pthread.h&gt;    /* pthread_attr_destroy(), pthread_attr_init(), */
-                        /* pthread_attr_setdetachstate(),
-                           pthread_attr_setstacksize(), pthread_attr_t,
-                           pthread_cond_destroy(), pthread_cond_init(),
-                           pthread_cond_signal(), pthread_cond_wait(),
-                           pthread_create(), pthread_join(),
-                           pthread_mutex_destroy(), pthread_mutex_init(),
-                           pthread_mutex_lock(), pthread_mutex_t,
-                           pthread_mutex_unlock(), pthread_t,
-                           PTHREAD_CREATE_JOINABLE */
-#endif
 #include &lt;sys/types.h&gt;  /* ssize_t */
 #include &lt;sys/stat.h&gt;   /* chmod(), stat(), fstat(), lstat(), struct stat, */
                         /* S_IFDIR, S_IFLNK, S_IFMT, S_IFREG */
@@ -168,12 +242,22 @@
 #include &lt;dirent.h&gt;     /* opendir(), readdir(), closedir(), DIR, */
                         /* struct dirent */
 #include &lt;limits.h&gt;     /* PATH_MAX */
+
 #include &quot;zlib.h&quot;       /* deflateInit2(), deflateReset(), deflate(), */
                         /* deflateEnd(), deflateSetDictionary(), crc32(),
                            Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY,
                            Z_DEFLATED, Z_NO_FLUSH, Z_NULL, Z_OK,
                            Z_SYNC_FLUSH, z_stream */
+#if !defined(ZLIB_VERNUM) || ZLIB_VERNUM &lt; 0x1230
+#  error Need zlib version 1.2.3 or later
+#endif
 
+#ifndef NOTHREAD
+#  include &quot;yarn.h&quot;     /* thread, launch(), join(), join_all(), */
+                        /* lock, new_lock(), possess(), twist(), wait_for(),
+                           release(), peek_lock(), free_lock(), yarn_name */
+#endif
+
 /* for local functions and globals */
 #define local static
 
@@ -194,110 +278,6 @@
         } \
     } while (0)
 
-#ifndef NOTHREAD
-
-/* combine two crc-32's or two adler-32's (copied from zlib 1.2.3) */
-
-local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec &amp; 1)
-            sum ^= *mat;
-        vec &gt;&gt;= 1;
-        mat++;
-    }
-    return sum;
-}
-
-local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
-{
-    int n;
-
-    for (n = 0; n &lt; 32; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-local unsigned long crc32_comb(unsigned long crc1, unsigned long crc2,
-                               size_t len2)
-{
-    int n;
-    unsigned long row;
-    unsigned long even[32];     /* even-power-of-two zeros operator */
-    unsigned long odd[32];      /* odd-power-of-two zeros operator */
-
-    /* degenerate case */
-    if (len2 == 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n &lt; 32; n++) {
-        odd[n] = row;
-        row &lt;&lt;= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 &amp; 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 &gt;&gt;= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 &amp; 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 &gt;&gt;= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
-
-#define BASE 65521U     /* largest prime smaller than 65536 */
-#define LOW16 0xffff    /* mask lower 16 bits */
-
-local unsigned long adler32_comb(unsigned long adler1, unsigned long adler2,
-                                 size_t len2)
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    rem = (unsigned)(len2 % BASE);
-    sum1 = adler1 &amp; LOW16;
-    sum2 = (rem * sum1) % BASE;
-    sum1 += (adler2 &amp; LOW16) + BASE - 1;
-    sum2 += ((adler1 &gt;&gt; 16) &amp; LOW16) + ((adler2 &gt;&gt; 16) &amp; LOW16) + BASE - rem;
-    if (sum1 &gt; BASE) sum1 -= BASE;
-    if (sum1 &gt; BASE) sum1 -= BASE;
-    if (sum2 &gt; (BASE &lt;&lt; 1)) sum2 -= (BASE &lt;&lt; 1);
-    if (sum2 &gt; BASE) sum2 -= BASE;
-    return sum1 | (sum2 &lt;&lt; 16);
-}
-
-#endif
-
 /* globals (modified by main thread only when it's the only thread) */
 local int ind;              /* input file descriptor */
 local int outd;             /* output file descriptor */
@@ -318,13 +298,9 @@
 local int decode;           /* 0 to compress, 1 to decompress, 2 to test */
 local int level;            /* compression level */
 local int rsync;            /* true for rsync blocking */
-local int procs;            /* number of compression threads (&gt;= 2) */
+local int procs;            /* maximum number of compression threads (&gt;= 1) */
 local int dict;             /* true to initialize dictionary in each thread */
 local size_t size;          /* uncompressed input size per thread (&gt;= 32K) */
-local struct timeval start; /* starting time of day for tracing */
-#ifndef NOTHREAD
-local pthread_attr_t attr;  /* thread creation attributes */
-#endif
 
 /* saved gzip/zip header data for decompression, testing, and listing */
 local time_t stamp;                 /* time stamp from gzip header */
@@ -333,14 +309,10 @@
 local unsigned long zip_clen;       /* local header compressed length */
 local unsigned long zip_ulen;       /* local header uncompressed length */
 
-/* compute check value depeding on format */
-#define CHECK(a,b,c) (form == 1 ? adler32(a,b,c) : crc32(a,b,c))
-#define COMB(a,b,c) (form == 1 ? adler32_comb(a,b,c) : crc32_comb(a,b,c))
-
-/* exit with error, delete output file */
+/* exit with error, delete output file if in the middle of writing it */
 local int bail(char *why, char *what)
 {
-    if (out != NULL)
+    if (outd != -1 &amp;&amp; out != NULL)
         unlink(out);
     if (verbosity &gt; 0)
         fprintf(stderr, &quot;pigz abort: %s%s\n&quot;, why, what);
@@ -350,20 +322,34 @@
 
 #ifdef DEBUG
 
+/* starting time of day for tracing */
+local struct timeval start;
+
 /* trace log */
-struct log {
+local struct log {
     struct timeval when;    /* time of entry */
     char *msg;              /* message */
     struct log *next;       /* next entry */
-} *log_head = NULL, **log_tail = &amp;log_head;
-
+} *log_head, **log_tail = NULL;
 #ifndef NOTHREAD
-local pthread_mutex_t logex = PTHREAD_MUTEX_INITIALIZER;
+  local lock *log_lock = NULL;
 #endif
 
 /* maximum log entry length */
 #define MAXMSG 256
 
+/* set up log (call from main thread before other threads launched) */
+local void log_init(void)
+{
+    if (log_tail == NULL) {
+#ifndef NOTHREAD
+        log_lock = new_lock(0);
+#endif
+        log_head = NULL;
+        log_tail = &amp;log_head;
+    }
+}
+
 /* add entry to trace log */
 local void log_add(char *fmt, ...)
 {
@@ -388,13 +374,13 @@
     strcpy(me-&gt;msg, msg);
     me-&gt;next = NULL;
 #ifndef NOTHREAD
-    if (pthread_mutex_lock(&amp;logex))
-        bail(&quot;mutex_lock error in &quot;, &quot;log_add&quot;);
+    assert(log_lock != NULL);
+    possess(log_lock);
 #endif
     *log_tail = me;
     log_tail = &amp;(me-&gt;next);
 #ifndef NOTHREAD
-    pthread_mutex_unlock(&amp;logex);
+    twist(log_lock, BY, +1);
 #endif
 }
 
@@ -404,21 +390,24 @@
     struct log *me;
     struct timeval diff;
 
+    if (log_tail == NULL)
+        return 0;
 #ifndef NOTHREAD
-    if (pthread_mutex_lock(&amp;logex))
-        bail(&quot;mutex_lock error in &quot;, &quot;log_show&quot;);
+    possess(log_lock);
 #endif
     me = log_head;
-    if (me != NULL) {
-        log_head = me-&gt;next;
-        if (me-&gt;next == NULL)
-            log_tail = &amp;log_head;
+    if (me == NULL) {
+#ifndef NOTHREAD
+        release(log_lock);
+#endif
+        return 0;
     }
+    log_head = me-&gt;next;
+    if (me-&gt;next == NULL)
+        log_tail = &amp;log_head;
 #ifndef NOTHREAD
-    pthread_mutex_unlock(&amp;logex);
+    twist(log_lock, BY, -1);
 #endif
-    if (me == NULL)
-        return 0;
     diff.tv_usec = me-&gt;when.tv_usec - start.tv_usec;
     diff.tv_sec = me-&gt;when.tv_sec - start.tv_sec;
     if (diff.tv_usec &lt; 0) {
@@ -433,11 +422,37 @@
     return 1;
 }
 
-/* show entries until no more */
+/* release log resources (need to do log_init() to use again) */
+local void log_free(void)
+{
+    struct log *me;
+
+    if (log_tail != NULL) {
+#ifndef NOTHREAD
+        possess(log_lock);
+#endif
+        while ((me = log_head) != NULL) {
+            log_head = me-&gt;next;
+            free(me-&gt;msg);
+            free(me);
+        }
+#ifndef NOTHREAD
+        twist(log_lock, TO, 0);
+        free_lock(log_lock);
+        log_lock = NULL;
+#endif
+        log_tail = NULL;
+    }
+}
+
+/* show entries until no more, free log */
 local void log_dump(void)
 {
+    if (log_tail == NULL)
+        return;
     while (log_show())
         ;
+    log_free();
 }
 
 /* debugging macro */
@@ -455,17 +470,6 @@
 
 #endif
 
-/* catch termination signal */
-local void cutshort(int sig)
-{
-    Trace((&quot;termination by user&quot;));
-    if (out != NULL)
-        unlink(out);
-    log_dump();
-    log_dump();
-    _exit(1);
-}
-
 /* read up to len bytes into buf, repeating read() calls as needed */
 local size_t readn(int desc, unsigned char *buf, size_t len)
 {
@@ -494,170 +498,20 @@
     while (len) {
         ret = write(desc, buf, len);
         if (ret &lt; 1)
+            fprintf(stderr, &quot;write error code %d\n&quot;, errno);
+        if (ret &lt; 1)
             bail(&quot;write error on &quot;, out);
         buf += ret;
         len -= ret;
     }
 }
 
-#ifndef NOTHREAD
-
-/* a flag variable for communication between two threads */
-struct flag {
-    int value;              /* value of flag */
-    pthread_mutex_t lock;   /* lock for checking and changing flag */
-    pthread_cond_t cond;    /* condition for signaling on flag change */
-};
-
-/* initialize a flag for use, starting with value val */
-local void flag_init(struct flag *me, int val)
-{
-    me-&gt;value = val;
-    pthread_mutex_init(&amp;(me-&gt;lock), NULL);
-    pthread_cond_init(&amp;(me-&gt;cond), NULL);
-}
-
-/* set the flag to val, signal another process that may be waiting for it */
-local void flag_set(struct flag *me, int val)
-{
-    int ret;
-
-    ret = pthread_mutex_lock(&amp;(me-&gt;lock));
-    if (ret)
-        bail(&quot;mutex_lock error in &quot;, &quot;flag_set&quot;);
-    me-&gt;value = val;
-    pthread_cond_signal(&amp;(me-&gt;cond));
-    pthread_mutex_unlock(&amp;(me-&gt;lock));
-}
-
-/* if it isn't already, wait for some other thread to set the flag to val */
-local void flag_wait(struct flag *me, int val)
-{
-    int ret;
-
-    ret = pthread_mutex_lock(&amp;(me-&gt;lock));
-    if (ret)
-        bail(&quot;mutex_lock error in &quot;, &quot;flag_wait&quot;);
-    while (me-&gt;value != val)
-        pthread_cond_wait(&amp;(me-&gt;cond), &amp;(me-&gt;lock));
-    pthread_mutex_unlock(&amp;(me-&gt;lock));
-}
-
-/* if flag is equal to val, wait for some other thread to change it */
-local void flag_wait_not(struct flag *me, int val)
-{
-    int ret;
-
-    ret = pthread_mutex_lock(&amp;(me-&gt;lock));
-    if (ret)
-        bail(&quot;mutex_lock error in &quot;, &quot;flag_wait_not&quot;);
-    while (me-&gt;value == val)
-        pthread_cond_wait(&amp;(me-&gt;cond), &amp;(me-&gt;lock));
-    pthread_mutex_unlock(&amp;(me-&gt;lock));
-}
-
-/* clean up the flag when done with it */
-local void flag_done(struct flag *me)
-{
-    pthread_cond_destroy(&amp;(me-&gt;cond));
-    pthread_mutex_destroy(&amp;(me-&gt;lock));
-}
-
-/* busy flag values */
-#define IDLE 0          /* compress and writing done -- can start compress */
-#define COMP 1          /* compress -- input and output buffers in use */
-#define WRITE 2         /* compress done, writing output -- can read input */
-
-/* next and previous jobs[] indices */
-#define NEXT(n) ((n) == procs - 1 ? 0 : (n) + 1)
-#define PREV(n) ((n) == 0 ? procs - 1 : (n) - 1)
-
-#endif
-
-/* work units to feed to compress_thread() -- it is assumed that the out
-   buffer is large enough to hold the maximum size len bytes could deflate to,
-   plus five bytes for the final sync marker */
-local struct work {
-    size_t len;                 /* length of input */
-    unsigned long check;        /* check value of input */
-    unsigned char *buf;         /* input */
-    unsigned char *out;         /* space for output (guaranteed big enough) */
-    z_stream strm;              /* pre-initialized z_stream */
-#ifndef NOTHREAD
-    struct flag busy;           /* busy flag indicating work unit in use */
-    pthread_t comp;             /* this compression thread */
-#endif
-} *jobs = NULL;
-
-/* set up the jobs[] work units -- full initialization of each unit is
-   deferred until the unit is actually needed, also make sure that
-   size arithmetic does not overflow for here or for job_init() */
-local void jobs_new(void)
-{
-    int n;
-
-    if (jobs != NULL)
-        return;
-    if (size + (size &gt;&gt; 11) + 10 &lt; (size &gt;&gt; 11) + 10 ||
-        (ssize_t)(size + (size &gt;&gt; 11) + 10) &lt; 0 ||
-        ((size_t)0 - 1) / procs &lt;= sizeof(struct work) ||
-        (jobs = malloc(procs * sizeof(struct work))) == NULL)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-    for (n = 0; n &lt; procs; n++) {
-        jobs[n].buf = NULL;
-#ifndef NOTHREAD
-        flag_init(&amp;(jobs[n].busy), IDLE);
-#endif
-    }
-}
-
-/* one-time initialization of a work unit -- this is where we set the deflate
-   compression level and request raw deflate, and also where we set the size
-   of the output buffer to guarantee enough space for a worst-case deflate
-   ending with a Z_SYNC_FLUSH */
-local void job_init(struct work *job)
-{
-    int ret;                        /* deflateInit2() return value */
-
-    Trace((&quot;-- initializing %d&quot;, job - jobs));
-    job-&gt;buf = malloc(size);
-    job-&gt;out = malloc(size + (size &gt;&gt; 11) + 10);
-    job-&gt;strm.zfree = Z_NULL;
-    job-&gt;strm.zalloc = Z_NULL;
-    job-&gt;strm.opaque = Z_NULL;
-    ret = deflateInit2(&amp;(job-&gt;strm), level, Z_DEFLATED, -15, 8,
-                       Z_DEFAULT_STRATEGY);
-    if (job-&gt;buf == NULL || job-&gt;out == NULL || ret != Z_OK)
-        bail(&quot;not enough memory&quot;, &quot;&quot;);
-}
-
-/* release resources used by the job[] work units */
-local void jobs_free(void)
-{
-    int n;
-
-    if (jobs == NULL)
-        return;
-    for (n = procs - 1; n &gt;= 0; n--) {
-        if (jobs[n].buf != NULL) {
-            (void)deflateEnd(&amp;(jobs[n].strm));
-            free(jobs[n].out);
-            free(jobs[n].buf);
-        }
-#ifndef NOTHREAD
-        flag_done(&amp;(jobs[n].busy));
-#endif
-    }
-    free(jobs);
-    jobs = NULL;
-}
-
 /* sliding dictionary size for deflate */
 #define DICT 32768U
 
 /* largest power of 2 that fits in an unsigned int -- used to limit requests
    to zlib functions that use unsigned int lengths */
-#define MAX ((((unsigned)-1) &gt;&gt; 1) + 1)
+#define MAX ((((unsigned)0 - 1) &gt;&gt; 1) + 1)
 
 /* convert Unix time to MS-DOS date and time, assuming current timezone
    (you got a better idea?) */
@@ -820,227 +674,699 @@
     }
 }
 
+/* compute check value depending on format */
+#define CHECK(a,b,c) (form == 1 ? adler32(a,b,c) : crc32(a,b,c))
+
 #ifndef NOTHREAD
+/* -- threaded portions of pigz -- */
 
-/* compress thread: compress the input in the provided work unit and compute
-   check -- assume that the amount of space at job-&gt;out is guaranteed to be
-   enough for the compressed output, as determined by the maximum expansion
-   of deflate compression -- use the input in the previous work unit (if there
-   is one) to set the deflate dictionary for better compression */
-local void *compress_thread(void *arg)
+/* -- check value combination routines for parallel calculation -- */
+
+#define COMB(a,b,c) (form == 1 ? adler32_comb(a,b,c) : crc32_comb(a,b,c))
+/* combine two crc-32's or two adler-32's (copied from zlib 1.2.3 so that pigz
+   can be compatible with older versions of zlib) */
+
+/* we copy the combination routines from zlib here, in order to avoid
+   linkage issues with the zlib builds on Sun, Ubuntu, and others */
+
+local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
 {
-    size_t len;                     /* input length for this work unit */
-    unsigned long check;            /* check of input data */
-    struct work *prev;              /* previous work unit */
-    struct work *job = arg;         /* work unit for this thread */
-    z_stream *strm = &amp;(job-&gt;strm);  /* zlib stream for this work unit */
+    unsigned long sum;
 
-    /* reset state for a new compressed stream */
-    Trace((&quot;-- compressing %d&quot;, job - jobs));
-    (void)deflateReset(strm);
+    sum = 0;
+    while (vec) {
+        if (vec &amp; 1)
+            sum ^= *mat;
+        vec &gt;&gt;= 1;
+        mat++;
+    }
+    return sum;
+}
 
-    /* initialize input, output, and check */
-    strm-&gt;next_in = job-&gt;buf;
-    strm-&gt;next_out = job-&gt;out;
-    len = job-&gt;len;
-    check = CHECK(0L, Z_NULL, 0);
+local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
+{
+    int n;
 
-    /* set dictionary if this isn't the first work unit, and if we will be
-       compressing something (the read thread assures that the dictionary
-       data in the previous work unit is still there) */
-    prev = jobs + PREV(job - jobs);
-    if (dict &amp;&amp; prev-&gt;buf != NULL &amp;&amp; len != 0)
-        deflateSetDictionary(strm, prev-&gt;buf + (size - DICT), DICT);
+    for (n = 0; n &lt; 32; n++)
+        square[n] = gf2_matrix_times(mat, mat[n]);
+}
 
-    /* run MAX-sized amounts of input through deflate and check -- this loop
-       is needed for those cases where the integer type is smaller than the
-       size_t type, or when len is close to the limit of the size_t type */
-    while (len &gt; MAX) {
-        strm-&gt;avail_in = MAX;
-        strm-&gt;avail_out = (unsigned)-1;
-        check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
-        (void)deflate(strm, Z_NO_FLUSH);
-        len -= MAX;
+local unsigned long crc32_comb(unsigned long crc1, unsigned long crc2,
+                               size_t len2)
+{
+    int n;
+    unsigned long row;
+    unsigned long even[32];     /* even-power-of-two zeros operator */
+    unsigned long odd[32];      /* odd-power-of-two zeros operator */
+
+    /* degenerate case */
+    if (len2 == 0)
+        return crc1;
+
+    /* put operator for one zero bit in odd */
+    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
+    row = 1;
+    for (n = 1; n &lt; 32; n++) {
+        odd[n] = row;
+        row &lt;&lt;= 1;
     }
 
-    /* run last piece through deflate and check -- terminate with sync marker,
-       or finish deflate stream if this is the last block */
-    strm-&gt;avail_in = len;
-    strm-&gt;avail_out = (unsigned)-1;
-    check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
-    (void)deflate(strm, job-&gt;len &lt; size ? Z_FINISH : Z_SYNC_FLUSH);
+    /* put operator for two zero bits in even */
+    gf2_matrix_square(even, odd);
 
-    /* return result */
-    job-&gt;check = check;
-    Trace((&quot;-- compressed %d&quot;, job - jobs));
-    return NULL;
+    /* put operator for four zero bits in odd */
+    gf2_matrix_square(odd, even);
+
+    /* apply len2 zeros to crc1 (first square will put the operator for one
+       zero byte, eight zero bits, in even) */
+    do {
+        /* apply zeros operator for this bit of len2 */
+        gf2_matrix_square(even, odd);
+        if (len2 &amp; 1)
+            crc1 = gf2_matrix_times(even, crc1);
+        len2 &gt;&gt;= 1;
+
+        /* if no more bits set, then done */
+        if (len2 == 0)
+            break;
+
+        /* another iteration of the loop with odd and even swapped */
+        gf2_matrix_square(odd, even);
+        if (len2 &amp; 1)
+            crc1 = gf2_matrix_times(odd, crc1);
+        len2 &gt;&gt;= 1;
+
+        /* if no more bits set, then done */
+    } while (len2 != 0);
+
+    /* return combined crc */
+    crc1 ^= crc2;
+    return crc1;
 }
 
-/* write thread: wait for compression threads to complete, write output in
-   order, also write gzip header and trailer around the compressed data */
-local void *write_thread(void *arg)
+#define BASE 65521U     /* largest prime smaller than 65536 */
+#define LOW16 0xffff    /* mask lower 16 bits */
+
+local unsigned long adler32_comb(unsigned long adler1, unsigned long adler2,
+                                 size_t len2)
 {
-    int n;                          /* compress thread index */
-    size_t len;                     /* length of input processed */
+    unsigned long sum1;
+    unsigned long sum2;
+    unsigned rem;
+
+    /* the derivation of this formula is left as an exercise for the reader */
+    rem = (unsigned)(len2 % BASE);
+    sum1 = adler1 &amp; LOW16;
+    sum2 = (rem * sum1) % BASE;
+    sum1 += (adler2 &amp; LOW16) + BASE - 1;
+    sum2 += ((adler1 &gt;&gt; 16) &amp; LOW16) + ((adler2 &gt;&gt; 16) &amp; LOW16) + BASE - rem;
+    if (sum1 &gt;= BASE) sum1 -= BASE;
+    if (sum1 &gt;= BASE) sum1 -= BASE;
+    if (sum2 &gt;= (BASE &lt;&lt; 1)) sum2 -= (BASE &lt;&lt; 1);
+    if (sum2 &gt;= BASE) sum2 -= BASE;
+    return sum1 | (sum2 &lt;&lt; 16);
+}
+
+/* -- pool of spaces for buffer management -- */
+
+/* These routines manage a pool of spaces.  Each pool specifies a fixed size
+   buffer to be contained in each space.  Each space has a use count, which
+   when decremented to zero returns the space to the pool.  If a space is
+   requested from the pool and the pool is empty, a space is immediately
+   created unless a specified limit on the number of spaces has been reached.
+   Only if the limit is reached will it wait for a space to be returned to the
+   pool.  Each space knows what pool it belongs to, so that it can be returned.
+ */
+
+/* a space (one buffer for each space) */
+struct space {
+    lock *use;              /* use count -- return to pool when zero */
+    void *buf;              /* buffer of size pool-&gt;size */
+    size_t len;             /* for application usage */
+    struct pool *pool;      /* pool to return to */
+    struct space *next;     /* for pool linked list */
+};
+
+/* pool of spaces (one pool for each size needed) */
+struct pool {
+    lock *have;             /* unused spaces available, lock for list */
+    struct space *head;     /* linked list of available buffers */
+    size_t size;            /* size of all buffers in this pool */
+    int limit;              /* number of new spaces allowed, or -1 */
+    int made;               /* number of buffers made */
+};
+
+/* initialize a pool (pool structure itself provided, not allocated) -- the
+   limit is the maximum number of spaces in the pool, or -1 to indicate no
+   limit, i.e., to never wait for a buffer to return to the pool */
+local void new_pool(struct pool *pool, size_t size, int limit)
+{
+    pool-&gt;have = new_lock(0);
+    pool-&gt;head = NULL;
+    pool-&gt;size = size;
+    pool-&gt;limit = limit;
+    pool-&gt;made = 0;
+}
+
+/* get a space from a pool -- the use count is initially set to one, so there
+   is no need to call use_space() for the first use */
+local struct space *get_space(struct pool *pool)
+{
+    struct space *space;
+
+    /* if can't create any more, wait for a space to show up */
+    possess(pool-&gt;have);
+    if (pool-&gt;limit == 0)
+        wait_for(pool-&gt;have, NOT_TO_BE, 0);
+
+    /* if a space is available, pull it from the list and return it */
+    if (pool-&gt;head != NULL) {
+        space = pool-&gt;head;
+        possess(space-&gt;use);
+        pool-&gt;head = space-&gt;next;
+        twist(pool-&gt;have, BY, -1);      /* one less in pool */
+        twist(space-&gt;use, TO, 1);       /* initially one user */
+        return space;
+    }
+
+    /* nothing available, don't want to wait, make a new space */
+    assert(pool-&gt;limit != 0);
+    if (pool-&gt;limit &gt; 0)
+        pool-&gt;limit--;
+    pool-&gt;made++;
+    release(pool-&gt;have);
+    space = malloc(sizeof(struct space));
+    if (space == NULL)
+        bail(&quot;not enough memory&quot;, &quot;&quot;);
+    space-&gt;use = new_lock(1);           /* initially one user */
+    space-&gt;buf = malloc(pool-&gt;size);
+    if (space-&gt;buf == NULL)
+        bail(&quot;not enough memory&quot;, &quot;&quot;);
+    space-&gt;pool = pool;                 /* remember the pool this belongs to */
+    return space;
+}
+
+/* increment the use count to require one more drop before returning this space
+   to the pool */
+local void use_space(struct space *space)
+{
+    possess(space-&gt;use);
+    twist(space-&gt;use, BY, +1);
+}
+
+/* drop a space, returning it to the pool if the use count is zero */
+local void drop_space(struct space *space)
+{
+    int use;
+    struct pool *pool;
+
+    possess(space-&gt;use);
+    use = peek_lock(space-&gt;use);
+    assert(use != 0);
+    if (use == 1) {
+        pool = space-&gt;pool;
+        possess(pool-&gt;have);
+        space-&gt;next = pool-&gt;head;
+        pool-&gt;head = space;
+        twist(pool-&gt;have, BY, +1);
+    }
+    twist(space-&gt;use, BY, -1);
+}
+
+/* free the memory and lock resources of a pool -- return number of spaces for
+   debugging and resource usage measurement */
+local int free_pool(struct pool *pool)
+{
+    int count;
+    struct space *space;
+
+    possess(pool-&gt;have);
+    count = 0;
+    while ((space = pool-&gt;head) != NULL) {
+        pool-&gt;head = space-&gt;next;
+        free(space-&gt;buf);
+        free_lock(space-&gt;use);
+        free(space);
+        count++;
+    }
+    release(pool-&gt;have);
+    free_lock(pool-&gt;have);
+    assert(count == pool-&gt;made);
+    return count;
+}
+
+/* input and output buffer pools */
+local struct pool in_pool;
+local struct pool out_pool;
+
+/* -- parallel compression -- */
+
+/* compress or write job (passed from compress list to write list) -- if seq is
+   equal to -1, compress_thread is instructed to return; if more is false then
+   this is the last chunk, which after writing tells write_thread to return */
+struct job {
+    long seq;                   /* sequence number */
+    int more;                   /* true if this is not the last chunk */
+    struct space *in;           /* input data to compress */
+    struct space *out;          /* dictionary or resulting compressed data */
+    unsigned long check;        /* check value for input data */
+    lock *calc;                 /* released when check calculation complete */
+    struct job *next;           /* next job in the list (either list) */
+};
+
+/* list of compress jobs (with tail for appending to list) */
+local lock *compress_have = NULL;   /* number of compress jobs waiting */
+local struct job *compress_head, **compress_tail;
+
+/* list of write jobs */
+local lock *write_first;            /* lowest sequence number in list */
+local struct job *write_head;
+
+/* number of compression threads running */
+local int cthreads = 0;
+
+/* write thread if running */
+local thread *writeth = NULL;
+
+/* setup job lists (call from main thread) */
+local void setup_jobs(void)
+{
+    /* set up only if not already set up*/
+    if (compress_have != NULL)
+        return;
+
+    /* allocate locks and initialize lists */
+    compress_have = new_lock(0);
+    compress_head = NULL;
+    compress_tail = &amp;compress_head;
+    write_first = new_lock(-1);
+    write_head = NULL;
+
+    /* initialize buffer pools */
+    new_pool(&amp;in_pool, size, (procs &lt;&lt; 1) + 2);
+    new_pool(&amp;out_pool, size + (size &gt;&gt; 11) + 10, -1);
+}
+
+/* command the compress threads to all return, then join them all (call from
+   main thread), free all the thread-related resources */
+local void finish_jobs(void)
+{
+    struct job job;
+    int caught;
+
+    /* only do this once */
+    if (compress_have == NULL)
+        return;
+
+    /* command all of the extant compress threads to return */
+    possess(compress_have);
+    job.seq = -1;
+    job.next = NULL;
+    compress_head = &job;
+    compress_tail = &amp;(job.next);
+    twist(compress_have, BY, +1);       /* will wake them all up */
+
+    /* join all of the compress threads, verify they all came back */
+    caught = join_all();
+    Trace((&quot;-- joined %d compress threads&quot;, caught));
+    assert(caught == cthreads);
+    cthreads = 0;
+
+    /* free the resources */
+    caught = free_pool(&amp;out_pool);
+    Trace((&quot;-- freed %d output buffers&quot;, caught));
+    caught = free_pool(&amp;in_pool);
+    Trace((&quot;-- freed %d input buffers&quot;, caught));
+    free_lock(write_first);
+    free_lock(compress_have);
+    compress_have = NULL;
+}
+
+/* get the next compression job from the head of the list, compress and compute
+   the check value on the input, and put a job in the write list with the
+   results -- keep looking for more jobs, returning when a job is found with a
+   sequence number of -1 (leave that job in the list for other incarnations to
+   find) */
+local void compress_thread(void *dummy)
+{
+    struct job *job;                /* job pulled and working on */ 
+    struct job *here, **prior;      /* pointers for inserting in write list */ 
+    unsigned long check;            /* check value of input */
+    unsigned char *next;            /* pointer for check value data */
+    size_t len;                     /* remaining bytes to compress/check */
+    z_stream strm;                  /* deflate stream */
+
+    /* initialize the deflate stream for this thread */
+    strm.zfree = Z_NULL;
+    strm.zalloc = Z_NULL;
+    strm.opaque = Z_NULL;
+    if (deflateInit2(&amp;strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) !=
+            Z_OK)
+        bail(&quot;not enough memory&quot;, &quot;&quot;);
+
+    /* keep looking for work */
+    for (;;) {
+        /* get a job (like I tell my son) */
+        possess(compress_have);
+        wait_for(compress_have, NOT_TO_BE, 0);
+        job = compress_head;
+        assert(job != NULL);
+        if (job-&gt;seq == -1)
+            break;
+        compress_head = job-&gt;next;
+        if (job-&gt;next == NULL)
+            compress_tail = &amp;compress_head;
+        twist(compress_have, BY, -1);
+
+        /* got a job -- initialize and set the compression level (note that if
+           deflateParams() is called immediately after deflateReset(), there is
+           no need to initialize the input/output for the stream) */
+        Trace((&quot;-- compressing #%ld&quot;, job-&gt;seq));
+        (void)deflateReset(&amp;strm);
+        (void)deflateParams(&amp;strm, level, Z_DEFAULT_STRATEGY);
+
+        /* set dictionary if provided, release that input buffer (only provided
+           if dict is true and if this is not the first work unit) -- the
+           amount of data in the buffer is assured to be &gt;= DICT */
+        if (job-&gt;out != NULL) {
+            len = job-&gt;out-&gt;len;
+            deflateSetDictionary(&amp;strm,
+                (unsigned char *)(job-&gt;out-&gt;buf) + (len - DICT), DICT);
+            drop_space(job-&gt;out);
+        }
+
+        /* set up input and output (the output size is assured to be big enough
+           for the worst case expansion of the input buffer size, plus five
+           bytes for the terminating stored block) */
+        job-&gt;out = get_space(&amp;out_pool);
+        strm.next_in = job-&gt;in-&gt;buf;
+        strm.next_out = job-&gt;out-&gt;buf;
+
+        /* run MAX-sized amounts of input through deflate -- this loop is
+           needed for those cases where the integer type is smaller than the
+           size_t type, or when len is close to the limit of the size_t type */
+        len = job-&gt;in-&gt;len;
+        while (len &gt; MAX) {
+            strm.avail_in = MAX;
+            strm.avail_out = (unsigned)-1;
+            (void)deflate(&amp;strm, Z_NO_FLUSH);
+            assert(strm.avail_in == 0 &amp;&amp; strm.avail_out != 0);
+            len -= MAX;
+        }
+
+        /* run the last piece through deflate -- terminate with a sync marker,
+           or finish deflate stream if this is the last block */
+        strm.avail_in = (unsigned)len;
+        strm.avail_out = (unsigned)-1;
+        (void)deflate(&amp;strm, job-&gt;more ? Z_SYNC_FLUSH :  Z_FINISH);
+        assert(strm.avail_in == 0 &amp;&amp; strm.avail_out != 0);
+        job-&gt;out-&gt;len = strm.next_out - (unsigned char *)(job-&gt;out-&gt;buf);
+        Trace((&quot;-- compressed #%ld%s&quot;, job-&gt;seq, job-&gt;more ? &quot;&quot; : &quot; (last)&quot;));
+
+        /* reserve input buffer until check value has been calculated */
+        use_space(job-&gt;in);
+
+        /* insert write job in list in sorted order, alert write thread */
+        possess(write_first);
+        prior = &amp;write_head;
+        while ((here = *prior) != NULL) {
+            if (here-&gt;seq &gt; job-&gt;seq)
+                break;
+            prior = &amp;(here-&gt;next);
+        }
+        job-&gt;next = here;
+        *prior = job;
+        twist(write_first, TO, write_head-&gt;seq);
+
+        /* calculate the check value in parallel with writing, alert the write
+           thread that the calculation is complete, and drop this usage of the
+           input buffer */
+        len = job-&gt;in-&gt;len;
+        next = job-&gt;in-&gt;buf;
+        check = CHECK(0L, Z_NULL, 0);
+        while (len &gt; MAX) {
+            check = CHECK(check, next, MAX);
+            len -= MAX;
+            next += MAX;
+        }
+        check = CHECK(check, next, (unsigned)len);
+        drop_space(job-&gt;in);
+        job-&gt;check = check;
+        possess(job-&gt;calc);
+        twist(job-&gt;calc, TO, 1);
+        Trace((&quot;-- checked #%ld%s&quot;, job-&gt;seq, job-&gt;more ? &quot;&quot; : &quot; (last)&quot;));
+
+        /* done with that one -- go find another job */
+    }
+
+    /* found job with seq == -1 -- free deflate memory and return to join */
+    release(compress_have);
+    deflateEnd(&amp;strm);
+}
+
+/* collect the write jobs off of the list in sequence order and write out the
+   compressed data until the last chunk is written -- also write the header and
+   trailer and combine the individual check values of the input buffers */
+local void write_thread(void *dummy)
+{
+    long seq;                       /* next sequence number looking for */
+    struct job *job;                /* job pulled and working on */
+    size_t len;                     /* input length */
+    int more;                       /* true if more chunks to write */
     unsigned long head;             /* header length */
     unsigned long ulen;             /* total uncompressed size (overflow ok) */
     unsigned long clen;             /* total compressed size (overflow ok) */
     unsigned long check;            /* check value of uncompressed data */
 
-    /* build and write gzip header */
+    /* build and write header */
     Trace((&quot;-- write thread running&quot;));
     head = put_header();
 
     /* process output of compress threads until end of input */    
     ulen = clen = 0;
     check = CHECK(0L, Z_NULL, 0);
-    n = 0;
+    seq = 0;
     do {
-        /* wait for compress thread to start, then wait to complete */
-        flag_wait(&amp;(jobs[n].busy), COMP);
-        pthread_join(jobs[n].comp, NULL);
+        /* get next write job in order */
+        possess(write_first);
+        wait_for(write_first, TO_BE, seq);
+        job = write_head;
+        write_head = job-&gt;next;
+        twist(write_first, TO, write_head == NULL ? -1 : write_head-&gt;seq);
 
-        /* now that compress is done, allow read thread to use input buffer */
-        flag_set(&amp;(jobs[n].busy), WRITE);
+        /* update lengths, save uncompressed length for COMB */
+        more = job-&gt;more;
+        len = job-&gt;in-&gt;len;
+        drop_space(job-&gt;in);
+        ulen += (unsigned long)len;
+        clen += (unsigned long)(job-&gt;out-&gt;len);
 
-        /* write compressed data and update length and check value */
-        Trace((&quot;-- writing %d&quot;, n));
-        writen(outd, jobs[n].out, jobs[n].strm.next_out - jobs[n].out);
-        len = jobs[n].len;
-        ulen += len;
-        clen += jobs[n].strm.next_out - jobs[n].out;
-        Trace((&quot;-- wrote %d&quot;, n));
-        check = COMB(check, jobs[n].check, len);
+        /* write the compressed data and drop the output buffer */
+        Trace((&quot;-- writing #%ld&quot;, seq));
+        writen(outd, job-&gt;out-&gt;buf, job-&gt;out-&gt;len);
+        drop_space(job-&gt;out);
+        Trace((&quot;-- wrote #%ld%s&quot;, seq, more ? &quot;&quot; : &quot; (last)&quot;));
 
-        /* release this work unit and go to the next work unit */
-        Trace((&quot;-- releasing %d&quot;, n));
-        flag_set(&amp;(jobs[n].busy), IDLE);
-        n = NEXT(n);
-        if (n == 0 &amp;&amp; verbosity &gt; 1) {
-            putc('.', stderr);
-            fflush(stderr);
-        }
+        /* wait for check calculation to complete, then combine, once
+           the compress thread is done with the input, release it */
+        possess(job-&gt;calc);
+        wait_for(job-&gt;calc, TO_BE, 1);
+        release(job-&gt;calc);
+        check = COMB(check, job-&gt;check, len);
 
-        /* an input buffer less than size in length indicates end of input */
-    } while (len == size);
+        /* free the job */
+        free_lock(job-&gt;calc);
+        free(job);
 
+        /* get the next buffer in sequence */
+        seq++;
+    } while (more);
+
     /* write trailer */
     put_trailer(ulen, clen, check, head);
-    return NULL;
+
+    /* verify no more jobs, prepare for next use */
+    possess(compress_have);
+    assert(compress_head == NULL &amp;&amp; peek_lock(compress_have) == 0);
+    release(compress_have);
+    possess(write_first);
+    assert(write_head == NULL);
+    twist(write_first, TO, -1);
 }
 
-/* compress ind to outd in the gzip format, using multiple threads for the
-   compression and checj calculation and another thread for writing the output,
-   the read thread is the main thread */
-local void read_thread(void)
+/* compress ind to outd, using multiple threads for the compression and check
+   value calculations and one other thread for writing the output -- compress
+   threads will be launched and left running (waiting actually) to support
+   subsequent calls of parallel_compress() */
+local void parallel_compress(void)
 {
-    int n;                          /* general index */
-    size_t got;                     /* amount read */
-    pthread_t write;                /* write thread */
+    long seq;                       /* sequence number */
+    struct space *prev;             /* previous input space */
+    struct space *next;             /* next input space */
+    struct job *job;                /* job for compress, then write */
+    int more;                       /* true if more input to read */
 
-    /* allocate new or clean up existing work units */
-    jobs_new();
+    /* if first time or after an option change, setup the job lists */
+    setup_jobs();
 
     /* start write thread */
-    pthread_create(&amp;write, &amp;attr, write_thread, NULL);
+    writeth = launch(write_thread, NULL);
 
     /* read from input and start compress threads (write thread will pick up
        the output of the compress threads) */
-    n = 0;
+    seq = 0;
+    prev = NULL;
+    next = get_space(&amp;in_pool);
+    next-&gt;len = readn(ind, next-&gt;buf, next-&gt;pool-&gt;size);
     do {
-        /* initialize this work unit if it's the first time it's used */
-        if (jobs[n].buf == NULL)
-            job_init(jobs + n);
+        /* create a new job, use next input chunk, previous as dictionary */
+        job = malloc(sizeof(struct job));
+        if (job == NULL)
+            bail(&quot;not enough memory&quot;, &quot;&quot;);
+        job-&gt;seq = seq;
+        job-&gt;in = next;
+        job-&gt;out = dict ? prev : NULL;  /* dictionary for compression */
+        job-&gt;calc = new_lock(0);
 
-        /* read input data, but wait for last compress on this work unit to be
-           done, and wait for the dictionary to be used by the last compress on
-           the next work unit */
-        flag_wait_not(&amp;(jobs[n].busy), COMP);
-        flag_wait_not(&amp;(jobs[NEXT(n)].busy), COMP);
-        got = readn(ind, jobs[n].buf, size);
-        Trace((&quot;-- have read %d&quot;, n));
+        /* check for end of file, reading next chunk if not sure */
+        if (next-&gt;len &lt; next-&gt;pool-&gt;size)
+            more = 0;
+        else {
+            next = get_space(&amp;in_pool);
+            next-&gt;len = readn(ind, next-&gt;buf, next-&gt;pool-&gt;size);
+            more = next-&gt;len != 0;
+            if (!more)
+                drop_space(next);       /* won't be using it */
+            if (dict &amp;&amp; more) {
+                use_space(job-&gt;in);     /* hold as dictionary for next loop */
+                prev = job-&gt;in;
+            }
+        }
+        job-&gt;more = more;
+        Trace((&quot;-- read #%ld%s&quot;, seq, more ? &quot;&quot; : &quot; (last)&quot;));
+        if (++seq &lt; 1)
+            bail(&quot;input too long: &quot;, in);
 
-        /* start compress thread, but wait for write to be done first */
-        flag_wait(&amp;(jobs[n].busy), IDLE);
-        jobs[n].len = got;
-        pthread_create(&amp;(jobs[n].comp), &amp;attr, compress_thread, jobs + n);
+        /* start another compress thread if needed */
+        if (cthreads &lt; seq &amp;&amp; cthreads &lt; procs) {
+            (void)launch(compress_thread, NULL);
+            cthreads++;
+        }
 
-        /* mark work unit so write thread knows compress was started */
-        flag_set(&amp;(jobs[n].busy), COMP);
+        /* put job at end of compress list, let all the compressors know */
+        possess(compress_have);
+        job-&gt;next = NULL;
+        *compress_tail = job;
+        compress_tail = &amp;(job-&gt;next);
+        twist(compress_have, BY, +1);
 
-        /* go to the next work unit */
-        n = NEXT(n);
+        /* do until end of input */
+    } while (more);
 
-        /* do until end of input, indicated by a read less than size */
-    } while (got == size);
-
-    /* wait for the write thread to complete -- the write thread will join with
-       all of the compress threads, so this waits for all of the threads to
-       complete */
-    pthread_join(write, NULL);
-    Trace((&quot;-- all threads joined&quot;));
+    /* wait for the write thread to complete (we leave the compress threads out
+       there and waiting in case there is another stream to compress) */
+    join(writeth);
+    writeth = NULL;
+    Trace((&quot;-- write thread joined&quot;));
 }
 
 #endif
 
-/* do a simple gzip in a single thread from ind to outd */
-local void single_gzip(void)
+/* do a simple compression in a single thread from ind to outd -- if reset is
+   true, instead free the memory that was allocated and retained for input,
+   output, and deflate */
+local void single_compress(int reset)
 {
     size_t got;                     /* amount read */
+    size_t more;                    /* amount of next read (0 if eof) */
     unsigned long head;             /* header length */
     unsigned long ulen;             /* total uncompressed size (overflow ok) */
     unsigned long clen;             /* total compressed size (overflow ok) */
     unsigned long check;            /* check value of uncompressed data */
-    z_stream *strm;                 /* convenient pointer */
+    static unsigned out_size;       /* size of output buffer */
+    static unsigned char *in, *next, *out;  /* reused i/o buffers */
+    static z_stream *strm = NULL;   /* reused deflate structure */
 
-    /* write gzip header */
+    /* if requested, just release the allocations and return */
+    if (reset) {
+        if (strm != NULL) {
+            deflateEnd(strm);
+            free(strm);
+            free(out);
+            free(next);
+            free(in);
+            strm = NULL;
+        }
+        return;
+    }
+
+    /* initialize the deflate structure if this is the first time */
+    if (strm == NULL) {
+        out_size = size &gt; MAX ? MAX : (unsigned)size;
+        if ((in = malloc(size)) == NULL ||
+            (next = malloc(size)) == NULL ||
+            (out = malloc(out_size)) == NULL ||
+            (strm = malloc(sizeof(z_stream))) == NULL)
+            bail(&quot;not enough memory&quot;, &quot;&quot;);
+        strm-&gt;zfree = Z_NULL;
+        strm-&gt;zalloc = Z_NULL;
+        strm-&gt;opaque = Z_NULL;
+        if (deflateInit2(strm, level, Z_DEFLATED, -15, 8,
+                         Z_DEFAULT_STRATEGY) != Z_OK)
+            bail(&quot;not enough memory&quot;, &quot;&quot;);
+    }
+
+    /* write header */
     head = put_header();
 
-    /* if first time, initialize buffers and deflate */
-    jobs_new();
-    if (jobs-&gt;buf == NULL)
-        job_init(jobs);
+    /* set compression level in case it changed */
+    (void)deflateReset(strm);
+    (void)deflateParams(strm, level, Z_DEFAULT_STRATEGY);
 
     /* do raw deflate and calculate check value */
-    strm = &amp;(jobs-&gt;strm);
-    (void)deflateReset(strm);
     ulen = clen = 0;
     check = CHECK(0L, Z_NULL, 0);
+    more = readn(ind, next, size);
     do {
-        /* read some data to compress */
-        got = readn(ind, jobs-&gt;buf, size);
+        /* get data to compress, see if there is any more input */
+        got = more;
+        { unsigned char *temp; temp = in; in = next; next = temp; }
+        more = got &lt; size ? 0 : readn(ind, next, size);
         ulen += (unsigned long)got;
-        strm-&gt;next_in = jobs-&gt;buf;
+        strm-&gt;next_in = in;
 
         /* compress MAX-size chunks in case unsigned type is small */
         while (got &gt; MAX) {
             strm-&gt;avail_in = MAX;
             check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
             do {
-                strm-&gt;avail_out = size;
-                strm-&gt;next_out = jobs-&gt;out;
+                strm-&gt;avail_out = out_size;
+                strm-&gt;next_out = out;
                 (void)deflate(strm, Z_NO_FLUSH);
-                writen(outd, jobs-&gt;out, size - strm-&gt;avail_out);
-                clen += size - strm-&gt;avail_out;
+                writen(outd, out, out_size - strm-&gt;avail_out);
+                clen += out_size - strm-&gt;avail_out;
             } while (strm-&gt;avail_out == 0);
+            assert(strm-&gt;avail_in == 0);
             got -= MAX;
         }
 
-        /* compress the remainder, finishing if end of input */
-        if (got)
-            check = CHECK(check, strm-&gt;next_in, got);
-        strm-&gt;avail_in = got;
+        /* compress the remainder, finishing if end of input -- when not -i,
+           use a Z_SYNC_FLUSH so that this and parallel compression produce the
+           same output */
+        strm-&gt;avail_in = (unsigned)got;
+        check = CHECK(check, strm-&gt;next_in, strm-&gt;avail_in);
         do {
-            strm-&gt;avail_out = size;
-            strm-&gt;next_out = jobs-&gt;out;
-            (void)deflate(strm, got &lt; size ? Z_FINISH :
-                            (dict ? Z_NO_FLUSH : Z_FULL_FLUSH));
-            writen(outd, jobs-&gt;out, size - strm-&gt;avail_out);
-            clen += size - strm-&gt;avail_out;
+            strm-&gt;avail_out = out_size;
+            strm-&gt;next_out = out;
+            (void)deflate(strm,
+                more ? (dict ? Z_SYNC_FLUSH : Z_FULL_FLUSH) : Z_FINISH);
+            writen(outd, out, out_size - strm-&gt;avail_out);
+            clen += out_size - strm-&gt;avail_out;
         } while (strm-&gt;avail_out == 0);
+        assert(strm-&gt;avail_in == 0);
 
-        /* do until read doesn't fill buffer */
-    } while (got == size);
+        /* do until no more input */
+    } while (more);
 
     /* write trailer */
     put_trailer(ulen, clen, check, head);
@@ -1054,14 +1380,121 @@
 local unsigned char *in_next;       /* next unused byte in buffer */
 local size_t in_left;               /* number of unused bytes in buffer */
 local int in_eof;                   /* true if reached end of file on input */
+local int in_short;                 /* true if last read didn't fill buffer */
 local off_t in_tot;                 /* total bytes read from input */
 local off_t out_tot;                /* total bytes written to output */
 local unsigned long out_check;      /* check value of output */
 
-/* buffered reading macros for decompresion and listing */
-#define LOAD() (in_eof ? 0 : (in_left = readn(ind, in_next = in_buf, BUF), \
-                    in_left ? (in_tot += in_left) : (in_eof = 1), in_left))
-#define GET() (in_eof || (in_left == 0 &amp;&amp; LOAD() == 0) ? EOF : \
+#ifndef NOTHREAD
+/* parallel reading */
+
+local unsigned char in_buf2[BUF];   /* second buffer for parallel reads */
+local size_t in_len;                /* data waiting in next buffer */
+local int in_which;                 /* -1: start, 0: in_buf2, 1: in_buf */
+local lock *load_state;             /* value = 0 to wait, 1 to read a buffer */
+local thread *load_thread;          /* load_read() thread for joining */
+
+/* parallel read thread */
+local void load_read(void *dummy)
+{
+    size_t len;
+
+    Trace((&quot;-- launched decompress read thread&quot;));
+    do {
+        possess(load_state);
+        wait_for(load_state, TO_BE, 1);
+        in_len = len = readn(ind, in_which ? in_buf : in_buf2, BUF);
+        Trace((&quot;-- decompress read thread read %lu bytes&quot;, len));
+        twist(load_state, TO, 0);
+    } while (len == BUF);
+    Trace((&quot;-- exited decompress read thread&quot;));
+}
+
+#endif
+
+/* load() is called when in_left has gone to zero in order to provide more
+   input data: load the input buffer with BUF or less bytes (less if at end of
+   file) from the file ind, set in_next to point to the in_left bytes read,
+   update in_tot, and return in_left -- in_eof is set to true when in_left has
+   gone to zero and there is no more data left to read from ind */
+local size_t load(void)
+{
+    /* if already detected end of file, do nothing */
+    if (in_short) {
+        in_eof = 1;
+        return 0;
+    }
+
+#ifndef NOTHREAD
+    /* if first time in or procs == 1, read a buffer to have something to
+       return, otherwise wait for the previous read job to complete */
+    if (procs &gt; 1) {
+        /* if first time, fire up the read thread, ask for a read */
+        if (in_which == -1) {
+            in_which = 1;
+            load_state = new_lock(1);
+            load_thread = launch(load_read, NULL);
+        }
+
+        /* wait for the previously requested read to complete */
+        possess(load_state);
+        wait_for(load_state, TO_BE, 0);
+        release(load_state);
+
+        /* set up input buffer with the data just read */
+        in_next = in_which ? in_buf : in_buf2;
+        in_left = in_len;
+
+        /* if not at end of file, alert read thread to load next buffer,
+           alternate between in_buf and in_buf2 */
+        if (in_len == BUF) {
+            in_which = 1 - in_which;
+            possess(load_state);
+            twist(load_state, TO, 1);
+        }
+
+        /* at end of file -- join read thread (already exited), clean up */
+        else {
+            join(load_thread);
+            free_lock(load_state);
+            in_which = -1;
+        }
+    }
+    else
+#endif
+    {
+        /* don't use threads -- simply read a buffer into in_buf */
+        in_left = readn(ind, in_next = in_buf, BUF);
+    }
+
+    /* note end of file */
+    if (in_left &lt; BUF) {
+        in_short = 1;
+
+        /* if we got bupkis, now is the time to mark eof */
+        if (in_left == 0)
+            in_eof = 1;
+    }
+
+    /* update the total and return the available bytes */
+    in_tot += in_left;
+    return in_left;
+}
+
+/* initialize for reading new input */
+local void in_init(void)
+{
+    in_left = 0;
+    in_eof = 0;
+    in_short = 0;
+    in_tot = 0;
+#ifndef NOTHREAD
+    in_which = -1;
+#endif
+}
+
+/* buffered reading macros for decompression and listing */
+#define GET() (in_eof || (in_left == 0 &amp;&amp; load() == 0) ? EOF : \
                (in_left--, *in_next++))
 #define GET2() (tmp2 = GET(), tmp2 + (GET() &lt;&lt; 8))
 #define GET4() (tmp4 = GET2(), tmp4 + ((unsigned long)(GET2()) &lt;&lt; 16))
@@ -1070,7 +1503,7 @@
         size_t togo = (dist); \
         while (togo &gt; in_left) { \
             togo -= in_left; \
-            if (LOAD() == 0) \
+            if (load() == 0) \
                 return -1; \
         } \
         in_left -= togo; \
@@ -1219,7 +1652,7 @@
                 memcpy(next, in_next, in_left);
                 fname -= in_left;
                 next += in_left;
-                if (LOAD() == 0)
+                if (load() == 0)
                     return -3;
             }
             memcpy(next, in_next, fname);
@@ -1271,7 +1704,7 @@
             bail(&quot;not enough memory&quot;, &quot;&quot;);
         have = 0;
         do {
-            if (in_left == 0 &amp;&amp; LOAD() == 0)
+            if (in_left == 0 &amp;&amp; load() == 0)
                 return -3;
             end = memchr(in_next, 0, in_left);
             copy = end == NULL ? in_left : (end - in_next) + 1;
@@ -1320,8 +1753,6 @@
         len = 4;
         if (strcmp(nm, &quot;.zip&quot;) == 0 || strcmp(nm, &quot;.ZIP&quot;) == 0)
             return 4;
-        if (strcmp(nm, &quot;.spl&quot;) == 0 || strcmp(nm, &quot;.SPL&quot;) == 0)
-            return 4;
     }
     if (len &gt; 3) {
         nm += len - 3;
@@ -1340,8 +1771,8 @@
 }
 
 /* listing file name lengths for -l and -lv */
-#define NAMEMAX1 48     /* name display limit at vebosity 1 */
-#define NAMEMAX2 16     /* name display limit at vebosity 2 */
+#define NAMEMAX1 48     /* name display limit at verbosity 1 */
+#define NAMEMAX2 16     /* name display limit at verbosity 2 */
 
 /* print gzip or lzw file information */
 local void show_info(int method, unsigned long check, off_t len, int cont)
@@ -1369,7 +1800,6 @@
     /* convert time stamp to text */
     if (stamp) {
         strcpy(mod, ctime(&amp;stamp));
-        ctime_r(&amp;stamp, mod);
         now = time(NULL);
         if (strcmp(mod + 20, ctime(&amp;now) + 20) != 0)
             strcpy(mod + 11, mod + 19);
@@ -1404,12 +1834,13 @@
         if ((form == 3 &amp;&amp; !decode) ||
             (method == 8 &amp;&amp; in_tot &gt; (len + (len &gt;&gt; 10) + 12)) ||
             (method == 256 &amp;&amp; in_tot &gt; len + (len &gt;&gt; 1) + 3))
-            printf(&quot;%10llu %10llu?  unk    %s\n&quot;,
-                   (long long unsigned int)in_tot,
-                   (long long unsigned int)len, name);
+            printf(sizeof(off_t) == 4 ? &quot;%10lu %10lu?  unk    %s\n&quot; :
+                                        &quot;%10llu %10llu?  unk    %s\n&quot;,
+                   in_tot, len, name);
         else
-            printf(&quot;%10llu %10llu %6.1f%%  %s\n&quot;,
-                   (long long unsigned int)in_tot, (long long unsigned int)len,
+            printf(sizeof(off_t) == 4 ? &quot;%10lu %10lu %6.1f%%  %s\n&quot; :
+                                        &quot;%10llu %10llu %6.1f%%  %s\n&quot;,
+                   in_tot, len,
                    len == 0 ? 0 : 100 * (len - in_tot)/(double)len,
                    name);
     }
@@ -1426,10 +1857,8 @@
     unsigned char tail[8];  /* trailer containing check and length */
     unsigned long check, len;   /* check value and length from trailer */
 
-    /* initialize buffer */
-    in_left = 0;
-    in_eof = 0;
-    in_tot = 0;
+    /* initialize input buffer */
+    in_init();
 
     /* read header information and position input after header */
     method = get_header(1);
@@ -1457,7 +1886,7 @@
                 in_next += in_left - len;
                 while (len--)
                     check = (check &lt;&lt; 8) + *in_next++;
-            } while (LOAD() != 0);
+            } while (load() != 0);
             check &amp;= LOW32;
         }
         else {
@@ -1475,7 +1904,7 @@
     if (method == 256) {
         at = lseek(ind, 0, SEEK_END);
         if (at == -1)
-            while (LOAD() != 0)
+            while (load() != 0)
                 ;
         else
             in_tot = at;
@@ -1485,7 +1914,7 @@
     }
 
     /* skip to end to get trailer (8 bytes), compute compressed length */
-    if (in_next - in_buf &lt; BUF - in_left) { /* whole thing already read */
+    if (in_short) {                     /* whole thing already read */
         if (in_left &lt; 8) {
             if (verbosity &gt; 0)
                 fprintf(stderr, &quot;%s not a valid gzip file -- skipping\n&quot;,
@@ -1504,7 +1933,7 @@
         do {
             n = in_left &lt; 8 ? in_left : 8;
             memcpy(tail, in_next + (in_left - n), n);
-            LOAD();
+            load();
         } while (in_left == BUF);       /* read until end */
         if (in_left &lt; 8) {
             if (n + in_left &lt; 8) {
@@ -1538,76 +1967,123 @@
     RELEASE(hname);
 }
 
-/* --- decompress gzip or zlib input --- */
+/* --- decompress deflate input --- */
 
 /* call-back input function for inflateBack() */
 local unsigned inb(void *desc, unsigned char **buf)
 {
-    LOAD();
+    load();
     *buf = in_next;
     return in_left;
 }
 
-#ifdef NOTHREAD
+/* output buffers and window for infchk() and unlzw() */
+#define OUTSIZE 32768U      /* must be at least 32K for inflateBack() window */
+local unsigned char out_buf[OUTSIZE];
 
-/* call-back output function for inflateBack() */
-local int outb(void *desc, unsigned char *buf, unsigned len)
+#ifndef NOTHREAD
+/* output data for parallel write and check */
+local unsigned char out_copy[OUTSIZE];
+local size_t out_len;
+
+/* outb threads states */
+local lock *outb_write_more = NULL;
+local lock *outb_check_more;
+
+/* output write thread */
+local void outb_write(void *dummy)
 {
-    out_tot += len;
-    out_check = CHECK(out_check, buf, len);
-    if (decode == 1)
-        writen(outd, buf, len);
-    return 0;
+    size_t len;
+
+    Trace((&quot;-- launched decompress write thread&quot;));
+    do {
+        possess(outb_write_more);
+        wait_for(outb_write_more, TO_BE, 1);
+        len = out_len;
+        if (len &amp;&amp; decode == 1)
+            writen(outd, out_copy, len);
+        Trace((&quot;-- decompress wrote %lu bytes&quot;, len));
+        twist(outb_write_more, TO, 0);
+    } while (len);
+    Trace((&quot;-- exited decompress write thread&quot;));
 }
 
-#else
-
-/* check value work unit */
-struct do_check {
-    unsigned long check;
-    unsigned char *buf;
-    unsigned len;
-};
-
-/* check value computation thread */
-local void *run_check(void *arg)
+/* output check thread */
+local void outb_check(void *dummy)
 {
-    struct do_check *work = arg;
+    size_t len;
 
-    work-&gt;check = CHECK(work-&gt;check, work-&gt;buf, work-&gt;len);
-    return NULL;
+    Trace((&quot;-- launched decompress check thread&quot;));
+    do {
+        possess(outb_check_more);
+        wait_for(outb_check_more, TO_BE, 1);
+        len = out_len;
+        out_check = CHECK(out_check, out_copy, len);
+        Trace((&quot;-- decompress checked %lu bytes&quot;, len));
+        twist(outb_check_more, TO, 0);
+    } while (len);
+    Trace((&quot;-- exited decompress check thread&quot;));
 }
+#endif
 
-/* call-back output function for inflateBack() */
+/* call-back output function for inflateBack() -- wait for the last write and
+   check calculation to complete, copy the write buffer, and then alert the
+   write and check threads and return for more decompression while that's
+   going on (or just write and check if no threads or if proc == 1) */
 local int outb(void *desc, unsigned char *buf, unsigned len)
 {
-    struct do_check work;
-    pthread_t check;
+#ifndef NOTHREAD
+    static thread *wr, *ch;
 
-    out_tot += len;
     if (procs &gt; 1) {
-        work.check = out_check;
-        work.buf = buf;
-        work.len = len;
-        pthread_create(&amp;check, &amp;attr, run_check, &amp;work);
+        /* if first time, initialize state and launch threads */
+        if (outb_write_more == NULL) {
+            outb_write_more = new_lock(0);
+            outb_check_more = new_lock(0);
+            wr = launch(outb_write, NULL);
+            ch = launch(outb_check, NULL);
+        }
+
+        /* wait for previous write and check threads to complete */
+        possess(outb_check_more);
+        wait_for(outb_check_more, TO_BE, 0);
+        possess(outb_write_more);
+        wait_for(outb_write_more, TO_BE, 0);
+
+        /* copy the output and alert the worker bees */
+        out_len = len;
+        out_tot += len;
+        memcpy(out_copy, buf, len);
+        twist(outb_write_more, TO, 1);
+        twist(outb_check_more, TO, 1);
+
+        /* if requested with len == 0, clean up -- terminate and join write and
+           check threads, free lock */
+        if (len == 0) {
+            join(ch);
+            join(wr);
+            free_lock(outb_check_more);
+            free_lock(outb_write_more);
+            outb_write_more = NULL;
+        }
+
+        /* return for more decompression while last buffer is being written
+           and having its check value calculated -- we wait for those to finish
+           the next time this function is called */
+        return 0;
     }
-    else
+#endif
+
+    /* if just one process or no threads, then do it without threads */
+    if (len) {
+        if (decode == 1)
+            writen(outd, buf, len);
         out_check = CHECK(out_check, buf, len);
-    if (decode == 1)
-        writen(outd, buf, len);
-    if (procs &gt; 1) {
-        pthread_join(check, NULL);
-        out_check = work.check;
+        out_tot += len;
     }
     return 0;
 }
 
-#endif
-
-/* output buffer and window for infchk() and unlzw() */
-#define OUTSIZE 32768U      /* must be at least 32K for inflateBack() window */
-local unsigned char outbuf[OUTSIZE];
-
 /* inflate for decompression or testing -- decompress from ind to outd unless
    decode != 1, in which case just test ind, and then also list if list != 0;
    look for and decode multiple, concatenated gzip and/or zlib streams;
@@ -1630,7 +2106,7 @@
         strm.zalloc = Z_NULL;
         strm.zfree = Z_NULL;
         strm.opaque = Z_NULL;
-        ret = inflateBackInit(&amp;strm, 15, outbuf);
+        ret = inflateBackInit(&amp;strm, 15, out_buf);
         if (ret != Z_OK)
             bail(&quot;not enough memory&quot;, &quot;&quot;);
 
@@ -1643,6 +2119,7 @@
         in_left = strm.avail_in;
         in_next = strm.next_in;
         inflateBackEnd(&amp;strm);
+        outb(NULL, NULL, 0);        /* finish off final write and check */
 
         /* compute compressed data length */
         clen = in_tot - in_left;
@@ -1668,8 +2145,9 @@
 
                 /* if second length doesn't match, try 64-bit lengths */
                 if (zip_ulen != (out_tot &amp; LOW32)) {
+                    unsigned long dummy = 0;
                     zip_ulen = GET4();
-                    (void) GET4();
+                    dummy = GET4();
                 }
                 if (in_eof)
                     bail(&quot;corrupted zip entry -- missing trailer: &quot;, in);
@@ -1731,7 +2209,7 @@
         rem = 0; \
         if (chunk &gt; in_left) { \
             chunk -= in_left; \
-            if (LOAD() == 0) \
+            if (load() == 0) \
                 break; \
             if (chunk &gt; in_left) { \
                 chunk = in_left = 0; \
@@ -1795,7 +2273,7 @@
     rem = (unsigned)got &gt;&gt; 1;               /* remaining 7 bits */
     left = 7;
     chunk = bits - 2;                       /* 7 bytes left in this chunk */
-    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */
+    out_buf[0] = (unsigned char)final;      /* write first decompressed byte */
     outcnt = 1;
 
     /* decode codes */
@@ -1818,7 +2296,7 @@
             /* write remaining buffered output */
             out_tot += outcnt;
             if (outcnt &amp;&amp; decode == 1)
-                writen(outd, outbuf, outcnt);
+                writen(outd, out_buf, outcnt);
             return;
         }
         code += (unsigned)got &lt;&lt; left;      /* middle (or high) bits of code */
@@ -1885,15 +2363,15 @@
         /* write output in forward order */
         while (stack &gt; OUTSIZE - outcnt) {
             while (outcnt &lt; OUTSIZE)
-                outbuf[outcnt++] = match[--stack];
+                out_buf[outcnt++] = match[--stack];
             out_tot += outcnt;
             if (decode == 1)
-                writen(outd, outbuf, outcnt);
+                writen(outd, out_buf, outcnt);
             outcnt = 0;
         }
         p = match + stack;
         do {
-            outbuf[outcnt++] = *--p;
+            out_buf[outcnt++] = *--p;
         } while (p &gt; match);
         stack = 0;
 
@@ -1925,17 +2403,16 @@
 {
     struct stat st;
     struct timeval times[2];
-    int status = 0;
 
     /* get all of from's Unix meta data, return if not a regular file */
     if (stat(from, &amp;st) != 0 || (st.st_mode &amp; S_IFMT) != S_IFREG)
         return;
 
     /* set to's mode bits, ignore errors */
-    status = chmod(to, st.st_mode &amp; 07777);
+    chmod(to, st.st_mode &amp; 07777);
 
     /* copy owner's user and group, ignore errors */
-    status = chown(to, st.st_uid, st.st_gid);
+    chown(to, st.st_uid, st.st_gid);
 
     /* copy access and modify times, ignore errors */
     times[0].tv_sec = st.st_atime;
@@ -1986,6 +2463,11 @@
         /* only process regular files, but allow symbolic links if -f,
            recurse into directory if -r */
         if (lstat(in, &amp;st)) {
+#ifdef EOVERFLOW
+            if (errno == EOVERFLOW || errno == EFBIG)
+                bail(in,
+                    &quot; too large -- pigz not compiled with large file support&quot;);
+#endif
             if (verbosity &gt; 0)
                 fprintf(stderr, &quot;%s does not exist -- skipping\n&quot;, in);
             return;
@@ -2017,7 +2499,7 @@
             struct dirent *next;
 
             /* accumulate list of entries (need to do this, since readdir()
-               behavior not defined if changing the directory between calls) */
+               behavior not defined if directory modified between calls) */
             here = opendir(in);
             if (here == NULL)
                 return;
@@ -2110,9 +2592,7 @@
     /* if decoding or testing, try to read gzip header */
     hname = NULL;
     if (decode) {
-        in_left = 0;
-        in_eof = 0;
-        in_tot = 0;
+        in_init();
         method = get_header(1);
         if (method != 8 &amp;&amp; method != 256) {
             RELEASE(hname);
@@ -2230,10 +2710,10 @@
     }
 #ifndef NOTHREAD
     else if (procs &gt; 1)
-        read_thread();
+        parallel_compress();
 #endif
     else
-        single_gzip();
+        single_compress(0);
     if (verbosity &gt; 1) {
         putc('\n', stderr);
         fflush(stderr);
@@ -2245,6 +2725,7 @@
     if (outd != 1) {
         if (close(outd))
             bail(&quot;write error on &quot;, out);
+        outd = -1;              /* now prevent deletion on interrupt */
         if (ind != 0) {
             copymeta(in, out);
             if (!keep)
@@ -2270,7 +2751,7 @@
 &quot;  -0 to -9, --fast, --best   Compression levels, --fast is -1, --best is -9&quot;,
 &quot;  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)&quot;,
 #ifndef NOTHREAD
-&quot;  -p, --processes n    Allow up to n compression threads (default 32)&quot;,
+&quot;  -p, --processes n    Allow up to n compression threads (default 8)&quot;,
 #endif
 &quot;  -i, --independent    Compress blocks independently for damage recovery&quot;,
 &quot;  -R, --rsyncable      Input-determined block locations for rsync&quot;,
@@ -2281,6 +2762,7 @@
 &quot;  -r, --recursive      Process the contents of all subdirectories&quot;,
 &quot;  -s, --suffix .sss    Use suffix .sss instead of .gz (for compression)&quot;,
 &quot;  -z, --zlib           Compress to zlib (.zz) instead of gzip format&quot;,
+&quot;  -K, --zip            Compress to PKWare zip (.zip) single entry format&quot;,
 &quot;  -k, --keep           Do not delete original file after processing&quot;,
 &quot;  -c, --stdout         Write all processed output to stdout (won't delete)&quot;,
 &quot;  -N, --name           Store/restore file name and mod time in/from header&quot;,
@@ -2310,16 +2792,11 @@
 /* set option defaults */
 local void defaults(void)
 {
-    /* 32 processes and 128K buffers were found to provide good utilization of
-       four cores (about 97%) and balanced the overall execution time impact of
-       more threads against more dictionary processing for a fixed amount of
-       memory -- the memory usage for these settings and full use of all work
-       units (at least 4 MB of input) is 16.2 MB */
     level = Z_DEFAULT_COMPRESSION;
 #ifdef NOTHREAD
     procs = 1;
 #else
-    procs = 32;
+    procs = 8;
 #endif
     size = 131072UL;
     rsync = 0;                      /* don't do rsync blocking */
@@ -2348,6 +2825,17 @@
     {&quot;version&quot;, &quot;V&quot;}, {&quot;zip&quot;, &quot;K&quot;}, {&quot;zlib&quot;, &quot;z&quot;}};
 #define NLOPTS (sizeof(longopts) / (sizeof(char *) &lt;&lt; 1))
 
+/* either new buffer size, new compression level, or new number of processes --
+   get rid of old buffers and threads to force the creation of new ones with
+   the new settings */
+local void new_opts(void)
+{
+    single_compress(1);
+#ifndef NOTHREAD
+    finish_jobs();
+#endif
+}
+
 /* process an option, return true if a file name and not an option */
 local int option(char *arg)
 {
@@ -2368,7 +2856,7 @@
                  get &amp; 1 ? &quot;b&quot; : (get &amp; 2 ? &quot;p&quot; : &quot;s&quot;));
         arg++;
 
-        /* a single dash will be interpeted as stdin */
+        /* a single dash will be interpreted as stdin */
         if (*arg == 0)
             return 1;
 
@@ -2391,8 +2879,8 @@
             switch (*arg) {
             case '0': case '1': case '2': case '3': case '4':
             case '5': case '6': case '7': case '8': case '9':
-                jobs_free();
                 level = *arg - '0';
+                new_opts();
                 break;
             case 'K':  form = 2;  sufx = &quot;.zip&quot;;  break;
             case 'L':
@@ -2442,20 +2930,25 @@
                  get == 3 ? &quot;-b and -p&quot; :
                             (get == 5 ? &quot;-b and -s&quot; : &quot;-p and -s&quot;));
         if (get == 1) {
-            jobs_free();
             size = (size_t)(atol(arg)) &lt;&lt; 10;   /* chunk size */
             if (size &lt; DICT)
                 bail(&quot;block size too small (must be &gt;= 32K)&quot;, &quot;&quot;);
+            if (size + (size &gt;&gt; 11) + 10 &lt; (size &gt;&gt; 11) + 10 ||
+                (ssize_t)(size + (size &gt;&gt; 11) + 10) &lt; 0)
+                bail(&quot;block size too large&quot;, &quot;&quot;);
+            new_opts();
         }
         else if (get == 2) {
-            jobs_free();
             procs = atoi(arg);                  /* # processes */
             if (procs &lt; 1)
                 bail(&quot;need at least one process&quot;, &quot;&quot;);
+            if ((2 + (procs &lt;&lt; 1)) &lt; 1)
+                bail(&quot;too many processes&quot;, &quot;&quot;);
 #ifdef NOTHREAD
             if (procs &gt; 1)
                 bail(&quot;this pigz compiled without threads&quot;, &quot;&quot;);
 #endif
+            new_opts();
         }
         else if (get == 4)
             sufx = arg;                         /* gz suffix */
@@ -2467,6 +2960,16 @@
     return 1;
 }
 
+/* catch termination signal */
+local void cut_short(int sig)
+{
+    Trace((&quot;termination by user&quot;));
+    if (outd != -1 &amp;&amp; out != NULL)
+        unlink(out);
+    log_dump();
+    _exit(1);
+}
+
 /* Process arguments, compress in the gzip format.  Note that procs must be at
    least two in order to provide a dictionary in one work unit for the other
    work unit, and that size must be at least 32K to store a full dictionary. */
@@ -2477,15 +2980,15 @@
     char *opts, *p;                 /* environment default options, marker */
 
     /* prepare for interrupts and logging */
-    signal(SIGINT, cutshort);
-    gettimeofday(&amp;start, NULL);
-
+    signal(SIGINT, cut_short);
 #ifndef NOTHREAD
-    /* set thread creation defaults */
-    pthread_attr_init(&amp;attr);
-    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
-    pthread_attr_setstacksize(&amp;attr, 524288UL);
+    yarn_prefix = &quot;pigz&quot;;           /* prefix for yarn error messages */
+    yarn_abort = cut_short;         /* call on thread error */
 #endif
+#ifdef DEBUG
+    gettimeofday(&amp;start, NULL);     /* starting time for log entries */
+    log_init();                     /* initialize logging */
+#endif
 
     /* set all options to defaults */
     defaults();
@@ -2529,11 +3032,8 @@
     if (done == 0)
         process(NULL);
 
-    /* done -- release work units allocated by compression */
-    jobs_free();
+    /* done -- release resources, show log */
+    new_opts();
     log_dump();
-#ifndef NOTHREAD
-    pthread_attr_destroy(&amp;attr);
-#endif
     return 0;
 }

Added: kiwi-head/tools/pigz/yarn.c
===================================================================
--- kiwi-head/tools/pigz/yarn.c	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/tools/pigz/yarn.c	2008-11-28 10:54:48 UTC (rev 1804)
@@ -0,0 +1,365 @@
+/* yarn.c -- generic thread operations implemented using pthread functions
+ * Copyright (C) 2008 Mark Adler
+ * Version 1.1  26 Oct 2008  Mark Adler
+ * For conditions of distribution and use, see copyright notice in yarn.h
+ */
+
+/* Basic thread operations implemented using the POSIX pthread library.  All
+   pthread references are isolated within this module to allow alternate
+   implementations with other thread libraries.  See yarn.h for the description
+   of these operations. */
+
+/* Version history:
+   1.0    19 Oct 2008  First version
+   1.1    26 Oct 2008  No need to set the stack size -- remove
+                       Add yarn_abort() function for clean-up on error exit
+ */
+
+/* for thread portability */
+#define _POSIX_PTHREAD_SEMANTICS
+#define _REENTRANT
+
+/* external libraries and entities referenced */
+#include &lt;stdio.h&gt;      /* fprintf(), stderr */
+#include &lt;stdlib.h&gt;     /* exit(), malloc(), free(), NULL */
+#include &lt;pthread.h&gt;    /* pthread_t, pthread_create(), pthread_join(), */
+    /* pthread_attr_t, pthread_attr_init(), pthread_attr_destroy(),
+       PTHREAD_CREATE_JOINABLE, pthread_attr_setdetachstate(),
+       pthread_self(), pthread_equal(),
+       pthread_mutex_t, PTHREAD_MUTEX_INITIALIZER, pthread_mutex_init(),
+       pthread_mutex_lock(), pthread_mutex_unlock(), pthread_mutex_destroy(),
+       pthread_cond_t, PTHREAD_COND_INITIALIZER, pthread_cond_init(),
+       pthread_cond_broadcast(), pthread_cond_wait(), pthread_cond_destroy() */
+#include &lt;errno.h&gt;      /* ENOMEM, EAGAIN, EINVAL */
+
+/* interface definition */
+#include &quot;yarn.h&quot;
+
+/* constants */
+#define local static            /* for non-exported functions and globals */
+
+/* error handling external globals, resettable by application */
+char *yarn_prefix = &quot;yarn&quot;;
+void (*yarn_abort)(int) = NULL;
+
+
+/* immediately exit -- use for errors that shouldn't ever happen */
+local void fail(int err)
+{
+    fprintf(stderr, &quot;%s: %s (%d) -- aborting\n&quot;, yarn_prefix,
+            err == ENOMEM ? &quot;out of memory&quot; : &quot;internal pthread error&quot;, err);
+    if (yarn_abort != NULL)
+        yarn_abort(err);
+    exit(err == ENOMEM || err == EAGAIN ? err : EINVAL);
+}
+
+/* memory handling routines provided by user -- if none are provided, malloc()
+   and free() are used, which are therefore assumed to be thread-safe */
+typedef void *(*malloc_t)(size_t);
+typedef void (*free_t)(void *);
+local malloc_t my_malloc_f = malloc;
+local free_t my_free = free;
+
+/* use user-supplied allocation routines instead of malloc() and free() */
+void yarn_mem(malloc_t lease, free_t vacate)
+{
+    my_malloc_f = lease;
+    my_free = vacate;
+}
+
+/* memory allocation that cannot fail (from the point of view of the caller) */
+local void *my_malloc(size_t size)
+{
+    void *block;
+
+    if ((block = my_malloc_f(size)) == NULL)
+        fail(ENOMEM);
+    return block;
+}
+
+/* -- lock functions -- */
+
+struct lock_s {
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    long value;
+};
+
+lock *new_lock(long initial)
+{
+    int ret;
+    lock *bolt;
+
+    bolt = my_malloc(sizeof(struct lock_s));
+    if ((ret = pthread_mutex_init(&amp;(bolt-&gt;mutex), NULL)) ||
+        (ret = pthread_cond_init(&amp;(bolt-&gt;cond), NULL)))
+        fail(ret);
+    bolt-&gt;value = initial;
+    return bolt;
+}
+
+void possess(lock *bolt)
+{
+    int ret;
+
+    if ((ret = pthread_mutex_lock(&amp;(bolt-&gt;mutex))) != 0)
+        fail(ret);
+}
+
+void release(lock *bolt)
+{
+    int ret;
+
+    if ((ret = pthread_mutex_unlock(&amp;(bolt-&gt;mutex))) != 0)
+        fail(ret);
+}
+
+void twist(lock *bolt, enum twist_op op, long val)
+{
+    int ret;
+
+    if (op == TO)
+        bolt-&gt;value = val;
+    else if (op == BY)
+        bolt-&gt;value += val;
+    if ((ret = pthread_cond_broadcast(&amp;(bolt-&gt;cond))) ||
+        (ret = pthread_mutex_unlock(&amp;(bolt-&gt;mutex))))
+        fail(ret);
+}
+
+#define until(a) while(!(a))
+
+void wait_for(lock *bolt, enum wait_op op, long val)
+{
+    int ret;
+
+    switch (op) {
+    case TO_BE:
+        until (bolt-&gt;value == val)
+            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
+                fail(ret);
+        break;
+    case NOT_TO_BE:
+        until (bolt-&gt;value != val)
+            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
+                fail(ret);
+        break;
+    case TO_BE_MORE_THAN:
+        until (bolt-&gt;value &gt; val)
+            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
+                fail(ret);
+        break;
+    case TO_BE_LESS_THAN:
+        until (bolt-&gt;value &lt; val)
+            if ((ret = pthread_cond_wait(&amp;(bolt-&gt;cond), &amp;(bolt-&gt;mutex))) != 0)
+                fail(ret);
+    }
+}
+
+long peek_lock(lock *bolt)
+{
+    return bolt-&gt;value;
+}
+
+void free_lock(lock *bolt)
+{
+    int ret;
+    if ((ret = pthread_cond_destroy(&amp;(bolt-&gt;cond))) ||
+        (ret = pthread_mutex_destroy(&amp;(bolt-&gt;mutex))))
+        fail(ret);
+    my_free(bolt);
+}
+
+/* -- thread functions (uses lock functions above) -- */
+
+struct thread_s {
+    pthread_t id;
+    int done;                   /* true if this thread has exited */
+    thread *next;               /* for list of all launched threads */
+};
+
+/* list of threads launched but not joined, count of threads exited but not
+   joined (incremented by ignition() just before exiting) */
+local lock threads_lock = {
+    PTHREAD_MUTEX_INITIALIZER,
+    PTHREAD_COND_INITIALIZER,
+    0                           /* number of threads exited but not joined */
+};
+local thread *threads = NULL;       /* list of extant threads */
+
+/* structure in which to pass the probe and its payload to ignition() */
+struct capsule {
+    void (*probe)(void *);
+    void *payload;
+};
+
+/* mark the calling thread as done and alert join_all() */
+local void reenter(void *dummy)
+{
+    thread *match, **prior;
+    pthread_t me;
+
+    /* find this thread in the threads list by matching the thread id */
+    me = pthread_self();
+    possess(&amp;(threads_lock));
+    prior = &amp;(threads);
+    while ((match = *prior) != NULL) {
+        if (pthread_equal(match-&gt;id, me))
+            break;
+        prior = &amp;(match-&gt;next);
+    }
+    if (match == NULL)
+        fail(EINVAL);
+
+    /* mark this thread as done and move it to the head of the list */
+    match-&gt;done = 1;
+    if (threads != match) {
+        *prior = match-&gt;next;
+        match-&gt;next = threads;
+        threads = match;
+    }
+
+    /* update the count of threads to be joined and alert join_all() */
+    twist(&amp;(threads_lock), BY, +1);
+}
+
+/* all threads go through this routine so that just before the thread exits,
+   it marks itself as done in the threads list and alerts join_all() so that
+   the thread resources can be released -- use cleanup stack so that the
+   marking occurs even if the thread is cancelled */
+local void *ignition(void *arg)
+{
+    struct capsule *capsule = arg;
+
+    /* run reenter() before leaving */
+    pthread_cleanup_push(reenter, NULL);
+
+    /* execute the requested function with argument */
+    capsule-&gt;probe(capsule-&gt;payload);
+    my_free(capsule);
+
+    /* mark this thread as done and let join_all() know */
+    pthread_cleanup_pop(1);
+
+    /* exit thread */
+    return NULL;
+}
+
+/* not all POSIX implementations create threads as joinable by default, so that
+   is made explicit here */
+thread *launch(void (*probe)(void *), void *payload)
+{
+    int ret;
+    thread *th;
+    struct capsule *capsule;
+    pthread_attr_t attr;
+
+    /* construct the requested call and argument for the ignition() routine
+       (allocated instead of automatic so that we're sure this will still be
+       there when ignition() actually starts up -- ignition() will free this
+       allocation) */
+    capsule = my_malloc(sizeof(struct capsule));
+    capsule-&gt;probe = probe;
+    capsule-&gt;payload = payload;
+
+    /* assure this thread is in the list before join_all() or ignition() looks
+       for it */
+    possess(&amp;(threads_lock));
+
+    /* create the thread and call ignition() from that thread */
+    th = my_malloc(sizeof(struct thread_s));
+    if ((ret = pthread_attr_init(&amp;attr)) ||
+        (ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE)) ||
+        (ret = pthread_create(&amp;(th-&gt;id), &amp;attr, ignition, capsule)) ||
+        (ret = pthread_attr_destroy(&amp;attr)))
+        fail(ret);
+
+    /* put the thread in the threads list for join_all() */
+    th-&gt;done = 0;
+    th-&gt;next = threads;
+    threads = th;
+    release(&amp;(threads_lock));
+    return th;
+}
+
+void join(thread *ally)
+{
+    int ret;
+    thread *match, **prior;
+
+    /* wait for thread to exit and return its resources */
+    if ((ret = pthread_join(ally-&gt;id, NULL)) != 0)
+        fail(ret);
+
+    /* find the thread in the threads list */
+    possess(&amp;(threads_lock));
+    prior = &amp;(threads);
+    while ((match = *prior) != NULL) {
+        if (match == ally)
+            break;
+        prior = &amp;(match-&gt;next);
+    }
+    if (match == NULL)
+        fail(EINVAL);
+
+    /* remove thread from list and update exited count, free thread */
+    if (match-&gt;done)
+        threads_lock.value--;
+    *prior = match-&gt;next;
+    release(&amp;(threads_lock));
+    my_free(ally);
+}
+
+/* This implementation of join_all() only attempts to join threads that have
+   announced that they have exited (see ignition()).  When there are many
+   threads, this is faster than waiting for some random thread to exit while a
+   bunch of other threads have already exited. */
+int join_all(void)
+{
+    int ret, count;
+    thread *match, **prior;
+
+    /* grab the threads list and initialize the joined count */
+    count = 0;
+    possess(&amp;(threads_lock));
+
+    /* do until threads list is empty */
+    while (threads != NULL) {
+        /* wait until at least one thread has reentered */
+        wait_for(&amp;(threads_lock), NOT_TO_BE, 0);
+
+        /* find the first thread marked done (should be at or near the top) */
+        prior = &amp;(threads);
+        while ((match = *prior) != NULL) {
+            if (match-&gt;done)
+                break;
+            prior = &amp;(match-&gt;next);
+        }
+        if (match == NULL)
+            fail(EINVAL);
+
+        /* join the thread (will be almost immediate), remove from the threads
+           list, update the reenter count, and free the thread */
+        if ((ret = pthread_join(match-&gt;id, NULL)) != 0)
+            fail(ret);
+        threads_lock.value--;
+        *prior = match-&gt;next;
+        my_free(match);
+        count++;
+    }
+
+    /* let go of the threads list and return the number of threads joined */
+    release(&amp;(threads_lock));
+    return count;
+}
+
+/* cancel and join the thread -- the thread will cancel when it gets to a file
+   operation, a sleep or pause, or a condition wait */
+void destruct(thread *off_course)
+{
+    int ret;
+
+    if ((ret = pthread_cancel(off_course-&gt;id)) != 0)
+        fail(ret);
+    join(off_course);
+}

Added: kiwi-head/tools/pigz/yarn.h
===================================================================
--- kiwi-head/tools/pigz/yarn.h	2008-11-27 16:25:50 UTC (rev 1803)
+++ kiwi-head/tools/pigz/yarn.h	2008-11-28 10:54:48 UTC (rev 1804)
@@ -0,0 +1,134 @@
+/* yarn.h -- generic interface for thread operations
+ * Copyright (C) 2008 Mark Adler
+ * Version 1.1  26 Oct 2008  Mark Adler
+ */
+
+/*
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the author be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Mark Adler
+  <A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">madler at alumni.caltech.edu</A>
+ */
+
+/* Basic thread operations
+
+   This interface isolates the local operating system implementation of threads
+   from the application in order to facilitate platform independent use of
+   threads.  All of the implementation details are deliberately hidden.
+
+   Assuming adequate system resources and proper use, none of these functions
+   can fail.  As a result, any errors encountered will cause an exit() to be
+   executed.
+
+   These functions allow the simple launching and joining of threads, and the
+   locking of objects and synchronization of changes of objects.  The latter is
+   implemented with a single lock type that contains an integer value.  The
+   value can be ignored for simple exclusive access to an object, or the value
+   can be used to signal and wait for changes to an object.
+
+   -- Arguments --
+
+   thread *thread;          identifier for launched thread, used by join
+   void probe(void *);      pointer to function &quot;probe&quot;, run when thread starts
+   void *payload;           single argument passed to the probe function
+   lock *lock;              a lock with a value -- used for exclusive access to
+                            an object and to synchronize threads waiting for
+                            changes to an object
+   long val;                value to set lock, increment lock, or wait for
+   int n;                   number of threads joined
+
+   -- Thread functions --
+
+   thread = launch(probe, payload) - launch a thread -- exit via probe() return
+   join(thread) - join a thread and by joining end it, waiting for the thread
+        to exit if it hasn't already -- will free the resources allocated by
+        launch() (don't try to join the same thread more than once)
+   n = join_all() - join all threads launched by launch() that are not joined
+        yet and free the resources allocated by the launches, usually to clean
+        up when the thread processing is done -- join_all() returns an int with
+        the count of the number of threads joined (join_all() should only be
+        called from the main thread, and should only be called after any calls
+        of join() have completed)
+   destruct(thread) - terminate the thread in mid-execution and join it
+        (depending on the implementation, the termination may not be immediate,
+        but may wait for the thread to execute certain thread or file i/o
+        operations)
+
+   -- Lock functions --
+
+   lock = new_lock(val) - create a new lock with initial value val (lock is
+        created in the released state)
+   possess(lock) - acquire exclusive possession of a lock, waiting if necessary
+   twist(lock, [TO | BY], val) - set lock to or increment lock by val, signal
+        all threads waiting on this lock and then release the lock -- must
+        possess the lock before calling (twist releases, so don't do a
+        release() after a twist() on the same lock)
+   wait_for(lock, [TO_BE | NOT_TO_BE | TO_BE_MORE_THAN | TO_BE_LESS_THAN], val)
+        - wait on lock value to be, not to be, be greater than, or be less than
+        val -- must possess the lock before calling, will possess the lock on
+        return but the lock is released while waiting to permit other threads
+        to use twist() to change the value and signal the change (so make sure
+        that the object is in a usable state when waiting)
+   release(lock) - release a possessed lock (do not try to release a lock that
+        the current thread does not possess)
+   val = peek_lock(lock) - return the value of the lock (assumes that lock is
+        already possessed, no possess or release is done by peek_lock())
+   free_lock(lock) - free the resources allocated by new_lock() (application
+        must assure that the lock is released before calling free_lock())
+
+   -- Memory allocation ---
+
+   yarn_mem(better_malloc, better_free) - set the memory allocation and free
+        routines for use by the yarn routines where the supplied routines have
+        the same interface and operation as malloc() and free(), and may be
+        provided in order to supply thread-safe memory allocation routines or
+        for any other reason -- by default malloc() and free() will be used
+
+   -- Error control --
+
+   yarn_name - a char pointer to a string that will be the prefix for any error
+        messages that these routines generate before exiting -- if not changed
+        by the application, &quot;yarn&quot; will be used
+   yarn_abort - an external function that will be executed when there is an
+        internal yarn error, due to out of memory or misuse -- this function
+        may exit to abort the application, or if it returns, the yarn error
+        handler will exit (set to NULL by default for no action)
+ */
+
+extern char *yarn_prefix;
+extern void (*yarn_abort)(int);
+
+void yarn_mem(void *(*)(size_t), void (*)(void *));
+
+typedef struct thread_s thread;
+thread *launch(void (*)(void *), void *);
+void join(thread *);
+int join_all(void);
+void destruct(thread *);
+
+typedef struct lock_s lock;
+lock *new_lock(long);
+void possess(lock *);
+void release(lock *);
+enum twist_op { TO, BY };
+void twist(lock *, enum twist_op, long);
+enum wait_op {
+    TO_BE, /* or */ NOT_TO_BE, /* that is the question */
+    TO_BE_MORE_THAN, TO_BE_LESS_THAN };
+void wait_for(lock *, enum wait_op, long);
+long peek_lock(lock *);
+void free_lock(lock *);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000910.html">[Kiwi-devel] r1803 - kiwi-head/modules
</A></li>
	<LI>Next message: <A HREF="000912.html">[Kiwi-devel] r1805 - in kiwi-head: modules rpm	system/boot/ix86/oemboot
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#911">[ date ]</a>
              <a href="thread.html#911">[ thread ]</a>
              <a href="subject.html#911">[ subject ]</a>
              <a href="author.html#911">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
