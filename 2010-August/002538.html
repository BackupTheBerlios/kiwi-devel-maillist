<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 586bf95c469f464433a8f65c9028f518dd768854
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20586bf95c469f464433a8f65c9028f518dd768854&In-Reply-To=%3C20100810082355.6370E4802F3%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002537.html">
   <LINK REL="Next"  HREF="002539.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 586bf95c469f464433a8f65c9028f518dd768854</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20586bf95c469f464433a8f65c9028f518dd768854&In-Reply-To=%3C20100810082355.6370E4802F3%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 586bf95c469f464433a8f65c9028f518dd768854">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Tue Aug 10 10:23:55 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002537.html">[Kiwi-devel] 0001-Link-for-new-openSUSE-KIWI-Portal-page.patch
</A></li>
        <LI>Next message: <A HREF="002539.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 414b91624380743e835592ddf3951857e4d6b366
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2538">[ date ]</a>
              <a href="thread.html#2538">[ thread ]</a>
              <a href="subject.html#2538">[ subject ]</a>
              <a href="author.html#2538">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  586bf95c469f464433a8f65c9028f518dd768854 (commit)
      from  f29f0bda7b38115bb8667ed5c95276ce40f9ad87 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 586bf95c469f464433a8f65c9028f518dd768854
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Tue Aug 10 10:21:48 2010 +0200

    - update documentation and man pages. some formal and
      consistency changes over the entire document

-----------------------------------------------------------------------

Summary of changes:
diff --git a/doc/LaTex/appendix.tex b/doc/LaTex/appendix.tex
index 8da707b..5827691 100644
--- a/doc/LaTex/appendix.tex
+++ b/doc/LaTex/appendix.tex
@@ -3,8 +3,8 @@
 \label{chapter:Appendix}
 \minitoc
 
-The following pages will show you the man page of kiwi and the
-functions which can be used within config.sh and index.sh
+The following pages will show you the man page of KIWI and the
+functions which can be used within \cmd{config.sh} and \cmd{index.sh}
 
 \begin{itemize}
   \item{man kiwi}
diff --git a/doc/LaTex/appliance.tex b/doc/LaTex/appliance.tex
index 1c3117c..1cc7579 100644
--- a/doc/LaTex/appliance.tex
+++ b/doc/LaTex/appliance.tex
@@ -13,7 +13,7 @@ the operating system. An e-mail server was just an e-mail application
 running on top of Linux, Unix, Microsoft Windows, or some other operating
 system, on a computer that was not designed specifically for that application.
 
-\section{The KIWI model}
+\section{The KIWI Model}
 With KIWI we started to use a different model. Instead of installing
 firewall software on top of a general purpose computer/operating system,
 the designers/engineers built images that are designed specifically for
@@ -99,7 +99,7 @@ and can be adapted to special needs and environments.
             \end{Command}
 
             Add those packages which are labeled with ($+$) to the
-            \textbf{&lt;packages type=&quot;image&quot;&gt;} section of your \path{config.xml}
+            \xmlstarttag{packages \xmlattrval{type}{image}} section of your \path{config.xml}
             file and remove those packages which has been removed ($-$)
             appropriately. If there are packages which has been removed
             against the will of the package manager make sure you address
diff --git a/doc/LaTex/ec2.tex b/doc/LaTex/ec2.tex
index 1f9d200..fb1c8de 100644
--- a/doc/LaTex/ec2.tex
+++ b/doc/LaTex/ec2.tex
@@ -1,5 +1,5 @@
 \index{KIWI images!ec2|(}
-\chapter{EC2 image - Amazon Elastic Compute Cloud}
+\chapter{EC2 Image---Amazon Elastic Compute Cloud}
 \label{chapter:ec2}
 \minitoc
 
@@ -10,8 +10,8 @@ environment. To use Amazon EC2 you simply:
 \begin{enumerate}
 \item Create an Amazon Machine Image (AMI) containing all your software,
       including your operating system and associated configuration settings,
-      applications, libraries, etc. Such an AMI can be created by the kiwi
-      ec2 image format. In order to do that kiwi makes use of the tools
+      applications, libraries, etc. Such an AMI can be created by the KIWI
+      ec2 image format. In order to do that KIWI makes use of the tools
       provided by Amazon. Your build system should have these tools
       installed. Due to license issues we are not allowed to distribute
       the tools which means you need to download, install and setup
@@ -30,17 +30,17 @@ environment. To use Amazon EC2 you simply:
 
 Please note while instances are running, you are billed for the
 computing and network resources that they consume.
-You should start creating an ec2 with kiwi after you can make sure
+You should start creating an ec2 with KIWI after you can make sure
 your system is prepared for ec2 which means if you call the command
-\textbf{ec2-describe-images -a} you will get a valid output.
+\cmd{ec2-describe-images -a} you will get a valid output.
 
-\section{Building the suse-xen-guest example for EC2}
+\section{Building the suse-xen-guest Example for EC2}
 
-One example provided with kiwi is based on openSUSE 11.3 and
+One example provided with KIWI is based on openSUSE 11.3 and
 includes the base pattern plus the vim editor.
 
-Before you run kiwi you need to include some of your ec2 account
-information into the image description config.xml file. The box
+Before you run KIWI you need to include some of your ec2 account
+information into the image description \path{config.xml} file. The box
 below shows the values you need to adapt:
 
 \begin{Command}{13cm}
@@ -53,7 +53,7 @@ below shows the values you need to adapt:
 \end{verbatim}
 \end{Command}
 
-After that call kiwi as follows:
+After that call KIWI as follows:
 
 \begin{Command}{13cm}
 \begin{verbatim}
@@ -73,7 +73,7 @@ kiwi --create /tmp/myec2 \
 \end{verbatim}
 \end{Command}
 
-\section{Using the image}
+\section{Using the Image}
 The generated image needs to be transfered over to Amazon which is
 done by the ec2-upload-bundle tool. You can do this by calling:
 
@@ -87,7 +87,7 @@ ec2-upload-bundle -b myImages \
 \end{Command}
 
 After this is done the image needs to be registered in order to
-receive a so called AMI id which starts with \textbf{ami-} followed
+receive a so called AMI id which starts with \path{ami-} followed
 by a random key sequence. To register call:
 
 \begin{Command}{13cm}
@@ -116,9 +116,9 @@ ec2-add-keypair gsg-keypair
 
 The private key returned needs to be saved in a local file so that
 you can use it later. Using your favorite text editor, create a file
-named \textbf{id\_rsa-gsg-keypair} and paste everything between
-(and including) the \textit{-----BEGIN RSA PRIVATE KEY-----} and
-\textit{-----END RSA PRIVATE KEY-----} lines into it. To review
+named \path{id_rsa-gsg-keypair} and paste everything between
+(and including) the \texttt{-{}-{}-{}-{}-BEGIN RSA PRIVATE KEY-{}-{}-{}-{}-} and
+\texttt{-{}-{}-{}-{}-END RSA PRIVATE KEY-{}-{}-{}-{}-} lines into it. To review
 your keypairs call:
 
 \begin{Command}{10cm}
diff --git a/doc/LaTex/intro.tex b/doc/LaTex/intro.tex
index d6b3a75..ac84b2d 100644
--- a/doc/LaTex/intro.tex
+++ b/doc/LaTex/intro.tex
@@ -4,10 +4,10 @@ The openSUSE KIWI Image System provides a complete operating system
 image solution for Linux supported hardware platforms as well as
 for virtualisation systems like Xen, VMWare, etc. The KIWI architecture
 was designed as a two level system. The first stage, based on a valid
-\textbf{software package source}, creates a so called \textbf{unpacked image}
+\emph{software package source}, creates a so called \emph{unpacked image}
 according to the provided image description. The second stage creates from
 a required unpacked image an operating system image. The result of the
-second stage is called a \textbf{packed image} or short an image.
+second stage is called a \emph{packed image} or short an image.
 
 \begin{figure}[h]
 \centering
@@ -21,7 +21,7 @@ it is important to understand what an operating system image is all about.
 A normal installation process is starting from a given installation source
 and installs single pieces of software until the system is complete. During
 this process there may be manual user intervention required. However an
-operating system image represents an already completed \textit{installation}
+operating system image represents an already completed \emph{installation}
 encapsulated as a file and optionally includes the configuration for a
 specific task. Such an operating system starts working as soon as the
 image has been brought to a system storage device no matter if this is a
@@ -29,7 +29,7 @@ volatile or non volatile storage. The process of creating an image takes
 place without user interaction.
 This means all requirements of the encapsulated system has to be fulfilled
 before the image is created. All of this information is stored in the
-\textbf{image description}.
+\emph{image description}.
 
 %% toms: Insert some terms and their definitions to make it clearer for
 %% our readers. As a side effect, the documentation will be more consistent.
diff --git a/doc/LaTex/iso.tex b/doc/LaTex/iso.tex
index fabd582..a11bb9d 100644
--- a/doc/LaTex/iso.tex
+++ b/doc/LaTex/iso.tex
@@ -12,7 +12,7 @@ like on any other system. All write actions takes place in RAM space
 and therefore all changes will be lost as soon as the computer shuts
 down.
 
-\section{Building the suse-live-iso example}
+\section{Building the suse-live-iso Example}
 
 The latest example provided with kiwi is based on openSUSE 11.2 and
 includes the base + kde patterns.
@@ -33,7 +33,7 @@ kiwi --create /tmp/myiso \
 \end{verbatim}
 \end{Command}
 
-\section{Using the image}
+\section{Using the Image}
 
 There are two ways to use the generated ISO image:
 \begin{itemize}
@@ -68,22 +68,23 @@ attribute in config.xml exists to be able to have the following
 alternative solutions:
 
 \begin{itemize}
-\item \textbf{flags=''unified''}\\
+\item \xmlattrval{flags}{unified}\\
       Compressed and unified root tree as explained above
-\item \textbf{flags=''compressed''}\\
+\item \xmlattrval{flags}{compressed}\\
       Does filesystem compression with squashfs but don't use an
       overlay filesystem for write support. A symbolic link list is used
-      instead and thus a split element is required in config.xml.
+      instead and thus a split element is required in \path{config.xml}.
       See the Split mode section below for details.
-\item \textbf{flags=''clic''}\\
+\item \xmlattrval{flags}{clic}\\
       Creates a fuse based clicfs image and allows write operations
       into a cow file. In case of an ISO the write happens into a
       ramdisk.
-\item \textbf{flags not set}\\
+\item {Flags Not Set}\\
       If no flags attribute is set no compressed filesystem and no overlay
       filesystem will be used. The root tree will be directly part of
-      the ISO filesystem and the paths: /bin, /boot, /lib, /lib64, /opt,
-      /sbin and /usr will be read-only.
+      the ISO filesystem and the paths: \path{/bin}, \path{/boot}, 
+      \path{/lib}, \path{/lib64}, \path{/opt},
+      \path{/sbin}, and \path{/usr} will be read-only.
 \end{itemize}
 
 \subsection{Split mode}
@@ -91,9 +92,9 @@ alternative solutions:
 If no overlay filesystem is in use but the image filesystem is based on
 a compressed filesystem KIWI allows to setup which files and directories
 should be writable in a so called split section. In order to allow to
-login into the system at least the /var directory should be writable
+login into the system at least the \path{/var} directory should be writable
 because the PAM authentification requires to be able to report any login
-attempt to /var/log/messages which therefore needs to be writable. The
+attempt to \path{/var/log/messages} which therefore needs to be writable. The
 following split section can be used if the flag compressed
 is used:  
 
diff --git a/doc/LaTex/kiwi.tex b/doc/LaTex/kiwi.tex
index 9e6b349..6b377eb 100644
--- a/doc/LaTex/kiwi.tex
+++ b/doc/LaTex/kiwi.tex
@@ -85,7 +85,7 @@ hyperindex=true]{hyperref}
 % An option for a (Shell) command, like --help
 \newcommand{\option}[1]{\texttt{--{}--#1}}
 
-% A quotation 
+% An inline quotation 
 \newcommand{\kquote}[1]{``#1''}
 
 %%
diff --git a/doc/LaTex/maintenance.tex b/doc/LaTex/maintenance.tex
index 34206a7..6149dfd 100644
--- a/doc/LaTex/maintenance.tex
+++ b/doc/LaTex/maintenance.tex
@@ -7,8 +7,8 @@ Creating an image often results in an appliance solution for a
 customer and gives you the freedom of a working solution at that
 time. But software develops and you don't want your solution to
 become outdated. Because of this together with an image people always
-should think of \textbf{image-maintenance}. The following paragraph
-just reflects ideas how to maintain images created by kiwi:
+should think of \emph{image-maintenance}. The following paragraph
+just reflects ideas how to maintain images created by KIWI:
 
 \begin{figure}[h]
 \centering
@@ -22,10 +22,10 @@ image to become updated. The first reason for updating an image
 are changes to the software, for example a new kernel should be
 used. If this change doesn't require additional software or changes
 in the configuration the update can be done by kiwi itself using
-its \textbf{upgrade} option. In combination with \textbf{upgrade}
-kiwi allows to add an additional repository which may be needed if
+its \option{upgrade} option. In combination with \option{upgrade}
+KIWI allows to add an additional repository which may be needed if
 the updated software is not part of the original repository. An
-important thing to know is that this additional repository is \textbf{not}
+important thing to know is that this additional repository is \emph{not}
 stored into the original config.xml file of the image description.
 
 Another reason for updating an image beside software updates are
diff --git a/doc/LaTex/migrate.tex b/doc/LaTex/migrate.tex
index 1fb4b45..ede5d9e 100644
--- a/doc/LaTex/migrate.tex
+++ b/doc/LaTex/migrate.tex
@@ -26,7 +26,7 @@ information and would copy it as overlay files as part of the image
 description. The process will skip all remote mounted filesystems
 and concentrate only on local filesystems.
 
-\section{Create a clean repository set first}
+\section{Create a Clean Repository Set First}
 When starting with the migration it is useful to let kiwi know about all
 the repositories from which packages has been installed to 
 the system. In a first step call:
@@ -57,7 +57,7 @@ kiwi --migrate mySystem --nofiles \
 \end{verbatim}
 \end{Command}
 
-\section{Watch the overlay and unpackaged files}
+\section{Watch the Overlay and Unpackaged Files}
 Files which has been modified but belong to a package will be
 automatically copied into the overlay directory below
 \path{/tmp/mySystem/root}. You should check that no modified file
@@ -84,24 +84,24 @@ to be copied over to the \path{/tmp/mySystem/root} directory
 After that you should walk through the following check list
 
 \begin{itemize}
-\item change author and contact in \path{config.xml}
-\item set appropriate name for your image in \path{config.xml}
-\item add/modify default type (oem) set in \path{config.xml} if needed
-\item make sure your X11 configuration is appropriate according to
+\item Change author and contact in \path{config.xml}
+\item Set appropriate name for your image in \path{config.xml}
+\item Add/modify default type (oem) set in \path{config.xml} if needed
+\item Make sure your X11 configuration is appropriate according to
       the new target. A failsafe version was created in
       \path{/tmp/mysys/root/etc/X11/xorg.conf.install} -&gt; fbdev based
-\item make sure \cmd{yast2} is installed to be able to reconfigure
+\item Make sure \cmd{yast2} is installed to be able to reconfigure
       the system. if \cmd{yast2} is not installed these tasks needs to
       be done else. Otherwise yast's second stage is started on first
       boot of the migrated image
-\item if you want to access any remote filesystem it's a good
+\item If you want to access any remote filesystem it's a good
       idea to let autoyast add them on first boot of the system
-\item check your network setup in \path{/etc/sysconfig/network}. Is this
+\item Check your network setup in \path{/etc/sysconfig/network}. Is this
       setup still possible in the cloned environment? Make sure you
       check for the MAC address of the card first.
 \end{itemize}
 
-\section{Turn my system into an image\ldots}
+\section{Turn my System Into an Image\ldots}
 After the process has finished you should check the size of the
 image description. The description itself shouldn't be that big.
 The size of a migrated image description mainly depends on how many
@@ -123,5 +123,5 @@ kiwi --create /tmp/mySys -d /tmp/myResult
 If everything worked well you can test the created OEM
 image in any full virtual operating system environment like QEMU or
 VMware. Once created the image description can serve for all image
-types kiwi supports.
+types KIWI supports.
  
diff --git a/doc/LaTex/oem.tex b/doc/LaTex/oem.tex
index b083501..2a9a869 100644
--- a/doc/LaTex/oem.tex
+++ b/doc/LaTex/oem.tex
@@ -1,5 +1,5 @@
 \index{KIWI images!oem|(}
-\chapter{OEM image - Preload Systems}
+\chapter{OEM Image---Preload Systems}
 \label{chapter:oem}
 \minitoc
 
@@ -15,13 +15,13 @@ Windows as long as a tool to dump data onto a disk device exists and is
 used. The oem image type may also be used to deploy an image on a USB stick. 
 A USB stick is simply a removable physical storage device.
 
-\section{Building the suse-oem-preload example}
+\section{Building the suse-oem-preload Example}
 
 The OEM example provided with kiwi is based on recent openSUSE releases, 
 one example configuration per release, and includes the default and x11 
 patterns. The image type is a split type utilizing the distributions default
 filesystem format for the read-write partition and the squashfs filesystem 
-for the read-only partition. Using the additional \textbf{installiso} attribute 
+for the read-only partition. Using the additional \xmlattr{installiso} attribute 
 creates an installable ISO image. When booting from the ISO image the
 OEM disk image will be deployed to the storage media on the booting machine
 (after confirmation by the user).
@@ -45,13 +45,13 @@ kiwi --create /tmp/myoem --type split \
 \end{verbatim}
 \end{Command}
 
-\section{Using the image}
+\section{Using the Image}
 
-The virtual disk image created by kiwi with the commands shown above can be 
+The virtual disk image created by KIWI with the commands shown above can be 
 tested using virtualization software such as QEMU, VMware, or VirtualBox. 
-The virtual disk is represented by the file with the .raw extension, whereas 
+The virtual disk is represented by the file with the \path{.raw} extension, whereas 
 the file with the .iso extension represents the installation disk for this oem
-image. The ISO image is bootable \textit{(filename.iso)} and can be burned to 
+image. The ISO image is bootable \path{(filename.iso)} and can be burned to 
 optical media. It is recommended to test the image on a bare test system. The 
 following command shows how to use qemu to test the oem disk image 
 \textit{(filename.raw)}.
@@ -64,7 +64,7 @@ qemu suse-11.2-oem-preload.i686-1.1.2.raw \
 \end{verbatim}
 \end{Command}
 
-or using the \textbf{dd} command you can dump the image onto a test hard 
+or using the \cmd{dd} command you can dump the image onto a test hard 
 disk or USB stick and upon reboot select the appropriate device as the 
 boot device in the BIOS:
 
@@ -83,7 +83,7 @@ re-partitioning performed for a physical disk install during the oem boot
 workflow will be skipped.
 
 You can test the installation procedure in a virtual environment using
-the .iso file. In this case the re-partitioning code in the boot image will
+the \path{.iso} file. In this case the re-partitioning code in the boot image will
 be executed. The following commnads show this procedure using QEMU.
 
 \begin{Command}{12cm}
@@ -98,7 +98,7 @@ qemu -hda /tmp/mydisk -cdrom \
 
 \section{Flavors}
 
-As indicated above the use of the \textbf{installiso} and \textbf{installstick}
+As indicated above the use of the \xmlattr{installiso} and \xmlattr{installstick}
  attributes for the oem image supports the creation of an installation image.
 The installation image can be created in two formats, one suitable for
 CD/DVD media and a second suitable for a USB stick. The self installing
@@ -106,21 +106,21 @@ image deploys the oem image onto the selected storage device. The
 installation process is a simple image dump using the dd command. During
 this process the target system
 remains in terminal mode. The following configuration snippets show the 
-use of the \textbf{installiso} and \textbf{installstick} attributes
+use of the \xmlattr{installiso} and \xmlattr{installstick} attributes
 to create the ISO or USB installation image format respectively.
 
 \begin{itemize}
-\item &lt;type image=&quot;name&quot; ... installiso=''true''/&gt;\\
-      Creates a .iso file which can be burned in CD or DVD. This
+\item \xmlemptytag{type \xmlattrval{image}{name} ... \xmlattrval{installiso}{true}}\\
+      Creates a \path{.iso} file which can be burned in CD or DVD. This
       represents an installation CD
-\item &lt;type image=&quot;name&quot; ... installstick=''true''/&gt;\\
-      Creates a .raw.install file which can be dumped (dd) on a
+\item \xmlemptytag{type \xmlattrval{image}{name} ... \xmlattrval{installstick}{true}}\\
+      Creates a \path{.raw.install} file which can be dumped (dd) on a
       USB stick. This represents an installation Stick
 \end{itemize}
 
-\subsection{Influencing the oem partitioning}
+\subsection{Influencing the OEM Partitioning}
 
-By default the oemboot process will create/modify a swap, /home and /
+By default the oemboot process will create/modify a swap, \path{/home} and \path{/}
 partition. It is possible to influence the behavior with the
 oem-* elements. See the \textit{KIWI image description} chapter for details.
 
@@ -150,7 +150,7 @@ oem-* elements. See the \textit{KIWI image description} chapter for details.
 %\end{verbatim}
 %\end{enumerate}
 
-\subsection{LVM support}
+\subsection{LVM Support}
 
 KIWI also provides support for LVM (Logical Volume Management). In this
 mode the disk partition table will include one lvm partition and one
@@ -164,8 +164,8 @@ has full control over the volume group and is free to change
 been added for all disk based image types. This includes the vmx, oem and
 usb image types. In order to use LVM for the oem type just add the 
 \verb+--lvm+ command line option when executing the create step or add
-the attribute \textbf{lvm=''true''} to of the \textbf{type} 
-element in your config.xml file.
+the attribute \xmlattrval{lvm}{true} to of the \xmlelement{type} 
+element in your \path{config.xml} file.
 
 \begin{Command}{12cm}
 \begin{verbatim}
@@ -178,17 +178,17 @@ With the optional \textbf{lvmvolumes} section you can specify to have
 one or more top level directories in a separate volume. See the
 \textit{KIWI image description} chapter for a detailed explanation.
 
-\subsection{Partition based installation}
+\subsection{Partition Based Installation}
 
 The default installation method of an OEM is dumping the entire
 virtual disk on the selected target disk and repartition the disk
 to the real geometry. This works but will also wipe everything which
 was on the disk before. KIWI also supports the installation into
 already existing partitions. This means the user can setup a disk
-with free partitions for the kiwi OEM installation process. This
+with free partitions for the KIWI OEM installation process. This
 way already existing data will not be touched. In order to activate
 the partition based install mode the following oem option has to
-be set in config.xml:
+be set in \path{config.xml}:
 
 \begin{Command}{14cm}
 \begin{verbatim}
@@ -209,7 +209,7 @@ should be mentioned:
       has to loop mount the disk image in order to access the partitions
       which can't be done remotely
 \item The raw disk image is stored uncompressed on the install media.
-      This is because kiwi needs to loop mount the disk image which it can't
+      This is because KIWI needs to loop mount the disk image which it can't
       do if the file is only available as compressed version. This means
       the install media in this mode will be approximately double the size
       of a standard install media
diff --git a/doc/LaTex/pxe.tex b/doc/LaTex/pxe.tex
index 7853985..4a3b70c 100644
--- a/doc/LaTex/pxe.tex
+++ b/doc/LaTex/pxe.tex
@@ -1,29 +1,29 @@
 \index{KIWI images!pxe|(}
-\chapter{PXE image - Thin Clients}
+\chapter{PXE Image---Thin Clients}
 \label{chapter:pxe}
 \minitoc
 
-A pxe image consists of a boot image and a system image like all other
- image types too. But with a pxe image the image files are available
+A PXE image consists of a boot image and a system image like all other
+image types too. But with a PXE image the image files are available
 seperately and needs to be copied at specific locations of a network
 boot server. PXE is a boot protocol implemented in most BIOS implementations
 which makes it so interesting. The protocol sends DHCP requests to assign
 an IP address and after that it uses tftp to download kernel and boot
 instructions. 
 
-\section{Setting up the required services}
+\section{Setting Up the Required Services}
 
 Before you start to build pxe images with kiwi you
 should have setup the boot server. The boot server requires the
-services \textbf{atftp} and \textbf{DHCP} to run
+services atftp and DHCP to run
 
-\subsection{atftp server}
+\subsection{Atftp Server}
 
 In order to setup the atftp server the following steps are required
 
 \begin{enumerate}
 \item install the packages atftp and kiwi-pxeboot
-\item edit the file /etc/sysconfig/atftpd and set/modify the following
+\item edit the file \path{/etc/sysconfig/atftpd} and set/modify the following
       variables:
       \begin{itemize}
       \item ATFTPD\_OPTIONS=''\option{daemon} \option{no-multicast}''
@@ -33,7 +33,7 @@ In order to setup the atftp server the following steps are required
       \textbf{rcatftpd start}
 \end{enumerate}
 
-\subsection{DHCP server}
+\subsection{DHCP Server}
 
 In contrast to the atftp server setup the following DHCP server setup
 can only serve as an example. Please note that according to your network
@@ -45,7 +45,7 @@ The following steps describe how to setup a new DHCP server instance:
 
 \begin{enumerate}
 \item install the package dhcp-server
-\item create the file /etc/dhcpd.conf and include the following
+\item create the file \path{/etc/dhcpd.conf} and include the following
       statements:
  
       \begin{verbatim}
@@ -66,16 +66,16 @@ subnet 192.168.100.0 netmask 255.255.255.0 {
 }
 \end{verbatim}
 
-\item edit the file /etc/sysconfig/dhcpd and setup the network
+\item edit the file \path{/etc/sysconfig/dhcpd} and setup the network
       interface the server should listen on:
       \begin{itemize}
       \item DHCPD\_INTERFACE=''eth0''
       \end{itemize}
 \item run the dhcp server by calling:
-      \textbf{rcdhcpd start}
+      \cmd{rcdhcpd start}
 \end{enumerate}
 
-\section{Building the suse-pxe-client example}
+\section{Building the suse-pxe-client Example}
 
 The example provided with kiwi is based on openSUSE 11.2 and creates an
 image for a Wyse VX0 terminal with a 128MB flash card and 512MB of RAM.
@@ -98,7 +98,7 @@ kiwi --create /tmp/mypxe --type pxe \
 \end{verbatim}
 \end{Command}
 
-\section{Using the image}
+\section{Using the Image}
 
 In order to make use of the image all related image parts needs 
 to be copied onto the boot server. According to the example the following
@@ -137,7 +137,7 @@ cp suse-11.2-pxe-client.i686-1.2.8.config \
       loaded and which kernel parameters are set. When installing
       the kiwi-pxeboot package a default configuration is added.
       To make sure the configuration is valid according to this
-      example the file /srv/tftpboot/pxelinux.cfg/default should
+      example the file \path{/srv/tftpboot/pxelinux.cfg/default} should
       provide the following information:
 \begin{verbatim}
 DEFAULT KIWI-Boot
@@ -156,14 +156,14 @@ LABEL Local-Boot
 \section{Flavours}
 
 All the different PXE boot based deployment methods are controlled
-by the config.&lt;MAC&gt; (or config.default) file. When a new client
+by the \path{config.&lt;MAC&gt;} (or \path{config.default}) file. When a new client
 boots up and there is no client configuration file the new client
 is registered by uploading a control file to the tftp server.
 The following sections informs about the control and the configuration
 file.
 
 \index{configuration files!hwtype.&lt;MAC Address&gt;|(}
-\subsection{The pxe client Control File}
+\subsection{The PXE Client Control File}
 \label{section:cntrlhw}
 This section describes the netboot client control file:
 
@@ -175,10 +175,10 @@ The control file is primarily used to set up new netboot clients. In this
 case, there is no configuration file corresponding to the client
 MAC address available. Using the MAC address information, the control file
 is created, which is uploaded to the TFTP servers upload directory
-\textit{/var/lib/tftpboot/upload}.
+\path{/var/lib/tftpboot/upload}.
 
 \index{configuration files!config.&lt;MAC Address&gt;|(}
-\subsection{The pxe client Configuration File}
+\subsection{The PXE Client Configuration File}
 \label{section:confmac}
 This section describes the netboot client configuration file:
 
@@ -188,7 +188,7 @@ This section describes the netboot client configuration file:
 
 The configuration file contains data about image, configuration,
 synchronization, or partition parameters. The configuration file is
-loaded from the TFTP server directory \textit{/var/lib/tftpboot/KIWI} via TFTP
+loaded from the TFTP server directory \path{/var/lib/tftpboot/KIWI} via TFTP
 for previously installed netboot clients. New netboot clients are
 immediately registered and a new configuration file with the
 corresponding MAC address is created. The standard case for the
@@ -204,6 +204,7 @@ IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;1.2.8;192.168.100.2;4096
 
 The following format is used:
 
+%% toms: Hmn, underline. Better stay way from it
 \begin{Command}{14cm}
     \textbf{IMAGE}=\underline{device;name;version;srvip;bsize;compressed},...,\\
     \textbf{CONF}=\underline{src;dest;srvip;bsize},...,
@@ -216,14 +217,14 @@ The following format is used:
     \item \textbf{IMAGE}\\
         Specifies which image (name) should be loaded with which
         version (version) and to which storage device (device) it
-        should be linked, e.g., \textbf{/dev/ram1} or
-        \textbf{/dev/hda2}. The netboot client partition (device)
-        \textbf{hda2} defines the root file system &quot;/&quot; and \texttt{hda1}
+        should be linked, e.g., \path{/dev/ram1} or
+        \path{/dev/hda2}. The netboot client partition (device)
+        \path{hda2} defines the root file system \path{/} and \path{hda1}
         is used for the swap partition. The numbering of the hard disk
         device should not be confused with the RAM disk device,
-        where \texttt{/dev/ram0} is used for the initial RAM disk and
+        where \path{/dev/ram0} is used for the initial RAM disk and
         can not be used as storage device for the second stage system image.
-        SUSE recommends to use the device \texttt{/dev/ram1} for the
+        SUSE recommends to use the device \path{/dev/ram1} for the
         RAM disk. If the hard drive is used, a corresponding partitioning
         must be performed.
         \begin{itemize}
@@ -244,9 +245,9 @@ The following format is used:
         The download will fail if you specify &quot;'compressed&quot;' and the image isn't
         compressed. It will also fail if you don't specify &quot;'compressed&quot;'
         but the image is compressed. The name of the compressed image has
-        to contain the suffix \textbf{.gz} and needs to be compressed with the
-        \textbf{gzip} tool. Using a compressed image will automatically
-        \textbf{deactivate} the multicast download option of atftp.
+        to contain the suffix \path{.gz} and needs to be compressed with the
+        \cmd{gzip} tool. Using a compressed image will automatically
+        \emph{deactivate} the multicast download option of atftp.
     \end{itemize}
     \item \textbf{CONF}\\
         Specifies a comma-separated list of source:target
@@ -261,7 +262,7 @@ The following format is used:
         Additionally all size specifications supported by the sfdisk
         program are allowed as well. The type number specifies the ID
         of the partition. Valid ID's are listed via the
-        \textit{sfdisk --list-types} command. The mount specifies the
+        \cmd{sfdisk \option{list-types}} command. The mount specifies the
         directory the partition is mounted to.
         \begin{itemize}
             \item The first element of the list must define the swap
@@ -277,7 +278,7 @@ The following format is used:
     \item \textbf{DISK}\\
         Specifies the hard disk. Used only with PART and defines
         the device via which the hard disk can be addressed,
-        e.g., \textbf{/dev/hda}.
+        e.g., \path{/dev/hda}.
     \item \textbf{RELOAD\_IMAGE}\\
         If set to a non-empty string, this forces the configured
         image to be loaded from the server even if the image on
@@ -299,8 +300,8 @@ The following format is used:
         system. The variables value must be set to the name of the
         initrd file which is used via PXE network boot. If the
         standard tftp setup suggested with the kiwi-pxeboot package
-        is used all initrd files resides in the \textbf{boot/} directory
-        below the tftp server path \textit{/var/lib/tftpboot}. Because
+        is used all initrd files resides in the \path{boot/} directory
+        below the tftp server path \path{/var/lib/tftpboot}. Because
         the tftpserver do a chroot into the tftp server path you need
         to specify the initrd file as the following example shows:
         \textbf{KIWI\_INITRD=/boot/&lt;name-of-initrd-file&gt;}
@@ -309,7 +310,7 @@ The following format is used:
         use unionfs or aufs as container filesystem in combination
         with a compressed system image. The recommended compressed
         filesystem type for the system image is \textbf{squashfs}.
-        In case of a usb-stick system the usbboot image will
+        In case of a USB stick system the usbboot image will
         automatically setup the unionfs/aufs filesystem. In case of
         a PXE network image the netboot image requires a config.&lt;MAC&gt;
         setup like the following example shows:
@@ -352,7 +353,7 @@ DISK=/dev/sda
         remote port that uses the nbd-server program. For more information
         on how to set up the server, see the nbd-server man pages. The
         kernel on the remote client can set up a special network block
-        device named /dev/nb0 using the nbd-client command. After this
+        device named \path{/dev/nb0} using the nbd-client command. After this
         device exists, the mount program is used to mount the root
         filesystem. To allow the KIWI boot image to use that, the following
         information must be provided:
@@ -365,8 +366,8 @@ NBDROOT=NBD.Server.IP.address;\
         The NBD-Device, NBD-Swap-Port-Number, NBD-Swap-Device,
         NBD-Write-Port-Number and NBD-Write-Device
         variables are optional. If the nbd root device is not set,
-        the default values (/dev/nb0 , port 2000) applies and if the nbd
-        swap device is not set the default values (/dev/nb1, port 9210)
+        the default values (\path{/dev/nb0} , port 2000) applies and if the nbd
+        swap device is not set the default values (\path{/dev/nb1}, port 9210)
         applies. The swap space over the network using a network block device
         is only established if the client has less than 48 MB of RAM.
         The optional NBD-Write-Port-Number and NBD-Write-Device specifies
@@ -379,10 +380,10 @@ NBDROOT=NBD.Server.IP.address;\
         the system image via the AoE subsystem. The block device
         could be a partition of a real or a virtual disk. In order to
         use the AoE subsystem I recommend to install the \textit{aoetools}
-        and \textit{vblade} packages from here first:\\
+        and \textit{vblade} packages from here first:
         \url{<A HREF="http://download.opensuse.org/repositories/system:/aoetools">http://download.opensuse.org/repositories/system:/aoetools</A>}\\
         Once installed the following example shows how to export
-        the local /dev/sdb1 partition via AoE:
+        the local \path{/dev/sdb1} partition via AoE:
 \begin{verbatim}
 vbladed 0 1 eth0 /dev/sdb1
 \end{verbatim}
@@ -390,11 +391,11 @@ vbladed 0 1 eth0 /dev/sdb1
         by a couple Major/Minor, with major between 0-65535 and minor
         between 0-255. AoE is based just over Ethernet on the OSI models
         so we need to indicate which ethernet card we'll use. 
-        In this example we export /dev/sdb1 with a major value of 0 and
+        In this example we export \path{/dev/sdb1} with a major value of 0 and
         minor of 1 on the eth0 interface. We are ready to use our partition
         on the network! To be able to use the device kiwi needs the
         information which AoE device contains the root filesystem. In
-        our example this is the device \textit{/dev/etherd/e0.1}.
+        our example this is the device \path{/dev/etherd/e0.1}.
         According to this the AOEROOT variable must be set as follows:
 \begin{verbatim}
 AOEROOT=/dev/etherd/e0.1
@@ -433,7 +434,7 @@ UNIONFS_CONFIG=/dev/ram1,nfs,aufs # write to RAM
          The value must be set to the name of the initrd file which is
          used via PXE network boot. If the standard TFTP setup suggested
          with the kiwi-pxeboot package is used, all initrd files reside
-         in the /srv/tftpboot/boot/ directory. Because the TFTP server
+         in the \path{/srv/tftpboot/boot/} directory. Because the TFTP server
          does a chroot into the TFTP server path, you must specify the
          initrd file as follows:
 \begin{verbatim}
@@ -462,7 +463,7 @@ protocol. With PXE the download protocol is fixed and thus you
 can't change the way how the kernel and the boot image (initrd)
 is downloaded. As soon as linux takes over control the following
 download protocols http, https and ftp are supported too.
-KIWI makes use of the \textbf{curl} program to support the
+KIWI makes use of the \cmd{curl} program to support the
 additional protocols.
 
 In order to select one of the additional download protocols
@@ -477,8 +478,8 @@ the following kernel parameters needs to be setup:
 \end{itemize}
 
 To setup this parameters edit the file
-\textbf{/srv/tftpboot/pxelinux.cfg/default} on your PXE boot server
-and change the \textbf{append} line accordingly. Please note all
+\path{/srv/tftpboot/pxelinux.cfg/default} on your PXE boot server
+and change the \texttt{append} line accordingly. Please note all
 downloads except for kernel and initrd are now controlled by the given
 server and protocol. You need to make sure that this server provides
 the same directory and file structure as initially provided by
@@ -493,9 +494,9 @@ available for the operating system after the image has been
 deployed into RAM. Below, find an example:
 
 \begin{itemize}
-\item use a read-write filesystem in config.xml, for example\\
+\item Use a read-write filesystem in \path{config.xml}, for example\\
       \textbf{filesystem=''ext3''}
-\item sample config.&lt;MAC&gt;
+\item Create \path{config.&lt;MAC&gt;}
 
 \begin{Command}{12cm}
 \begin{verbatim}
@@ -505,7 +506,7 @@ IMAGE=/dev/ram1;suse-11.2-pxe-client.i686;\
 \end{Command}
 \end{itemize}
 
-\subsection{union image}
+\subsection{Union Image}
 
 As used in the suse-pxe-client example it is possible to make use of the
 aufs or unionfs overlay filesystems to combine two filesystems
@@ -528,7 +529,7 @@ KIWI_INITRD=/boot/initrd
 \end{verbatim}
 \end{Command}
 
-\subsection{split image}
+\subsection{Split Image}
 
 As an alternative to the UNIONFS\_CONFIG method it is also
 possible to create a split image and combine the two portions
@@ -578,7 +579,7 @@ KIWI_INITRD=/boot/initrd
 \end{Command}
 \end{itemize}
 
-\subsection{root tree over NFS}
+\subsection{Root Tree Over NFS}
 
 Instead of installing the image onto a local storage device of
 the client it is also possible to let the client mount the root
@@ -595,7 +596,7 @@ NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot
 \end{Command}
 \end{itemize}
 
-\subsection{root tree over NBD}
+\subsection{Root Tree Over NBD}
 
 As an alternative for root over NFS it is also possible to
 let the client mount the root tree via a special network block
@@ -612,7 +613,7 @@ NBDROOT=192.168.100.7;2000;/dev/nbd0
 \end{Command}
 \end{itemize}
 
-\subsection{root tree over AoE}
+\subsection{Root Tree Over AoE}
 
 As an alternative for root over NBD it is also possible to
 let the client mount the root device via a special ATA over
@@ -632,7 +633,7 @@ AOEROOT=/dev/etherd/e0.1
 \end{Command}
 
       This would require the command
-      \textbf{''vbladed 0 1 eth0 blockdevice''}
+      \cmd{vbladed 0 1 eth0 blockdevice}
       to be called first
 \end{itemize}
 
diff --git a/doc/LaTex/source.tex b/doc/LaTex/source.tex
index 124dcdf..d0d97c3 100644
--- a/doc/LaTex/source.tex
+++ b/doc/LaTex/source.tex
@@ -11,10 +11,10 @@ installation source. It depends on your network bandwidth how fast
 an image creation process is and in almost all cases it is better
 to prepare a local installation source first.
 
-\section{Adapt the example's config.xml}
+\section{Adapt the Example's config.xml}
 If you can make
 sure you have a local installation source it's important to change
-the path attribute inside of the &lt;repository&gt; element of the
+the path attribute inside of the \xmlelement{repository} element of the
 appropriate example to point to your local source directory.
 A typically default repository element looks like the following:
 
@@ -25,12 +25,12 @@ A typically default repository element looks like the following:
 &lt;/repository&gt;
 \end{verbatim}
 
-\section{Create a local installation source}
+\section{Create a Local Installation Source}
 The following describes how to create a local SUSE installation
 source which is stored below the path: \path{/images/CDs}
 If you are using the local path as described in this docuement
 you only need to flip the given path information inside of
-the example config.xml file.
+the example \path{config.xml} file.
 
 \begin{enumerate}
 \item find your SUSE standard installation CDs or the DVD and
@@ -48,8 +48,8 @@ mount -o loop /dev/&lt;drive-device-name&gt; /mnt
 \end{Command}
 
 \item You don't have a DVD but a CD set ? No problem all you need to
-      do is copy the contents of \textbf{all} CDs into one directory. It's
-      absolutly important that you first start with the \textbf{last} CD and
+      do is copy the contents of \emph{all} CDs into one directory. It's
+      absolutly important that you first start with the \emph{last} CD and
       copy the first CD at last. In case of CDs you should have a
       bundly of 4 CDs. Copy them in the order 4 3 2 1
 
diff --git a/doc/LaTex/testing.tex b/doc/LaTex/testing.tex
index d237c99..ae2175b 100644
--- a/doc/LaTex/testing.tex
+++ b/doc/LaTex/testing.tex
@@ -1,11 +1,11 @@
 \index{KIWI images!testing|(}
-\chapter{KIWI testsuite}
+\chapter{KIWI Testsuite}
 \label{chapter:testing}
 \minitoc
 
 The KIWI test suite is useful to perform basic quality checks on
 the image root directory. The test cases are stored in subdirectories
-below /usr/share/kiwi/tests. To run the testsuite call kiwi as
+below \path{/usr/share/kiwi/tests}. To run the testsuite call KIWI as
 follows:
 
 \begin{Command}{12cm}
@@ -17,10 +17,10 @@ If not test names are set the default tests rpm and ldd run.
 The name of a test corresponds with the name of the directory
 the test is implemented in.
 
-\section{testsuite packages}
+\section{Testsuite Packages}
 If a test requires special software to be installed but this
 software is not an essential part of the image itself it can be
-specified as testsuite packages in the system image config.xml
+specified as testsuite packages in the system image \path{config.xml}
 as follows:
 
 \begin{Command}{12cm}
@@ -29,13 +29,13 @@ as follows:
 &lt;/packages&gt;
 \end{Command}
 
-The testsuite packages are installed when calling kiwi with
+The testsuite packages are installed when calling KIWI with
 the testsuite option and are removed after the tests has
 finished.
 
-\section{Creating a test}
-The test itself is defined by a xml description ''test-case.xml''
-and its template definition file /usr/share/kiwi/modules/KIWISchemaTest.rnc
+\section{Creating a Test}
+The test itself is defined by a xml description \path{test-case.xml}
+and its template definition file \path{/usr/share/kiwi/modules/KIWISchemaTest.rnc}
 The following example shows the basic structure of the rpm test:
 
 \begin{verbatim}
@@ -57,7 +57,7 @@ The following example shows the basic structure of the rpm test:
 &lt;/test_case&gt;
 \end{verbatim}
 
-There are basically two sections called ''equirements'' and ''test''.
+There are basically two sections called \xmlelement{equirements} and \xmlelement{test}.
 In requirements you define what files/directories or packages has to be
 present in your image to run the test. For example if you need to check
 the rpm database, the database has to be present within the image.
@@ -84,7 +84,7 @@ There are two types of scripts, extern and intern.
       Their first parameter should be CHROOT. This parameter
       is changed to the real path of the image chroot directory.
 
-\item internal scripts are executed inside image using the ''chroot'' command.
+\item internal scripts are executed inside image using the \cmd{chroot} command.
       Files are copied into the image and deleted after execution.
 \end{itemize}
 
diff --git a/doc/LaTex/usb.tex b/doc/LaTex/usb.tex
index 4ea5ea8..d8525a6 100644
--- a/doc/LaTex/usb.tex
+++ b/doc/LaTex/usb.tex
@@ -10,9 +10,9 @@ you plug the stick in supports booting from USB stick. Almost all
 new BIOS systems support that. The USB stick serves as OS system disk
 in this case and you can read and write data onto it.
 
-\section{Building the suse-live-stick example}
+\section{Building the suse-live-stick Example}
 
-The latest example provided with kiwi is based on openSUSE 11.2 and makes use
+The latest example provided with KIWI is based on openSUSE 11.2 and makes use
 of the default plus x11 pattern. The operating system is stored on a
 standard ext3 filesystem. 
 
@@ -26,7 +26,7 @@ kiwi --prepare ./suse-live-stick \
 \end{Command}
 
 There are two possible image types which allows you to drive the
-stick. Both are added into the config.xml of this example image
+stick. Both are added into the \path{config.xml} of this example image
 description. If you already have access to the stick you want to
 run the image on the first approach should be preferred over the
 second one.
@@ -45,7 +45,7 @@ kiwi --create /tmp/mystick --type usb \
 
 \item The second image type named ''oem'' allows you to create a
       virtual disk which represents a virtual disk geometry including
-      all partitions and boot information in one file. You simply can ''dd''
+      all partitions and boot information in one file. You simply can \cmd{dd}
       this file on the stick.
 
       \begin{Command}{12cm}
@@ -79,8 +79,8 @@ kiwi --bootstick \
 
 In case of the second image type (oem) you only need a tool which allows
 you to dump data onto a device. On Linux the most popular tool to do this
-is the \textbf{dd} command. The oem image is represented by the file
-with the .raw extension. As said this is a virtual disk which already
+is the \cmd{dd} command. The oem image is represented by the file
+with the \path{.raw} extension. As said this is a virtual disk which already
 includes partition information. But this partition information does
 not match the real USB stick geometry which means the kiwi boot image
 (oemboot) has to adapt the disk geometry on first boot. To deploy the
@@ -107,23 +107,23 @@ from USB stick you should test the stick on real hardware
 
 USB sticks weren't designed to serve as storage devices for
 operating systems. By design of these nice little gadgets their
-storage capacity is limited to only a few G-bytes. According to
+storage capacity is limited to only a few gigabytes. According to
 this KIWI supports compressed filesystems with USB sticks too:  
 
 \begin{itemize}
-\item \textbf{filesystem=''squashfs''}\\
+\item \xmlattrval{filesystem}{squashfs}\\
       This will compress the image using the squashfs filesystem. The
       boot process will automatically use aufs as overlay filesystem to
       mount the complete tree read-write. For the write part an additional
       ext2 partition will be created on the stick. The support for this
       compression layer requires squashfs and aufs to be present in
       the distribution KIWI has used to build the image 
-\item \textbf{filesystem=''clicfs''}\\
+\item \xmlattrval{filesystem}{clicfs}\\
       Creates a fuse based clicfs image and allows write operations
       into a cow file.
 \end{itemize}
 
-\subsection{Split stick}
+\subsection{Split Stick}
 If there is no overlay filesystem available it is also possible to
 define a split section in config.xml and use the split support to
 split the image into a compressed read-only and a read-write portion.
@@ -150,7 +150,7 @@ To create a split stick the types needs to be adapted as follows:
 
 For both types a split section inside the type section is required
 which defines the read-write data. A good starting point is
-to set /var, /home and /etc as writable data.
+to set \path{/var}, \path{/home}, and \path{/etc} as writable data.
 
 \begin{Command}{12cm}
 \begin{verbatim}
@@ -169,23 +169,23 @@ to set /var, /home and /etc as writable data.
 \end{Command}
 
 If no split section is added the default split section from
-/usr/share/kiwi/modules/KIWISplit.txt is used
+\path{/usr/share/kiwi/modules/KIWISplit.txt} is used
 
-\subsection{LVM support}
+\subsection{LVM Support}
 
 kiwi also provides support for LVM (Logical Volume Management). In this
 mode the disk partition table will include one lvm partition and one
-standard ext2 boot partition. kiwi creates the kiwiVG volume group and
+standard ext2 boot partition. KIWI creates the kiwiVG volume group and
 adds logical volumes as they are needed and configured according to the
 image type and filesystem. After boot of the system the user has full
 control over the volume group and is free to change/resize/increas the
 group and the volumes inside. Support for LVM has been added for all
 image types which are disk based. This includes vmx,oem and usb.
-In order to use LVM for the usb type just add the \verb+--lvm+ option
-as part of the kiwi \verb+kiwi --bootstick+ deployment or add the
-attribute \textbf{lvm=''true''} as part of the \textbf{type} section
-in your config.xml file.
+In order to use LVM for the usb type just add the \option{lvm} option
+as part of the kiwi \cmd{kiwi \option{bootstick}} deployment or add the
+attribute \xmlattrval{lvm}{true} as part of the \xmlelement{type} section
+in your \path{config.xml} file.
 
-The optional \textbf{lvmvolumes} section can be used to set one or
+The optional \xmlelement{lvmvolumes} section can be used to set one or
 more top level directories into a separate volume. See the
 \textit{KIWI image description} chapter for a detailed explanation.
diff --git a/doc/LaTex/vmx.tex b/doc/LaTex/vmx.tex
index 688f4aa..3135f1d 100644
--- a/doc/LaTex/vmx.tex
+++ b/doc/LaTex/vmx.tex
@@ -5,13 +5,13 @@
 
 A VMX image is a virtual disk image for use in full virtualisation
 systems like QEMU or VMware. The image is a file containing the
-system represented by the configured packages in config.xml as well
+system represented by the configured packages in \path{config.xml} as well
 as partition data and bootloader information. The size of
-this virtual disk can be specified by using the &lt;size&gt; element
-in the config.xml file or by adding the \option{bootvm-disksize} command
+this virtual disk can be specified by using the \xmlstarttag{size} element
+in the \path{config.xml} file or by adding the \option{bootvm-disksize} command
 line argument.
 
-\section{Building the suse-vm-guest example}
+\section{Building the suse-vm-guest Example}
 
 The vm-guest example provided with kiwi is based on recent openSUSE releases,
 one example configuration per release. The example uses base pattern and the
@@ -50,7 +50,7 @@ qemu suse-11.2-vm-guest.i686-1.1.2.raw -m 256
 
 \section{Flavours}
 
-KIWI always generates a file in the .raw format. The .raw file is a disk
+KIWI always generates a file in the .raw format. The \path{.raw} file is a disk
 image with a structure equivalent to the structure of a physical hard disk. 
 Individual virtualization systems have specific formats to facilitate
 improved I/O performance to the virtual disk, represented by the image file,
@@ -83,10 +83,10 @@ includes information about the hardware to be represented to the guest
 image by the VMware virtualization environment as well as specification
 of resources such as memory. 
 
-Within the config.xml file it is possible to specify the VMware configuration
+Within the \path{config.xml} file it is possible to specify the VMware configuration
 settings. In addition it is possible to include selected packages in the 
 created image that are specific to the VM image generation. The following
-config.xml snippet provides general guidance on the elements in config.xml.
+config.xml snippet provides general guidance on the elements in \path{config.xml}.
 
 \begin{Command}{13cm}
 \begin{verbatim}
@@ -104,11 +104,11 @@ config.xml snippet provides general guidance on the elements in config.xml.
 Given the specification above KIWI will create a VMware guest
 configuration specifying the availability of 512 MB of RAM and an IDE 
 disk controller interface for the VM guest. For aditional information
-about the configuration settings please refere to the 
-\textbf{machine} section. 
+about the configuration settings please refer to the 
+\textit{machine} section. 
 
 The guest configuration can be loaded through VMware user interface and 
-may be modified through the GUI. The configuration file has the .vmx 
+may be modified through the GUI. The configuration file has the \path{.vmx} 
 extension as shown in the example below.
 
 \begin{Command}{13cm}
@@ -117,18 +117,18 @@ extension as shown in the example below.
 \end{verbatim}
 \end{Command}
 
-Using the \textbf{format=''vmdk''} attribute of the &lt;type&gt; element
-will create the VMware formated disk image (.vmdk file) and the required 
-VMware guest configuration (.vmx) file.
+Using the \xmlattrval{format}{vmdk} attribute of the \xmlstarttag{type} start tag
+will create the VMware formated disk image (\path{.vmdk} file) and the required 
+VMware guest configuration (\path{.vmx}) file.
 
 In addition it is possible to create an image for the Xen virtualization 
-framework.  By adding the \textbf{bootprofile} and \textbf{bootkernel} 
-attributes to the &lt;type&gt; element with values of 'xen' and 'xenboot', 
+framework.  By adding the \xmlattr{bootprofile} and \xmlattr{bootkernel} 
+attributes to the \xmlstarttag{type} start tag with values of \xmlval{xen} and
+\xmlval{xenboot}, 
 respectively. Please refer to the \ref{chapter:xen} (Xen image) chapter 
 for additional details.
 
-\subsection{LVM support}
-
+\subsection{LVM Support}
 KIWI also provides support for LVM (Logical Volume Management). In this
 mode the disk partition table will include one lvm partition and one
 standard ext2 boot partition. KIWI creates the kiwiVG volume group and
@@ -136,10 +136,10 @@ adds logical volumes as they are needed and configured according to the
 image type and filesystem. After boot of the system the user has full
 control over the volume group and is free to change/resize/increas the
 group and the volumes inside. Support for LVM has been added for all
-image types which are disk based. This includes vmx,oem and usb.
-In order to use LVM for the vmx type just add the \verb+--lvm+ option
-as part of the KIWI create step or add the attribute \textbf{lvm=''true''}
-as part of the \textbf{type} section in your config.xml file.
+image types which are disk based. This includes vmx, oem and usb.
+In order to use LVM for the vmx type just add the \option{lvm} option
+as part of the KIWI create step or add the attribute \xmlattrval{lvm}{true}
+as part of the \xmlelement{type} section in your \path{config.xml} file.
 
 \begin{Command}{12cm}
 \begin{verbatim}
@@ -148,6 +148,6 @@ kiwi --create /tmp/myvm --type vmx \
 \end{verbatim}
 \end{Command}
 
-With the optional \textbf{lvmvolumes} section you can set one or
+With the optional \xmlelement{lvmvolumes} section you can set one or
 more top level directories into a separate volume. See the
 \textit{KIWI image description} chapter for a detailed explanation.
diff --git a/doc/LaTex/xen.tex b/doc/LaTex/xen.tex
index 7380aca..113ed94 100644
--- a/doc/LaTex/xen.tex
+++ b/doc/LaTex/xen.tex
@@ -12,10 +12,10 @@ most privileged layer.%[1] %% &lt;-- Should this be a reference?
 Above this layer are one or more guest
 operating systems, which the hypervisor schedules across the physical
 CPUs. The first guest operating system, called in Xen terminology
-&quot;domain 0&quot; (dom0), is booted automatically when the hypervisor boots
+\kquote{domain 0} (dom0), is booted automatically when the hypervisor boots
 and given special management privileges and direct access to the physical
 hardware. The system administrator logs into dom0 in order to start
-any further guest operating systems, called &quot;domain U&quot; (domU) in
+any further guest operating systems, called \kquote{domain U} (domU) in
 Xen terminology.
 
 A xen image is a virtual disk like a vmx but with the xen kernel
@@ -25,7 +25,7 @@ Xen versions. Xen extracts the kernel and initrd from the virtual
 disk as well as the grub configuration and displays the menu which
 allows emulation of the grub console
 
-\section{Building the suse-xen-guest example}
+\section{Building the suse-xen-guest Example}
 
 The latest example provided with kiwi is based on openSUSE 11.3 and includes
 the base pattern. 
@@ -46,9 +46,9 @@ kiwi --create /tmp/myxen \
 \end{verbatim}
 \end{Command}
 
-\section{Using the image}
+\section{Using the Image}
 
-In order to run a domain U the Xen tool \textbf{xm} needs to be called
+In order to run a domain U the Xen tool \cmd{xm} needs to be called
 in conjunction with the KIWI genereated domain U configuration file
 
 \begin{Command}{13cm}
@@ -80,9 +80,9 @@ need in this para virtual environment with a profile.
 \end{Command}
 
 If this information is present KIWI will create a Xen domain U
-configuration with 512 MB of RAM and expects the disk at /dev/xvda.
+configuration with 512 MB of RAM and expects the disk at \path{/dev/xvda}.
 Additional information to setup the Xen guest machine properties are
-explained in the \textbf{machine} section. The KIWI Xen domain U
+explained in the \texttt{machine} section. The KIWI Xen domain U
 configuration is stored in the file:
 
 \begin{Command}{13cm}
diff --git a/doc/kiwi-man/KIWI::config.sh.1 b/doc/kiwi-man/KIWI::config.sh.1
index 40b8631..e7cf4ed 100644
--- a/doc/kiwi-man/KIWI::config.sh.1
+++ b/doc/kiwi-man/KIWI::config.sh.1
@@ -1,12 +1,12 @@
 .\&quot;     Title: kiwi::config.sh
 .\&quot;    Author: Marcus Sch&#195;&#164;fer &lt;ms (AT) suse.de&gt;
 .\&quot; Generator: DocBook XSL Stylesheets v1.74.0 &lt;<A HREF="http://docbook.sf.net/">http://docbook.sf.net/</A>&gt;
-.\&quot;      Date: Created: 08/09/2010
+.\&quot;      Date: Created: 08/10/2010
 .\&quot;    Manual: KIWI Manualpage
 .\&quot;    Source: KIWI 4.55
 .\&quot;  Language: English
 .\&quot;
-.TH &quot;KIWI::CONFIG\&amp;.SH&quot; &quot;1&quot; &quot;Created: 08/09/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
+.TH &quot;KIWI::CONFIG\&amp;.SH&quot; &quot;1&quot; &quot;Created: 08/10/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
 .\&quot; -----------------------------------------------------------------
 .\&quot; * (re)Define some macros
 .\&quot; -----------------------------------------------------------------
diff --git a/doc/kiwi-man/KIWI::images.sh.1 b/doc/kiwi-man/KIWI::images.sh.1
index c4148c7..2ea52a6 100644
--- a/doc/kiwi-man/KIWI::images.sh.1
+++ b/doc/kiwi-man/KIWI::images.sh.1
@@ -1,12 +1,12 @@
 .\&quot;     Title: kiwi::images.sh
 .\&quot;    Author: Marcus Sch&#195;&#164;fer &lt;ms (AT) suse.de&gt;
 .\&quot; Generator: DocBook XSL Stylesheets v1.74.0 &lt;<A HREF="http://docbook.sf.net/">http://docbook.sf.net/</A>&gt;
-.\&quot;      Date: Created: 08/09/2010
+.\&quot;      Date: Created: 08/10/2010
 .\&quot;    Manual: KIWI Manualpage
 .\&quot;    Source: KIWI 4.55
 .\&quot;  Language: English
 .\&quot;
-.TH &quot;KIWI::IMAGES\&amp;.SH&quot; &quot;1&quot; &quot;Created: 08/09/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
+.TH &quot;KIWI::IMAGES\&amp;.SH&quot; &quot;1&quot; &quot;Created: 08/10/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
 .\&quot; -----------------------------------------------------------------
 .\&quot; * (re)Define some macros
 .\&quot; -----------------------------------------------------------------
diff --git a/doc/kiwi-man/KIWI::kiwirc.1 b/doc/kiwi-man/KIWI::kiwirc.1
index 6c9933f..1d1d720 100644
--- a/doc/kiwi-man/KIWI::kiwirc.1
+++ b/doc/kiwi-man/KIWI::kiwirc.1
@@ -1,12 +1,12 @@
 .\&quot;     Title: kiwi::kiwirc
 .\&quot;    Author: Robert Schweikert &lt;rschweikert (AT) novell.com&gt;
 .\&quot; Generator: DocBook XSL Stylesheets v1.74.0 &lt;<A HREF="http://docbook.sf.net/">http://docbook.sf.net/</A>&gt;
-.\&quot;      Date: Created: 08/09/2010
+.\&quot;      Date: Created: 08/10/2010
 .\&quot;    Manual: KIWI Manualpage
 .\&quot;    Source: &gt;KIWI 4.55
 .\&quot;  Language: English
 .\&quot;
-.TH &quot;KIWI::KIWIRC&quot; &quot;1&quot; &quot;Created: 08/09/2010&quot; &quot;&gt;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
+.TH &quot;KIWI::KIWIRC&quot; &quot;1&quot; &quot;Created: 08/10/2010&quot; &quot;&gt;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
 .\&quot; -----------------------------------------------------------------
 .\&quot; * (re)Define some macros
 .\&quot; -----------------------------------------------------------------
diff --git a/doc/kiwi-man/kiwi-man.xml b/doc/kiwi-man/kiwi-man.xml
index f499c96..bcbc6ad 100644
--- a/doc/kiwi-man/kiwi-man.xml
+++ b/doc/kiwi-man/kiwi-man.xml
@@ -818,7 +818,7 @@
     &lt;para&gt;More information about KIWI, its files can be found at:&lt;/para&gt;
     &lt;variablelist&gt;
       &lt;varlistentry&gt;
-        &lt;term&gt;&lt;ulink url=&quot;<A HREF="http://en.opensuse.org/Build_Service/KIWI/Cookbook">http://en.opensuse.org/Build_Service/KIWI/Cookbook</A>&quot;/&gt;&lt;/term&gt;
+        &lt;term&gt;&lt;ulink url=&quot;<A HREF="http://en.opensuse.org/Portal:KIWI">http://en.opensuse.org/Portal:KIWI</A>&quot;/&gt;&lt;/term&gt;
         &lt;listitem&gt;
           &lt;para&gt;KIWI wiki&lt;/para&gt;
         &lt;/listitem&gt;
diff --git a/doc/kiwi-man/kiwi.1 b/doc/kiwi-man/kiwi.1
index 8209e39..d546b17 100644
--- a/doc/kiwi-man/kiwi.1
+++ b/doc/kiwi-man/kiwi.1
@@ -1,12 +1,12 @@
 .\&quot;     Title: kiwi
 .\&quot;    Author: Marcus Schaefer &lt;ms (AT) suse.de&gt;
 .\&quot; Generator: DocBook XSL Stylesheets v1.74.0 &lt;<A HREF="http://docbook.sf.net/">http://docbook.sf.net/</A>&gt;
-.\&quot;      Date: Created: 08/09/2010
+.\&quot;      Date: Created: 08/10/2010
 .\&quot;    Manual: KIWI Manualpage
 .\&quot;    Source: KIWI 4.55
 .\&quot;  Language: English
 .\&quot;
-.TH &quot;KIWI&quot; &quot;1&quot; &quot;Created: 08/09/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
+.TH &quot;KIWI&quot; &quot;1&quot; &quot;Created: 08/10/2010&quot; &quot;KIWI 4\&amp;.55&quot; &quot;KIWI Manualpage&quot;
 .\&quot; -----------------------------------------------------------------
 .\&quot; * (re)Define some macros
 .\&quot; -----------------------------------------------------------------
@@ -535,7 +535,7 @@ Activates check for matching kernels between boot and system image\&amp;. The kernel
 .PP
 More information about KIWI, its files can be found at:
 .PP
-\m[blue]\fB\%<A HREF="http://en.opensuse.org/Build_Service/KIWI/Cookbook\fR\m[">http://en.opensuse.org/Build_Service/KIWI/Cookbook\fR\m[</A>]
+\m[blue]\fB\%<A HREF="http://en.opensuse.org/Portal:KIWI\fR\m[">http://en.opensuse.org/Portal:KIWI\fR\m[</A>]
 .RS 4
 KIWI wiki
 .RE
diff --git a/doc/kiwi.pdf b/doc/kiwi.pdf
index fa66ae6..282c9aa 100644
Binary files a/doc/kiwi.pdf and b/doc/kiwi.pdf differ


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002537.html">[Kiwi-devel] 0001-Link-for-new-openSUSE-KIWI-Portal-page.patch
</A></li>
	<LI>Next message: <A HREF="002539.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 414b91624380743e835592ddf3951857e4d6b366
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2538">[ date ]</a>
              <a href="thread.html#2538">[ thread ]</a>
              <a href="subject.html#2538">[ subject ]</a>
              <a href="author.html#2538">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
