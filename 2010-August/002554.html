<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 4784945f8e4baf8557ad8bba07de258e8fb38803
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%204784945f8e4baf8557ad8bba07de258e8fb38803&In-Reply-To=%3C20100817122855.8E7F7480CA9%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002553.html">
   <LINK REL="Next"  HREF="002555.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 4784945f8e4baf8557ad8bba07de258e8fb38803</H1>
    <B>marcus_schaefer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%204784945f8e4baf8557ad8bba07de258e8fb38803&In-Reply-To=%3C20100817122855.8E7F7480CA9%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 4784945f8e4baf8557ad8bba07de258e8fb38803">marcus_schaefer at mail.berlios.de
       </A><BR>
    <I>Tue Aug 17 14:28:55 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002553.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. b2acc89cf611fb2df8450097f53e40c811fb483a
</A></li>
        <LI>Next message: <A HREF="002555.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 85d885db2b8596e5fecbf55f188a5baf4ecdf8e6
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2554">[ date ]</a>
              <a href="thread.html#2554">[ thread ]</a>
              <a href="subject.html#2554">[ subject ]</a>
              <a href="author.html#2554">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  4784945f8e4baf8557ad8bba07de258e8fb38803 (commit)
      from  b2acc89cf611fb2df8450097f53e40c811fb483a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4784945f8e4baf8557ad8bba07de258e8fb38803
Author: Marcus Sch&#195;&#164;fer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at novell.com</A>&gt;
Date:   Tue Aug 17 14:28:06 2010 +0200

    - update documentation. Better index page

-----------------------------------------------------------------------

Summary of changes:
diff --git a/doc/LaTex/appendix.tex b/doc/LaTex/appendix.tex
index 8bda8c3..369d1d2 100644
--- a/doc/LaTex/appendix.tex
+++ b/doc/LaTex/appendix.tex
@@ -1,4 +1,5 @@
 \chapter{Appendix---KIWI man pages}
+\index{man pages}
 \label{chapter:Appendix}
 \minitoc
 
diff --git a/doc/LaTex/appliance.tex b/doc/LaTex/appliance.tex
index 17ffa3d..636bc17 100644
--- a/doc/LaTex/appliance.tex
+++ b/doc/LaTex/appliance.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!appliance|(}
 \chapter{Creating Appliances with KIWI}
+\index{KIWI images!appliance|(}
 \label{chapter:appliance}
 \minitoc
 
@@ -29,14 +29,14 @@ and can be adapted to special needs and environments.
       build an image for
 \item Allow the image to create an in-place git repository to
       allow tracking of non binary changes. This is done by adding
-      the following into your \cmd{config.sh} script
+      the following into your \cmd{config.sh}\index{scripts!config.sh} script.
 
 \begin{verbatim}
 baseSetupPlainTextGITRepository
 \end{verbatim}
 
 \item Prepare the preliminary version of your new appliance by
-      calling \cmd{kiwi \option{prepare} ...} and refer to chapter \ref{chapter:usb}
+      calling \cmd{kiwi} \option{prepare}\ldots\ and refer to chapter \ref{chapter:usb}
       (USB image - Live-Stick System) for details.
 \item Decide for a testing environment. In my opinion a real
       hardware based test machine which allows to boot from USB
@@ -48,10 +48,10 @@ baseSetupPlainTextGITRepository
 \end{xml}
 
 \item Create the preliminary live stick image of your new appliance
-      by calling \cmd{kiwi\linebreak[3] \option{create} ...}. After successful creation
+      by calling \cmd{kiwi}\linebreak[3] \option{create}\ldots After successful creation
       of the image files find an USB stick which is able to store
       your appliance and plug it into a free USB port on your image
-      build machine. Use the \cmd{kiwi \option{bootstick} ...} call to deploy
+      build machine. Use the \cmd{kiwi} \option{bootstick}\ldots call to deploy
       the image on the stick. Refer to chapter \ref{chapter:usb}
       (USB image - Live-Stick System) for details.
 \item Plug in the stick on your test machine and boot it.
@@ -70,7 +70,8 @@ rpm -qa | sort &gt; /tmp/deployPackages
       \item Check the output of the command \cmd{git status} and
             include everything which is unknown to git and surely
             will not be changed by you and will not become part of the
-            image description overlay files to the \path{/.gitignore}
+            image description overlay files to the 
+            \path{/.gitignore}\index{configuration files!.gitignore}
             files
       \end{itemize}
 
@@ -98,11 +99,13 @@ diff -u /tmp/deployPackages /tmp/appliancePackages
 \end{Command}
 
             Add those packages which are labeled with ($+$) to the
-            \xmlstarttag{packages \xmlattrval{type}{image}} section of your \path{config.xml}
+            \xmlstarttag{packages \xmlattrval{type}{image}} section of your 
+            \path{config.xml}\index{configuration files!config.xml}
             file and remove those packages which has been removed ($-$)
             appropriately. If there are packages which has been removed
             against the will of the package manager make sure you address
-            the uninstallation of these packages in your \cmd{config.sh}
+            the uninstallation of these packages in your 
+            \cmd{config.sh}\index{scripts!config.sh}
             script. If you have installed packages from repositories which
             are not part of your \path{config.xml} file you should also add these
             repositories in order to allow kiwi to install the packages
@@ -149,3 +152,5 @@ deactivate the creation of the git repository which will save you
 some space on the filesystem. If this appliance is a server I recommend
 to leave the repository because it allows you to keep track of changes
 during the live time of this appliance.
+
+\index{KIWI images!appliance|)}
diff --git a/doc/LaTex/description.tex b/doc/LaTex/description.tex
index 21f0876..92b44fa 100644
--- a/doc/LaTex/description.tex
+++ b/doc/LaTex/description.tex
@@ -1,12 +1,12 @@
-\index{KIWI images!description|(}
 \chapter{KIWI Image Description}
+\index{KIWI images!description|(}
 \label{chapter:description}
 \minitoc
 
 In order to be able to create an image with KIWI a so called
 image description must be created. The image description is
 represented by a directory which has to contain at least one
-file named \path{config.xml} or alternatively \path{*.kiwi}.
+file named \path{config.xml}\index{configuration files!config.xml} or alternatively \path{*.kiwi}.
 A good start for such a description can be found in the examples
 provided in \path{/usr/share/doc/packages/kiwi/examples}.
 
@@ -22,13 +22,13 @@ of building an image but most often mandatory for the functionality
 of the later operating system.
 
 \begin{itemize}
-\item \path{images.sh}\\
+\item \path{images.sh}\index{scripts!images.sh}\\
       Optional configuration script while creating the packed image.
       This script is called at the beginning of the image creation process.
       It is designed to clean-up the image system. Affected are all the
       programs and files only needed while the unpacked image exists.
 
-\item \path{config.sh}\\
+\item \path{config.sh}\index{scripts!config.sh}\\
       Optional configuration script while creating the unpacked image. This
       script is called at the end of the installation but \emph{before}
       the package scripts have run. It is designed to configure the image
@@ -40,9 +40,9 @@ of the later operating system.
       Subdirectory that contains special files, directories, and scripts for
       adapting the image environment \textbf{after} the installation of all the
       image packages. The entire directory is copied into the root of the
-      image tree using \cmd{cp -a}.
+      image tree using \cmd{cp} \soption{a}.
 
-\item \path{config-yast-firstboot.xml}\\
+\item \path{config-yast-firstboot.xml}\index{configuration files!config-yast-firstboot.xml}\\
       Configuration file for the control of the yast2 firstboot service.
       Similar to the autoyast approach yast also provides a boot time
       service called firstboot. Unfortunately there is no GUI available
@@ -70,7 +70,7 @@ yast2 autoyast
 \end{Command}
 
       Once you have saved the information from the autoyast UI as
-      config-yast-autoyast.xml file in your image description directory KIWI
+      \path{config-yast-autoyast.xml} file in your image description directory KIWI
       will process on the file and setup your image as follows:
       \begin{enumerate}
       \item While booting the image YaST is started in autoyast mode
@@ -82,13 +82,13 @@ yast2 autoyast
             cleaned and autoyast won't be called at next reboot.
       \end{enumerate}
 
-\item \path{config-cdroot.tgz}\\
+\item \path{config-cdroot.tgz}\index{configuration files!config-cdroot.tgz}\\
       Archive which is used for ISO images only. The data in the archive is
       uncompressed and stored in the CD/DVD root directory. This
       archive can be used, for example, to integrate a license file or
       readme information directly readable from the CD or DVD.
 
-\item \path{config-cdroot.sh}\\
+\item \path{config-cdroot.sh}\index{scripts!config-cdroot.sh}\\
       Along with the \path{config-cdroot.tgz} one can provide a script which allows
       to manipulate the extracted data.
 
@@ -101,6 +101,7 @@ yast2 autoyast
 \end{itemize}
 
 \section{The config.xml File}
+\index{configuration files!config.xml}
 The mandatory image definition file is divided into different sections
 which describes information like the image name and type as well as
 the packages and patterns the image should consist of.
@@ -142,7 +143,7 @@ The following optional attributes can be inserted in the \xmlstarttag{image} tag
       a working image from this description. If the KIWI SVN
       revision is less than the specified value, the
       process will exit. The currently used SVN revision can
-      be queried by calling \cmd{kiwi \option{version}}.
+      be queried by calling \cmd{kiwi} \option{version}.
 
 \item \xmlattr{id}\\
       sets an identification
@@ -485,7 +486,7 @@ supported child elements:
 	\path{/} partition. It is possible to influence the behavior by the
 	\xmlelement{oem-*} elements explained below.
 	KIWI uses this information to create the file
-	\path{/config.oempartition} as part
+	\path{/config.oempartition}\index{configuration files!config.oempartition} as part
 	of the automatically created oemboot boot image. The format of the
 	file is a simple key=value format and created by the \cmd{KIWIConfig.sh}
 	function named baseSetupOEMPartition(). 
@@ -525,7 +526,8 @@ supported child elements:
 	\item \xmlstarttag{oem-recovery}true|false\xmlendtag{oem-recovery}\\
       If this element is set to true (default value is \xmlval{false}), KIWI will
       create a recovery archivefrom the prepared root tree. The archive will 
-      appear as \path{/recovery.tar.bz2} in the image file. During 
+      appear as \path{/recovery.tar.bz2}\index{configuration files!recovery.tar.bz2}
+      in the image file. During 
       first boot of the image a single recovery partition will be
       created and the recovery archive will be moved to the recovery 
       partition. An additional boot menu entry is created that when selected
@@ -536,7 +538,7 @@ supported child elements:
     \item \xmlstarttag{oem-recoveryID}partition-id\xmlendtag{oem-recoveryID}\\
       Specify the partition type for the recovery partition. The default 
       is to create a Linux partition (id\,=\,83). This value is represented by 
-      the OEM\_RECOVERY\_ID variable in config.oempartition. 
+      the OEM\_RECOVERY\_ID variable in \path{config.oempartition}.
     \item \xmlstarttag{oem-swap}true|false\xmlendtag{oem-swap}\\
        Specify if a sawp partition should be create. The creation of a swap
        partition is the default behavior. This value is represented by the
@@ -821,7 +823,7 @@ The attributes \xmlattr{home}, \xmlattr{id}, \xmlattr{name}, \xmlattr{pwd},
 users home directory, the user name, the user's password, the user's 
 real name, and the user's login shell, respectively. By default the value
 of the password attribute is expected to be an encrypted string. An
-encrypted password can be created using \cmd{kiwi \option{createpassword}}. It
+encrypted password can be created using \cmd{kiwi} \option{createpassword}. It
 is also possible to specify the password as a non encrypted string by using
 the \xmlattr{pwdformat} attribute and setting it's value to \kquote{plain}. KIWI will then
 encrypt the password prior to the user being added to the system.
@@ -1089,7 +1091,7 @@ ignored it.
 To restrict a package to a specific architecture, use
 the \xmlattr{arch} attribute to specify a comma separated list of allowed
 architectures. Such a package is only installed if the build systems
-architecture (\cmd{uname -m}) matches one of the specified values of the arch
+architecture (\cmd{uname} \soption{m}) matches one of the specified values of the arch
 attribute.
 
 \subsubsection{Image Type Specific Packages}
@@ -1121,7 +1123,8 @@ to be part of the boot image as the data is used at boot time
 of the image. If the bootdelete attribute is specified along with
 the bootinclude attribute this means that the selected package
 will be marked as a \kquote{to become deleted} package and is
-removed by the contents of the \cmd{images.sh} script of the corresponding
+removed by the contents of the 
+\cmd{images.sh}\index{scripts!images.sh} script of the corresponding
 boot image description
 
 \subsubsection{Data not Available as Packages to Become Included}
@@ -1135,3 +1138,4 @@ boot image.
 
 
 
+\index{KIWI images!description|)}
diff --git a/doc/LaTex/ec2.tex b/doc/LaTex/ec2.tex
index a8f8f51..f258a5b 100644
--- a/doc/LaTex/ec2.tex
+++ b/doc/LaTex/ec2.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!ec2|(}
 \chapter{EC2 Image---Amazon Elastic Compute Cloud}
+\index{KIWI images!EC2|(}\index{EC2|see KIWI images, EC2}\index{Cloud|see EC2}
 \label{chapter:ec2}
 \minitoc
 
@@ -8,7 +8,9 @@ with the ability to execute arbitrary applications in our computing
 environment. To use Amazon EC2 you simply:
 
 \begin{enumerate}
-\item Create an Amazon Machine Image (AMI) containing all your software,
+\item Create an Amazon Machine Image (AMI)\index{Amazon Machine Image}%
+      \index{AMI|see Amazon Machine Image}
+      containing all your software,
       including your operating system and associated configuration settings,
       applications, libraries, etc. Such an AMI can be created by the KIWI
       ec2 image format. In order to do that KIWI makes use of the tools
@@ -18,6 +20,7 @@ environment. To use Amazon EC2 you simply:
       them from here:\\
       \url{<A HREF="http://aws.amazon.com/documentation/ec2/">http://aws.amazon.com/documentation/ec2/</A>}
 \item Upload this AMI to the Amazon S3 (Amazon Simple Storage Service)
+      \index{Amazon Simple Storage Service}\index{Amazon S3|see Amazon Simple Storage Service}
       service. This gives us reliable, secure access to your AMI.
 \item Register your AMI with Amazon EC2. This allows us to verify that your
       AMI has been uploaded correctly and to allocate a unique identifier
@@ -32,7 +35,7 @@ Please note while instances are running, you are billed for the
 computing and network resources that they consume.
 You should start creating an ec2 with KIWI after you can make sure
 your system is prepared for ec2 which means if you call the command
-\cmd{ec2-describe-images -a} you will get a valid output.
+\cmd{ec2-describe-images} \soption{a} you will get a valid output.
 
 \section{Building the suse-xen-guest Example for EC2}
 
@@ -88,7 +91,7 @@ ec2-register myImages/\
 \end{Command}
 
 The result is the AMI id which you need to run an instance from
-your image. The command ec2-describe-images allows you to review your
+your image. The command \cmd{ec2-describe-images} allows you to review your
 registered images. Since you will be running an instance of a public AMI,
 you will need to use a public/private keypair to ensure that only you
 will have access. One half of this keypair will be embedded into your
@@ -154,3 +157,6 @@ ec2-authorize default -p 22
 
 Congratulations ! You made it and can now use Amazons storage and
 computing power.
+
+
+\index{KIWI images!EC2|)}
diff --git a/doc/LaTex/iso.tex b/doc/LaTex/iso.tex
index 2e3a039..409c267 100644
--- a/doc/LaTex/iso.tex
+++ b/doc/LaTex/iso.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!iso|(}
 \chapter{ISO Image---Live Systems}
+\index{KIWI images!ISO|(}
 \label{chapter:iso}
 \minitoc
 
@@ -14,8 +14,8 @@ down.
 
 \section{Building the suse-live-iso Example}
 
-The latest example provided with kiwi is based on openSUSE 11.2 and
-includes the base + kde patterns.
+The latest example provided with KIWI is based on openSUSE 11.2 and
+includes the base and KDE patterns.
 
 \begin{Command}{12cm}
 cd /usr/share/doc/packages/kiwi/examples
@@ -29,7 +29,7 @@ kiwi --create /tmp/myiso --type iso -d /tmp/myiso-result
 
 There are two ways to use the generated ISO image:
 \begin{itemize}
-\item Burn the .iso file on a CD or DVD with your preferred burn program.
+\item Burn the \path{.iso} file on a CD or DVD with your preferred burn program.
       Plug in the CD or DVD into a test computer and (re)boot the machine.
       Make sure the computer boot from the CD drive as first boot device.
 \item Use a virtualisation system to test the image directly. Testing an
@@ -59,13 +59,13 @@ alternative solutions:
 \begin{itemize}
 \item \xmlattrval{flags}{unified}\\
       Compressed and unified root tree as explained above
-\item \xmlattrval{flags}{compressed}\\
+\item \xmlattrval{flags}{compressed}\index{filesystem!compression}\\
       Does filesystem compression with squashfs but don't use an
       overlay filesystem for write support. A symbolic link list is used
       instead and thus a split element is required in \path{config.xml}.
       See the Split mode section below for details.
-\item \xmlattrval{flags}{clic}\\
-      Creates a fuse based clicfs image and allows write operations
+\item \xmlattrval{flags}{clic}\index{FUSE}\\
+      Creates a FUSE based clicfs image and allows write operations
       into a cow file. In case of an ISO the write happens into a
       ramdisk.
 \item {Flags Not Set}\\
@@ -101,3 +101,5 @@ is used:
    &lt;/temporary&gt;
 &lt;/split&gt;
 \end{xml}
+
+\index{KIWI images!ISO|)}
diff --git a/doc/LaTex/kiwi.tex b/doc/LaTex/kiwi.tex
index 5a13b50..ef68fd7 100644
--- a/doc/LaTex/kiwi.tex
+++ b/doc/LaTex/kiwi.tex
@@ -115,10 +115,14 @@ basewidth={0.5em,0.45em},captionpos=b,
 \newcommand{\ti}{\symbol{126}}
 
 % A Shell command like df
-\newcommand{\cmd}[1]{\texttt{#1}}
+\newcommand{\cmd}[1]{\texttt{#1}\index{commands!#1}\index{#1}}
 
 % An option for a (Shell) command, like --help
-\newcommand{\option}[1]{\texttt{--{}--#1}}
+\newcommand{\option}[1]{\texttt{--{}--#1}\index{options!--{}--#1}}
+% A single option, like -a
+\newcommand{\soption}[1]{\texttt{--#1}}
+%
+\newcommand{\xoption}[1]{\texttt{#1}}
 
 % An inline quotation 
 \newcommand{\kquote}[1]{``#1''}
diff --git a/doc/LaTex/maintenance.tex b/doc/LaTex/maintenance.tex
index 6149dfd..94c5940 100644
--- a/doc/LaTex/maintenance.tex
+++ b/doc/LaTex/maintenance.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!maintenance|(}
 \chapter{Maintenance of Operating System Images}
+\index{KIWI images!maintenance|(}
 \label{chapter:maintain}
 \minitoc
 
@@ -43,3 +43,5 @@ subversion. All changes can be tracked down then and maybe more
 important can be assigned to product tags and branches. As a consequence
 an image must be prepared from scratch and the old physical extend
 could be removed.
+
+\index{KIWI images!maintenance|)}
diff --git a/doc/LaTex/migrate.tex b/doc/LaTex/migrate.tex
index 45af42c..1c36231 100644
--- a/doc/LaTex/migrate.tex
+++ b/doc/LaTex/migrate.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!migration|(}
 \chapter{System to Image Migration}
+\index{KIWI images!migration|(}
 \label{chapter:migration}
 \minitoc
 
@@ -53,6 +53,7 @@ kiwi --migrate mySystem --nofiles [ --skip package ... ]
 \end{Command}
 
 \section{Watch the Overlay and Unpackaged Files}
+\index{overlay}
 Files which has been modified but belong to a package will be
 automatically copied into the overlay directory below
 \path{/tmp/mySystem/root}. You should check that no modified file
@@ -79,19 +80,23 @@ to be copied over to the \path{/tmp/mySystem/root} directory
 After that you should walk through the following check list
 
 \begin{itemize}
-\item Change author and contact in \path{config.xml}
+\item Change author and contact in \path{config.xml}\index{configuration files!config.xml}
 \item Set appropriate name for your image in \path{config.xml}
 \item Add/modify default type (oem) set in \path{config.xml} if needed
 \item Make sure your X11 configuration is appropriate according to
       the new target. A failsafe version was created in
-      \path{/tmp/mysys/root/etc/X11/xorg.conf.install} -&gt; fbdev based
+      \path{/tmp/mysys/root/etc/X11/xorg.conf.install}%
+      \index{configuration files!xorg.conf.install}
+      -&gt; fbdev based
 \item Make sure \cmd{yast2} is installed to be able to reconfigure
       the system. if \cmd{yast2} is not installed these tasks needs to
       be done else. Otherwise yast's second stage is started on first
       boot of the migrated image
 \item If you want to access any remote filesystem it's a good
       idea to let autoyast add them on first boot of the system
-\item Check your network setup in \path{/etc/sysconfig/network}. Is this
+\item Check your network setup in \path{/etc/sysconfig/network}.
+      \index{network setup}
+      Is this
       setup still possible in the cloned environment? Make sure you
       check for the MAC address of the card first.
 \end{itemize}
@@ -114,7 +119,8 @@ kiwi --create /tmp/mySys -d /tmp/myResult
 \end{Command}
 
 If everything worked well you can test the created OEM
-image in any full virtual operating system environment like QEMU or
+image in any full virtual operating system environment like Qemu\index{Qemu} or
 VMware. Once created the image description can serve for all image
 types KIWI supports.
  
+\index{KIWI images!migration|)}
diff --git a/doc/LaTex/oem.tex b/doc/LaTex/oem.tex
index 6962db7..734a1e8 100644
--- a/doc/LaTex/oem.tex
+++ b/doc/LaTex/oem.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!oem|(}
 \chapter{OEM Image---Preload Systems}
+\index{KIWI images!OEM|(}
 \label{chapter:oem}
 \minitoc
 
@@ -196,3 +196,5 @@ should be mentioned:
       the install media in this mode will be approximately double the size
       of a standard install media
 \end{itemize}
+
+\index{KIWI images!OEM|)}
diff --git a/doc/LaTex/pxe.tex b/doc/LaTex/pxe.tex
index cf8672a..b3424e7 100644
--- a/doc/LaTex/pxe.tex
+++ b/doc/LaTex/pxe.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!pxe|(}
 \chapter{PXE Image---Thin Clients}
+\index{KIWI images!PXE|(}
 \label{chapter:pxe}
 \minitoc
 
@@ -34,7 +34,7 @@ In order to setup the atftp server the following steps are required
 \end{enumerate}
 
 \subsection{DHCP Server}
-
+\index{examples!DHCP server}
 In contrast to the atftp server setup the following DHCP server setup
 can only serve as an example. Please note that according to your network
 structure the IP addresses, ranges and domain settings needs to be adapted
@@ -44,8 +44,8 @@ that the filename and next-server information is provided by your server.
 The following steps describe how to setup a new DHCP server instance:
 
 \begin{enumerate}
-\item install the package dhcp-server
-\item create the file \path{/etc/dhcpd.conf} and include the following
+\item Install the package dhcp-server
+\item Create the file \path{/etc/dhcpd.conf} and include the following
       statements:
  
 \begin{verbatim}
@@ -66,18 +66,18 @@ subnet 192.168.100.0 netmask 255.255.255.0 {
 }
 \end{verbatim}
 
-\item edit the file \path{/etc/sysconfig/dhcpd} and setup the network
+\item Edit the file \path{/etc/sysconfig/dhcpd} and setup the network
       interface the server should listen on:
       \begin{itemize}
       \item DHCPD\_INTERFACE=''eth0''
       \end{itemize}
-\item run the dhcp server by calling:
+\item Run the dhcp server by calling:
       \cmd{rcdhcpd start}
 \end{enumerate}
 
 \section{Building the suse-pxe-client Example}
 
-The example provided with kiwi is based on openSUSE 11.2 and creates an
+The example provided with KIWI is based on openSUSE 11.2 and creates an
 image for a Wyse VX0 terminal with a 128MB flash card and 512MB of RAM.
 The image makes use of the squashfs compressed filesystem and its
 root tree is deployed as unified (aufs) based system. 
@@ -210,7 +210,7 @@ DISK=device
     \item \textbf{IMAGE}\\
         Specifies which image (name) should be loaded with which
         version (version) and to which storage device (device) it
-        should be linked, e.g., \path{/dev/ram1} or
+        should be linked, e.\,g., \path{/dev/ram1} or
         \path{/dev/hda2}. The netboot client partition (device)
         \path{hda2} defines the root file system \path{/} and \path{hda1}
         is used for the swap partition. The numbering of the hard disk
@@ -255,7 +255,7 @@ DISK=device
         Additionally all size specifications supported by the sfdisk
         program are allowed as well. The type number specifies the ID
         of the partition. Valid ID's are listed via the
-        \cmd{sfdisk \option{list-types}} command. The mount specifies the
+        \cmd{sfdisk} \option{list-types} command. The mount specifies the
         directory the partition is mounted to.
         \begin{itemize}
             \item The first element of the list must define the swap
@@ -289,7 +289,7 @@ DISK=device
         image, whereas the first image defines the read-write
         part and the second image defines the read-only part.
     \item \textbf{KIWI\_INITRD}\\
-        Specifies the kiwi initrd to be used for local boot of the
+        Specifies the KIWI initrd to be used for local boot of the
         system. The variables value must be set to the name of the
         initrd file which is used via PXE network boot. If the
         standard tftp setup suggested with the kiwi-pxeboot package
@@ -403,7 +403,8 @@ AOEROOT=/dev/etherd/e0.1,/dev/ram1
         Writing to RAM is the default but you also can set another device
         like another aoe location or a local device for writing the data
     \item \textbf{NFSROOT}\\
-         Mount the system image root filesystem remotely via NFS
+         Mount the system image root filesystem remotely via 
+         NFS\index{NFS (Network File System)}
          (Network File System). This means there is a server which
          exports the root filesystem of the network client in such a
          way that the client can mount it read/write. In order to do
@@ -450,11 +451,11 @@ KIWI_KERNEL=/boot/name-of-kernel-file
 
 \subsection{User another than tftp as download protocol}
 
-By default all downloads controlled by the kiwi linuxrc code
+By default all downloads controlled by the KIWI linuxrc code
 are performed by an atftp call and therefore uses the tftp
 protocol. With PXE the download protocol is fixed and thus you
 can't change the way how the kernel and the boot image (initrd)
-is downloaded. As soon as linux takes over control the following
+is downloaded. As soon as Linux takes over control the following
 download protocols http, https and ftp are supported too.
 KIWI makes use of the \cmd{curl} program to support the
 additional protocols.
@@ -567,7 +568,7 @@ KIWI_INITRD=/boot/initrd
 \end{itemize}
 
 \subsection{Root Tree Over NFS}
-
+\index{NFS (Network File System)}
 Instead of installing the image onto a local storage device of
 the client it is also possible to let the client mount the root
 tree via an NFS remote mount. Below find an example:
@@ -588,7 +589,7 @@ let the client mount the root tree via a special network block
 device. Below find an example:
 
 \begin{itemize}
-\item Use nbd-server to export the kiwi prepared tree
+\item Use nbd-server to export the KIWI prepared tree
 \item sample config.&lt;MAC&gt;
 
 \begin{verbatim}
@@ -614,7 +615,8 @@ AOEROOT=/dev/etherd/e0.1
 \end{verbatim}
 
       This would require the command
-      \cmd{vbladed 0 1 eth0 blockdevice}
+      \cmd{vbladed} \xoption{0 1 eth0 blockdevice}
       to be called first
 \end{itemize}
 
+\index{KIWI images!PXE|)}
diff --git a/doc/LaTex/source.tex b/doc/LaTex/source.tex
index 862bc54..3a8fb10 100644
--- a/doc/LaTex/source.tex
+++ b/doc/LaTex/source.tex
@@ -1,5 +1,5 @@
-\index{KIWI Setup of installation sources!instsourcesetup|(}
 \chapter{Installation Source}
+\index{KIWI Setup of installation sources!instsourcesetup|(}
 \label{chapter:instsourcesetup}
 \minitoc
 
@@ -30,11 +30,11 @@ The following describes how to create a local SUSE installation
 source which is stored below the path: \path{/images/CDs}
 If you are using the local path as described in this docuement
 you only need to flip the given path information inside of
-the example \path{config.xml} file.
+the example \path{config.xml}\index{configuration files!config.xml} file.
 
 \begin{enumerate}
 \item find your SUSE standard installation CDs or the DVD and
-      make them available to the build system. Most linux systems
+      make them available to the build system. Most Linux systems
       auto-mount a previosly inserted media automatically. If this
       is the case you simply can change the directory to the
       auto mounted path below \path{/media}. If your system doesn't mount
@@ -45,14 +45,14 @@ the example \path{config.xml} file.
 mount -o loop /dev/&lt;drive-device-name&gt; /mnt
 \end{Command}
 
-\item You don't have a DVD but a CD set ? No problem all you need to
+\item You don't have a DVD but a CD set? No problem all you need to
       do is copy the contents of \emph{all} CDs into one directory. It's
       absolutly important that you first start with the \emph{last} CD and
       copy the first CD at last. In case of CDs you should have a
       bundly of 4 CDs. Copy them in the order 4 3 2 1
 
 \item Once you have access to the media copy the contents of the
-      CDs / DVD to your hard drive. You need at least 4GB free
+      CDs/DVD to your hard drive. You need at least 4GB free
       space available. The following is intended to create a SUSE
       11.0 installation source:
 
@@ -65,3 +65,5 @@ cp -a /mnt/* /image/CDs/full-11.0-i386/
       after that unplugg the CD and insert the next one to repeat
       the copy command until all CDs are copied into to /image
 \end{enumerate}
+
+\index{KIWI Setup of installation sources!instsourcesetup|)}
diff --git a/doc/LaTex/testing.tex b/doc/LaTex/testing.tex
index e05b3e4..07237f3 100644
--- a/doc/LaTex/testing.tex
+++ b/doc/LaTex/testing.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!testing|(}
 \chapter{KIWI Testsuite}
+\index{KIWI images!testing|(}
 \label{chapter:testing}
 \minitoc
 
@@ -93,3 +93,4 @@ any error occur. All messages printed to standard and error output are stored
 and printed out of the test has failed.
 
 
+\index{KIWI images!testing|)}
diff --git a/doc/LaTex/usb.tex b/doc/LaTex/usb.tex
index dac9d12..8e35613 100644
--- a/doc/LaTex/usb.tex
+++ b/doc/LaTex/usb.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!usb|(}
 \chapter{USB Image---Live-Stick System}
+\index{KIWI images!USB|(}
 \label{chapter:usb}
 \minitoc
 
@@ -23,21 +23,22 @@ kiwi --prepare ./suse-live-stick --root /tmp/mystick
 \end{Command}
 
 There are two possible image types which allows you to drive the
-stick. Both are added into the \path{config.xml} of this example image
+stick. Both are added into the \path{config.xml}%
+\index{configuration files!config.xml} of this example image
 description. If you already have access to the stick you want to
 run the image on the first approach should be preferred over the
 second one.
 
 \begin{itemize}
-\item The first image type named ''usb'' creates all required
+\item The first image type named \xmlval{usb} creates all required
       images for booting the OS but requires you to plug in the stick
-      and let kiwi deploy the data onto this stick.
+      and let KIWI deploy the data onto this stick.
 
 \begin{Command}{12cm}
 kiwi --create /tmp/mystick --type usb d /tmp/mystick-result
 \end{Command}
 
-\item The second image type named ''oem'' allows you to create a
+\item The second image type named \xmlval{oem} allows you to create a
       virtual disk which represents a virtual disk geometry including
       all partitions and boot information in one file. You simply can \cmd{dd}
       this file on the stick.
@@ -50,10 +51,10 @@ kiwi --create /tmp/mystick --type oem -d /tmp/mystick-result
 \section{Using the Image}
 
 To make use of the created images they need to be deployed on the
-USB stick. For the first image type (usb) you need kiwi itself to
+USB stick. For the first image type (usb) you need KIWI itself to
 be able to deploy the image on the stick. The reason for this is
 that the usb image type has created the boot and the system image
-but there is no disk geometry or partition table available. kiwi
+but there is no disk geometry or partition table available. KIWI
 creates a new partition table on the stick and imports the created
 images as follows:
 
@@ -71,7 +72,7 @@ you to dump data onto a device. On Linux the most popular tool to do this
 is the \cmd{dd} command. The oem image is represented by the file
 with the \path{.raw} extension. As said this is a virtual disk which already
 includes partition information. But this partition information does
-not match the real USB stick geometry which means the kiwi boot image
+not match the real USB stick geometry which means the KIWI boot image
 (oemboot) has to adapt the disk geometry on first boot. To deploy the
 image on the stick call:
 
@@ -153,7 +154,7 @@ If no split section is added the default split section from
 \path{/usr/share/kiwi/modules/KIWISplit.txt} is used
 
 \subsection{LVM Support}
-
+\index{LVM}
 kiwi also provides support for LVM (Logical Volume Management). In this
 mode the disk partition table will include one lvm partition and one
 standard ext2 boot partition. KIWI creates the kiwiVG volume group and
@@ -163,10 +164,12 @@ control over the volume group and is free to change/resize/increas the
 group and the volumes inside. Support for LVM has been added for all
 image types which are disk based. This includes vmx,oem and usb.
 In order to use LVM for the usb type just add the \option{lvm} option
-as part of the kiwi \cmd{kiwi \option{bootstick}} deployment or add the
+as part of the kiwi \cmd{kiwi} \option{bootstick} deployment or add the
 attribute \xmlattrval{lvm}{true} as part of the \xmlelement{type} section
 in your \path{config.xml} file.
 
 The optional \xmlelement{lvmvolumes} section can be used to set one or
 more top level directories into a separate volume. See the
 \textit{KIWI image description} chapter for a detailed explanation.
+
+\index{KIWI images!USB|)}
diff --git a/doc/LaTex/vmx.tex b/doc/LaTex/vmx.tex
index 2205c01..c7d9fb2 100644
--- a/doc/LaTex/vmx.tex
+++ b/doc/LaTex/vmx.tex
@@ -1,19 +1,20 @@
-\index{KIWI images!vmx|(}
 \chapter{VMX Image---Virtual Disks}
+\index{KIWI images!vmx|(}
 \label{chapter:vmx}
 \minitoc
 
 A VMX image is a virtual disk image for use in full virtualisation
-systems like QEMU or VMware. The image is a file containing the
-system represented by the configured packages in \path{config.xml} as well
+systems like Qemu\index{Qemu} or VMware.\index{VMware} The image is a file containing the
+system represented by the configured packages in \path{config.xml}%
+\index{configuration files!config.xml} as well
 as partition data and bootloader information. The size of
 this virtual disk can be specified by using the \xmlstarttag{size} element
 in the \path{config.xml} file or by adding the \option{bootvm-disksize} command
 line argument.
 
 \section{Building the suse-vm-guest Example}
-
-The vm-guest example provided with kiwi is based on recent openSUSE releases,
+\index{examples!suse-vm-guest}
+The vm-guest example provided with KIWI is based on recent openSUSE releases,
 one example configuration per release. The example uses base pattern and the
 virtual disk is formated using the distribution default filesystem.
 
@@ -42,7 +43,7 @@ qemu suse-11.2-vm-guest.i686-1.1.2.raw -m 256
 
 \section{Flavours}
 
-KIWI always generates a file in the .raw format. The \path{.raw} file is a disk
+KIWI always generates a file in the \path{.raw} format. The \path{.raw} file is a disk
 image with a structure equivalent to the structure of a physical hard disk. 
 Individual virtualization systems have specific formats to facilitate
 improved I/O performance to the virtual disk, represented by the image file,
@@ -60,20 +61,21 @@ The following table lists the supported virtual disk formats
 \hline
 \textbf{Name} &amp; \textbf{Description} \\
 \hline
-vmdk        &amp; Disk format for VMware \\
-ovf         &amp; Open Virtual Format requires VMwares ovftool \\
-qcow2       &amp; QEMU virtual disk format  \\
+vmdk\index{vmdk}\index{VMware!vmdk}       &amp; Disk format for VMware \\
+ovf\index{ovf}         &amp; Open Virtual Format requires VMwares ovftool \\
+qcow2\index{qcow2}     &amp; QEMU virtual disk format  \\
 \hline
 \end{tabular}
 
 \subsection{VMware support}
-
+\index{VMware!support}
 A VMware image is accompanied by a guest configuration file. This file 
 includes information about the hardware to be represented to the guest 
 image by the VMware virtualization environment as well as specification
 of resources such as memory. 
 
-Within the \path{config.xml} file it is possible to specify the VMware configuration
+Within the \path{config.xml}\index{configuration files!config.xml}
+file it is possible to specify the VMware configuration
 settings. In addition it is possible to include selected packages in the 
 created image that are specific to the VM image generation. The following
 config.xml snippet provides general guidance on the elements in \path{config.xml}.
@@ -90,7 +92,7 @@ config.xml snippet provides general guidance on the elements in \path{config.xml
 \end{xml}
 
 Given the specification above KIWI will create a VMware guest
-configuration specifying the availability of 512 MB of RAM and an IDE 
+configuration specifying the availability of 512~MB of RAM and an IDE 
 disk controller interface for the VM guest. For aditional information
 about the configuration settings please refer to the 
 \textit{machine} section. 
@@ -134,3 +136,5 @@ kiwi --create /tmp/myvm --type vmx -d /tmp/myvm-result --lvm
 With the optional \xmlelement{lvmvolumes} section you can set one or
 more top level directories into a separate volume. See the
 \textit{KIWI image description} chapter for a detailed explanation.
+
+\index{KIWI images!vmx|)}
diff --git a/doc/LaTex/workflow.tex b/doc/LaTex/workflow.tex
index fdc97e6..7652976 100644
--- a/doc/LaTex/workflow.tex
+++ b/doc/LaTex/workflow.tex
@@ -11,7 +11,8 @@ tree or, in KIWI speak, a new unpacked image. The building of a new
 root tree consists of the creation of the directory specified to
 hold it and the installation of the selected packages on it. The
 installation of software packages is driven by a packagemanager.
-KIWI supports the smart and zypper package managers. The prepare
+KIWI supports the smart\index{package managers!smart}
+and zypper\index{package managers!zypper} package managers. The prepare
 step executes the following major stages:
 
 \begin{itemize}
@@ -32,7 +33,7 @@ step executes the following major stages:
       because of the dependency system. To save space in your image you
       could schedule a set of packages for deletion after the package
       installation phase is over by listing them in the \xmlelement{delete} section.
-\item \textbf{Executing of User Defined Script config.sh}\\
+\item \textbf{Executing of User Defined Script config.sh}\index{scripts!config.sh}\\
       At the end of the preperation stage the optional script named \cmd{config.sh}
       is called. This script should be used to configure the system which means
       for example the activation of services. For a detailed description what
@@ -64,7 +65,7 @@ Xen image from the same prepared root tree. The create step executes the
 following major stages:
 
 \begin{itemize}
-\item \textbf{Executing User Defined Script images.sh}\\
+\item \textbf{Executing User Defined Script images.sh}\index{scripts!images.sh}\\
       At the beginning of the creation stage the optional script named
       \cmd{images.sh} is called. This script has no distinctive use case like
       \cmd{config.sh} but is most often used to remove packages which were pulled
@@ -90,8 +91,8 @@ Detailed information including a step by step guidance how to call
 kiwi and how to make use of the result image can be found in the image
 type specific sections later in this document.
 
-\section{Boot Process}
-Todays linux systems are using a special boot image to control the
+\section{Boot Process}\index{boot process}
+Todays Linux systems are using a special boot image to control the
 boot process. This boot image is called \path{initrd}. The linux
 kernel loads this initial ramdisk which is a compressed cpio archive
 into RAM and calls init or if present the program named \cmd{linuxrc}. The
@@ -176,4 +177,6 @@ list of kernel drivers from the SUSE kernel.
 The prefixed implementation allows us to integrate all the
 distribution specific tasks into one project but this of course
 requires the help and knowledge of the people who are familar
-with their preferred linux distribution. 
+with their preferred Linux distribution. 
+
+\index{KIWI images!workflow|)}
diff --git a/doc/LaTex/xen.tex b/doc/LaTex/xen.tex
index daf2e3a..51ce1d7 100644
--- a/doc/LaTex/xen.tex
+++ b/doc/LaTex/xen.tex
@@ -1,5 +1,5 @@
-\index{KIWI images!xen|(}
 \chapter{Xen Image---Paravirtual Systems}
+\index{KIWI images!Xen|(}\index{Xen|(}
 \label{chapter:xen}
 \minitoc
 
@@ -18,12 +18,12 @@ hardware. The system administrator logs into dom0 in order to start
 any further guest operating systems, called \kquote{domain U} (domU) in
 Xen terminology.
 
-A xen image is a virtual disk like a vmx but with the xen kernel
+A Xen image is a virtual disk like a vmx but with the xen kernel
 installed. In order to run it a Xen dom0 server needs to run. Xen
-images in kiwi makes use of the PVGrub method supported by current
+images in KIWI makes use of the PVGrub method supported by current
 Xen versions. Xen extracts the kernel and initrd from the virtual
 disk as well as the grub configuration and displays the menu which
-allows emulation of the grub console
+allows emulation of the Grub console
 
 \section{Building the suse-xen-guest Example}
 
@@ -58,7 +58,7 @@ xm create -c \
 \section{Flavours}
 
 With KIWI you can provide the information
-required to create a guest configuration as part of the config.xml
+required to create a guest configuration as part of the \path{config.xml}
 file. Additionally you can group special packages which you may only
 need in this para virtual environment with a profile.
 
@@ -74,7 +74,7 @@ need in this para virtual environment with a profile.
 \end{xml}
 
 If this information is present KIWI will create a Xen domain U
-configuration with 512 MB of RAM and expects the disk at \path{/dev/xvda}.
+configuration with 512~MB of RAM and expects the disk at \path{/dev/xvda}.
 Additional information to setup the Xen guest machine properties are
 explained in the \texttt{machine} section. The KIWI Xen domain U
 configuration is stored in the file:
@@ -83,3 +83,7 @@ configuration is stored in the file:
 /tmp/myxen-result/\
     suse-11.2-xen-guest.i686-1.1.2.xenconfig
 \end{Command}
+
+
+\index{KIWI images!Xen|)}
+\index{Xen|)}
\ No newline at end of file
diff --git a/doc/kiwi.pdf b/doc/kiwi.pdf
index d2ecb03..c7f3893 100644
Binary files a/doc/kiwi.pdf and b/doc/kiwi.pdf differ


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002553.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. b2acc89cf611fb2df8450097f53e40c811fb483a
</A></li>
	<LI>Next message: <A HREF="002555.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 85d885db2b8596e5fecbf55f188a5baf4ecdf8e6
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2554">[ date ]</a>
              <a href="thread.html#2554">[ thread ]</a>
              <a href="subject.html#2554">[ subject ]</a>
              <a href="author.html#2554">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
