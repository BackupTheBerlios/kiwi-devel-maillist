<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 86a8bf0620ba40e76fa93fd477b620225ccdd95f
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%2086a8bf0620ba40e76fa93fd477b620225ccdd95f&In-Reply-To=%3C200912030901.nB391kqE013899%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001646.html">
   <LINK REL="Next"  HREF="001647.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 86a8bf0620ba40e76fa93fd477b620225ccdd95f</H1>
    <B>adrians at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%2086a8bf0620ba40e76fa93fd477b620225ccdd95f&In-Reply-To=%3C200912030901.nB391kqE013899%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 86a8bf0620ba40e76fa93fd477b620225ccdd95f">adrians at mail.berlios.de
       </A><BR>
    <I>Thu Dec  3 10:01:46 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001646.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 7f462113c37ae034b976c4cae45c84fa4a2ff700
</A></li>
        <LI>Next message: <A HREF="001647.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. ce47e8c55dcc4934d284d0656b53dc75911241ed
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1652">[ date ]</a>
              <a href="thread.html#1652">[ thread ]</a>
              <a href="subject.html#1652">[ subject ]</a>
              <a href="author.html#1652">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  86a8bf0620ba40e76fa93fd477b620225ccdd95f (commit)
      from  7f462113c37ae034b976c4cae45c84fa4a2ff700 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 86a8bf0620ba40e76fa93fd477b620225ccdd95f
Author: Adrian Schr&#195;&#182;ter &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">adrian at scherben.</A>(none)&gt;
Date:   Thu Dec 3 10:00:52 2009 +0100

    move kiwi installation source plugins from novell forge.
    These plugins are needed to create product medias for openSUSE 11.1 and later.
    The 11.0 plugin has been dropped, since it never was in a working state.

-----------------------------------------------------------------------

Summary of changes:
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIBasePlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIBasePlugin.pm
new file mode 100644
index 0000000..e488e04
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIBasePlugin.pm
@@ -0,0 +1,193 @@
+#================
+# FILE          : KIWIInstSourceBasePlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Base class for a loadable plugin which creates
+#               : a certain type of metadata
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIBasePlugin;
+
+use strict;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIInstSourceBasePlugin object which creates
+  # one specific type of metadata
+  # ---
+  my $class = shift;
+  
+  my $this  = {
+    m_handler	  =&gt; undef, # know the handler object
+    m_name	  =&gt; &quot;KIWIBasePlugin&quot;, # name of the plugin (just sound nice)
+    m_order	  =&gt; undef, # order number, selects execution time
+    m_requireddirs =&gt; [],    # list of directories required before execution
+    m_descr	  =&gt; [],    # plaintext description of what the plugin does
+    m_requires	  =&gt; [],    # list of required packages for the plugin
+    m_ready	  =&gt; 0,	    # execution ready flag. Must be true to enable execute()
+    m_collect	  =&gt; 0,	    # reference to KIWICollect object
+  };
+  bless ($this, $class);
+
+  $this-&gt;{m_handler} = shift;
+  if(not ref($this-&gt;{m_handler})) {
+    return undef;
+  }
+  $this-&gt;{m_collect} = $this-&gt;{m_handler}-&gt;collect();
+
+  return $this;
+}
+# /constructor
+
+
+
+# access method for name:
+sub name
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldname = $this-&gt;{m_name};
+  if(@_) {
+    $this-&gt;{m_name} = shift;
+  }
+  return $oldname;
+}
+
+
+
+# access method for order:
+sub order
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldorder = $this-&gt;{m_order};
+  if(@_) {
+    $this-&gt;{m_order} = shift;
+  }
+  return $oldorder;
+}
+
+
+
+# access method for readyness:
+sub ready
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldready = $this-&gt;{m_ready};
+  if(@_) {
+    $this-&gt;{m_ready} = shift;
+  }
+  return $oldready;
+}
+
+
+
+# access method for required directories:
+sub requiredDirs
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @oldrd = @{$this-&gt;{m_requireddirs}};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_requireddirs}}, $entry;
+  }
+  return @oldrd;
+}
+
+
+
+# access method for description
+sub description
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @olddesc = $this-&gt;{m_descr};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_descr}}, $entry;
+  }
+  return @olddesc;
+}
+
+
+
+# access method for requirements
+sub requires
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @oldreq = $this-&gt;{m_requires};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_requires}}, $entry;
+  }
+  return @oldreq;
+}
+
+
+
+# access method for handler
+sub handler
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  return $this-&gt;{m_handler};
+}
+
+
+
+# access method for collect
+sub collect
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  return $this-&gt;{m_collect};
+}
+
+
+
+# interface to KIWICollect::logMsg
+sub logMsg
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $type = shift;
+  my $msg = shift;
+  if(not defined($type) or not defined($msg)) {
+    return undef;
+  }
+
+  $this-&gt;{m_collect}-&gt;logMsg($type, $msg);
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.ini
new file mode 100644
index 0000000..3af66f4
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.ini
@@ -0,0 +1,19 @@
+# INI file for KIWIContentPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIContentPlugin
+order = 4
+defaultenable = 1
+
+[target]
+targetfile = content
+targetdir = $PRODUCT_DIR
+media = all
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.pm
new file mode 100644
index 0000000..cd5c217
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIContentPlugin.pm
@@ -0,0 +1,169 @@
+#================
+# FILE          : KIWIContentPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module creating the content file
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIContentPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Data::Dumper;
+use Config::IniFiles;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIContentPlugin object
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = content
+  #targetdir = $PRODUCT_DIR
+  #media = (list of numbers XOR &quot;all&quot;)
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  my $target	= $ini-&gt;val('target', 'targetfile');
+  my $targetdir	= $ini-&gt;val('target', 'targetdir');
+  my @media	= $ini-&gt;val('target', 'media');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($enable)
+     or not defined($target)
+     or not defined($targetdir)
+     or not @media
+    ) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $targetdir = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$targetdir&quot;);
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  $this-&gt;requiredDirs($targetdir);
+  $this-&gt;{m_target} = $target;
+  $this-&gt;{m_targetdir} = $targetdir;
+  @{$this-&gt;{m_media}} = @media;
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my @targetmedia = $this-&gt;collect()-&gt;getMediaNumbers();
+  my %targets;
+  if($this-&gt;{m_media}-&gt;[0] =~ m{all}i) {
+    %targets = map { $_ =&gt; 1 } @targetmedia;
+  }
+  else {
+    foreach my $cd(@{$this-&gt;{m_media}}) {
+      if(grep { $cd } @targetmedia) {
+	$targets{$cd} = 1;
+      }
+    }
+  }
+  
+  my $info = $this-&gt;collect()-&gt;productData()-&gt;getSet(&quot;prodinfo&quot;);
+  if(!$info) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;data set named &lt;prodinfo&gt; seems to be broken:&quot;);
+    $this-&gt;logMsg(&quot;E&quot;, Dumper($info));
+    return $retval;
+  }
+
+  foreach my $cd(keys(%targets)) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Creating content file on medium &lt;$cd&gt;:&quot;);
+    my $dir = $this-&gt;collect()-&gt;basesubdirs()-&gt;{$cd};
+    my $contentfile = &quot;$dir/$this-&gt;{m_target}&quot;;
+    if(not open(CONT, &quot;&gt;&quot;, $contentfile)) {
+      $this-&gt;logMsg(&quot;E&quot;, &quot;Cannot create &lt;$contentfile&gt; on medium &lt;$cd&gt;&quot;);
+      next;
+    }
+
+    # compute maxlen:
+    my $len = 0;
+    foreach(keys(%{$info})) {
+      my $l = length($info-&gt;{$_}-&gt;[0]);
+      $len = ($l&gt;$len)?$l:$len;
+    }
+    $len++;
+    foreach my $i(sort { $a &lt;=&gt; $b } keys(%{$info})) {
+      print CONT sprintf('%-*s %s', $len, $info-&gt;{$i}-&gt;[0], $info-&gt;{$i}-&gt;[1]).&quot;\n&quot;;
+    }
+    close(CONT);
+
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Wrote file &lt;$contentfile&gt; for medium &lt;$cd&gt; successfully.&quot;);
+    $retval++;
+  }
+
+  return $retval;
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.ini
new file mode 100644
index 0000000..34e7fa5
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.ini
@@ -0,0 +1,38 @@
+# INI file for KIWIDescrPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIDescrPlugin
+order = 2
+tool = create_package_descr
+tooldir = /usr/bin
+toolpack = inst-source-utils
+defaultenable = 1
+#media = 1
+
+[options]
+pdbfiles = -p /mounts/work/cd/data/pdb/stable
+parameter = -P
+parameter = -Z
+parameter = -C
+parameter = -K
+parameter = -M 3
+parameter = -V
+parameter = -F
+parameter = -B
+language = -l german
+language = -l english
+language = -l french
+language = -l czech
+language = -l spanish
+language = -l hungarian
+
+[target]
+compress = yes
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.pm
new file mode 100644
index 0000000..44df109
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIDescrPlugin.pm
@@ -0,0 +1,200 @@
+#================
+# FILE          : KIWIDescrPlugin.pm
+#----------------
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module calling create_package_descr
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIDescrPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Config::IniFiles;
+use Data::Dumper;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIDescrPlugin object
+  # creates patterns file
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation&quot;);
+    return undef;
+  }
+
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name    = $ini-&gt;val('base', 'name'); # scalar value
+  my $order   = $ini-&gt;val('base', 'order'); # scalar value
+  my $tool    = $ini-&gt;val('base', 'tool'); # scalar value
+  my $tdir    = $ini-&gt;val('base', 'tooldir'); # scalar value
+  my $tpack   = $ini-&gt;val('base', 'toolpack'); # scalar value
+  my $enable  = $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  my $pdbfiles	= $ini-&gt;val('options', 'pdbfiles');
+  my @params	= $ini-&gt;val('options', 'parameter');
+  my @langs	= $ini-&gt;val('options', 'language');
+
+  my $gzip    = $ini-&gt;val('target', 'compress');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($tool)
+     or not defined($tdir)
+     or not defined($tpack)
+     or not defined($enable)
+     or not defined($pdbfiles)
+     or not defined($gzip)
+     or not (@params)
+     or not (@langs)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!&quot;);
+    return undef;
+  }
+
+  # sanity check for tools' existence:
+  if(not( -f &quot;$tdir/$tool&quot; and -x &quot;$tdir/$tool&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin &lt;$name&gt;: tool &lt;$tdir/$tool&gt; is not executable!&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Check if package &lt;$tpack&gt; is installed.&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $this-&gt;{m_tool} = $tool;
+  $this-&gt;{m_tooldir} = $tdir;
+  $this-&gt;{m_toolpack} = $tpack;
+  $this-&gt;{m_pdbfiles} = $pdbfiles;
+  $this-&gt;{m_params} = join(' ', @params);
+  $this-&gt;{m_languages} = join(' ', @langs);
+  $this-&gt;{m_compress} = $gzip;
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $coll = $this-&gt;{m_collect};
+  my $basesubdirs = $coll-&gt;basesubdirs();
+  if(not defined($basesubdirs)) {
+    ## prevent crash when dereferencing
+    $this-&gt;logMsg(&quot;E&quot;, &quot;&lt;basesubdirs&gt; is undefined! Skipping &lt;$this-&gt;name()&gt;&quot;);
+    return $retval;
+  }
+
+  # ftp trees should get no connection. This should maybe get an optional switch.
+  # FIXME: FLAVOR is not a good idea, but the media type is currently not reachable here.
+  if( $coll-&gt;productData()-&gt;getvar(&quot;FLAVOR&quot;) =~ m{ftp}i ) {
+    foreach my $d(values %{$basesubdirs}) {
+      my @a;
+      push @a, $d;
+      $retval += $this-&gt;executeDir( @a );
+    }
+  }
+  else {
+    my @paths = values(%{$basesubdirs});
+    @paths = grep { $_ =~ /[^0]$/ } @paths; # remove Media0
+    @paths = sort @paths; # sort it
+    $retval += $this-&gt;executeDir( @paths );
+  }
+  return $retval;
+}
+
+
+
+sub executeDir
+{
+  my $this     = shift;
+  my @paths    = @_;
+  my $retval   = 0;
+  if(!@paths) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;Empty path list!&quot;);
+    return $retval;
+  }
+
+  my $coll  = $this-&gt;{m_collect};
+  my $datadir  = $coll-&gt;productData()-&gt;getInfo(&quot;DATADIR&quot;);
+  my $descrdir = $coll-&gt;productData()-&gt;getInfo(&quot;DESCRDIR&quot;);
+
+  my $targetdir = $paths[0].&quot;/&quot;.$descrdir;
+
+  ## this ugly bit creates a parameter string from a list of directories:
+  # param = -d &lt;dir1&gt; -d &lt;dir2&gt; ...
+  # the order is important. Idea: use map to make hash &lt;dir&gt; =&gt; -d for all subdirs not ending with &quot;0&quot;
+  # (those are for metafile unpacking only). The result is evaluated in list context be reverse, so there's a list
+  # looking like &quot;&lt;dir_N&gt; -d ... &lt;dir1&gt; -d&quot; which is reversed again, making the result
+  # '-d', '&lt;dir1&gt;', ..., '-d', '&lt;dir_N&gt;'&quot;, after the join as string.
+  my $pathlist = &quot;-d &quot;.join(' -d ', map{$_.&quot;/&quot;.$datadir}(@paths));
+
+  $this-&gt;logMsg(&quot;I&quot;, &quot;Calling &quot;.$this-&gt;name().&quot; for directories &lt;@paths&gt;:&quot;);
+
+  my $cmd = &quot;$this-&gt;{m_tooldir}/$this-&gt;{m_tool} $this-&gt;{m_pdbfiles} $pathlist $this-&gt;{m_params} $this-&gt;{m_languages} -o &quot;.$paths[0].&quot;/&quot;.$descrdir;
+  my $data = qx( $cmd );
+  my $status = $? &gt;&gt; 8;
+  my $linkname = &quot;packages.sk&quot;;	# default link name for uncompressed file
+  my $linktarget = &quot;packages.cs&quot;;
+  if($this-&gt;{m_compress} =~ m{yes}i) {
+    if(!opendir(PATDIR, &quot;$targetdir&quot;)) {
+      $this-&gt;logMsg(&quot;E&quot;, &quot;Can't open directory &lt;$targetdir&gt;!&quot;);
+      return $retval;
+    }
+    my @files = readdir(PATDIR);
+    closedir(PATDIR);
+
+    foreach my $pfile(@files) {
+      next if($pfile !~ m{^(packages[.]*.*)});
+      if(system(&quot;gzip&quot;, &quot;$targetdir/$pfile&quot;) == 0) {
+	unlink &quot;$targetdir/$pfile&quot;;
+	if($pfile =~ m{packages.(cs|cz)}) {
+	  $linktarget .= &quot;.gz&quot;;
+	  $linkname .= &quot;.gz&quot;;
+	}
+      }
+      else {
+	$this-&gt;logMsg(&quot;W&quot;, &quot;Can't compress file &lt;$targetdir/$pfile&gt;!&quot;);
+      }
+    }
+  }
+  symlink &quot;$linktarget&quot;, &quot;$targetdir/$linkname&quot;;
+
+  $retval = 1;
+  return $retval;
+}
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.ini
new file mode 100644
index 0000000..cf83ec6
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.ini
@@ -0,0 +1,28 @@
+# INI file for KIWIEulaPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIEulaPlugin
+order = 3
+tool = packages2eula.pl
+tooldir = /usr/bin
+toolpack = inst-source-utils
+defaultenable = 1
+sourcefile = packages.en.gz
+sourcedir = $DESCRDIR
+
+[option]
+in = -i
+out = -o
+packfile = -p
+
+[target]
+targetfile = EULA.txt
+targetdir = $PRODUCT_DIR
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.pm
new file mode 100644
index 0000000..0d5ea1b
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIEulaPlugin.pm
@@ -0,0 +1,185 @@
+#================
+# FILE          : KIWIEulaPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module creating the EULA.txt file
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIEulaPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Config::IniFiles;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIEulaPlugin object
+  # creates patterns file
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #src = packages.en[.gz]
+  #srcdir = $DESCRDIR
+  #tool = packages2eula.pl
+  #tooldir = /usr/bin
+  #toolpack = inst-source-utils
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = EULA.txt
+  #targetdir = $PRODUCT_DIR
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $tool	= $ini-&gt;val('base', 'tool'); # scalar value
+  my $tooldir   = $ini-&gt;val('base', 'tooldir'); # scalar value
+  my $toolpack	= $ini-&gt;val('base', 'toolpack'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+  my $src	= $ini-&gt;val('base', 'sourcefile'); # scalar value
+  my $srcdir	= $ini-&gt;val('base', 'sourcedir'); # scalar value
+
+  my $iopt	= $ini-&gt;val('option', 'in'); # scalar value
+  my $oopt	= $ini-&gt;val('option', 'out'); # scalar value
+  my $popt	= $ini-&gt;val('option', 'packfile'); # scalar value
+
+  my $target  = $ini-&gt;val('target', 'targetfile');
+  my $targetdir  = $ini-&gt;val('target', 'targetdir');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($tool)
+     or not defined($tooldir)
+     or not defined($toolpack)
+     or not defined($enable)
+     or not defined($target)
+     or not defined($targetdir)
+     or not defined($iopt)
+     or not defined($oopt)
+     or not defined($popt)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $targetdir = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$targetdir&quot;);
+  $srcdir = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$srcdir&quot;);
+  $this-&gt;{m_target} = $target;
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  $this-&gt;{m_source} = $src;
+  $this-&gt;{m_srcdir} = $srcdir;
+  $this-&gt;{m_tool} = $tool;
+  $this-&gt;{m_toolpath} = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$tooldir&quot;);
+  $this-&gt;{m_toolpack} = $toolpack;
+  $this-&gt;{m_iopt} = $iopt;
+  $this-&gt;{m_oopt} = $oopt;
+  $this-&gt;{m_popt} = $popt;
+  $this-&gt;requiredDirs($srcdir, $targetdir);
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $dirname = $this-&gt;{m_handler}-&gt;baseurl().&quot;/&quot;.$this-&gt;{m_handler}-&gt;mediaName();
+  my $mult = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;MULTIPLE_MEDIA&quot;);
+  if( $mult ne &quot;no&quot;) {
+    $dirname .= $this-&gt;{m_media};
+  }
+  my $srcdir = $dirname.&quot;/&quot;.$this-&gt;{m_requireddirs}-&gt;[0];
+  my $targetdir = $dirname.&quot;/&quot;.$this-&gt;{m_requireddirs}-&gt;[1];
+
+  if(!open(SRCFILE, &quot;&lt;&quot;, &quot;$srcdir/&quot;.$this-&gt;{m_source})) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;PatternsPlugin: cannot read &lt;$srcdir/&quot;.$this-&gt;{m_source}.&quot;&gt;&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;&quot;);
+    return $retval;
+  }
+  #if(!open(TARGET, &quot;&gt;&quot;, &quot;$targetdir/&quot;.$this-&gt;{m_target}&quot;.new&quot;)) {
+  #  $this-&gt;handler()-&gt;collect()-&gt;logger()-&gt;error(&quot;[E] PatternsPlugin: cannot create &lt;$targetdir/&quot;.$this-&gt;{m_target}.&quot;&gt;/!&quot;);
+  #  $this-&gt;handler()-&gt;collect()-&gt;logger()-&gt;error(&quot;[I] Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;\n&quot;);
+  #  return $retval;
+  #}
+
+  my $cmd = &quot;$this-&gt;{m_toolpath}/$this-&gt;{m_tool} $this-&gt;{m_iopt} $targetdir/$this-&gt;{m_target} $this-&gt;{m_popt} $srcdir/$this-&gt;{m_source} $this-&gt;{m_oopt} $targetdir/$this-&gt;{m_target}.new&quot;;
+  my @data = qx($cmd);
+  #my $data = qx($this-&gt;{m_toolpath}/$this-&gt;{m_tool} -i &quot;$this-&gt;{m_basesubdir}-&gt;{'1'}/EULA.txt&quot; -p $pfilename -o &quot;$this-&gt;{m_basesubdir}-&gt;{'1'}/EULA.txt.new&quot;);
+  close(SRCFILE);
+
+  $this-&gt;logMsg(&quot;I&quot;, &quot;output of command $this-&gt;{m_tool}:\n&quot;);
+  foreach my $l(@data) {
+    chomp($l);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;\t$l\n&quot;);
+  }
+  my $status = $? &gt;&gt; 8;
+  if($status) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;command $this-&gt;{m_tool} exited with &lt;$status&gt;\n&quot;);
+  }
+  else {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;command $this-&gt;{m_tool} exited successfully.\n&quot;);
+    $retval = 1;
+  }
+
+  return $retval;
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.ini
new file mode 100644
index 0000000..d1eff4a
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.ini
@@ -0,0 +1,14 @@
+# INI file for KIWIMiniIsoPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIDescrPlugin
+order = 5
+defaultenable = 1
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.pm
new file mode 100644
index 0000000..5c7ad13
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIMiniIsoPlugin.pm
@@ -0,0 +1,216 @@
+#================
+# FILE          : KIWIMiniIsoPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module patching mini iso builds
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIMiniIsoPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Data::Dumper;
+use Config::IniFiles;
+use File::Find;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIMiniIsoPlugin object
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = content
+  #targetdir = $PRODUCT_DIR
+  #media = (list of numbers XOR &quot;all&quot;)
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($enable)
+    ) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $repoloc = $this-&gt;collect()-&gt;productData()-&gt;getOpt(&quot;REPO_LOCATION&quot;);
+  my $ismini = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;FLAVOR&quot;);
+  if(not defined($repoloc) or $repoloc =~ m{notset}i) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;&lt;REPO_LOCATION&gt; is missing, can't patch &lt;gfxboot.cfg&gt;!&quot;);
+    return $retval;
+  }
+  if(not defined($ismini) or $ismini =~ m{notset}i) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;Can't determine if this is a miniiso! Doing nothing&quot;);
+    return $retval;
+  }
+  $repoloc =~ m{^<A HREF="http://([^/">http://([^/</A>]+)/(.+)};
+  my ($srv, $path) = ($1, $2);
+
+  if($ismini !~ m{mini}i and !$srv) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Nothing to for for media type &lt;$ismini&gt;&quot;);
+    return $retval;
+  }
+
+  my @gfxbootfiles;
+  find( sub { find_cb($this, \@gfxbootfiles) }, $this-&gt;handler()-&gt;collect()-&gt;basedir());
+
+  if(!@gfxbootfiles) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;No gfxboot.cfg file found!&quot;);
+    return $retval;
+  }
+
+  foreach my $cfg(@gfxbootfiles) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Processing file &lt;$cfg&gt;: &quot;);
+    if(not open(F, &quot;&lt;&quot;, $cfg)) {
+      $this-&gt;logMsg(&quot;E&quot;, &quot;Cant open file &lt;$cfg&gt;!&quot;);
+      next;
+    }
+    my @lines = &lt;F&gt;;
+    close(F);
+    chomp(@lines);
+    my $install = -1;
+    my $ihs = -1;
+    my $ihp = -1;
+    my $i = -1;
+    foreach my $line(@lines) {
+      $i++;
+      next if $line !~ m{^install};
+      if($line =~ m{^install=.*}) {
+	$install = $i;
+      }
+      if($line =~ m{^install.http.server=+}) {
+	$ihs = $i;
+      }
+      if($line =~ m{^install.http.path=+}) {
+	$ihp = $i;
+      }
+    }
+
+    if($ismini =~ m{mini}i) {
+      if($install == -1) {
+	push @lines, &quot;install=slp&quot;;
+      }
+      else {
+	$lines[$install] =~ s{^install.*}{install=slp};
+      }
+    }
+    else {
+      if($ihs == -1) {
+	push @lines, &quot;install.http.server=$srv&quot;;
+      }
+      else {
+	$lines[$ihs] =~ s{^(install.http.server).*}{$1=$srv};
+      }
+      if($ihp == -1) {
+	push @lines, &quot;install.http.path=$path&quot;;
+      }
+      else {
+	$lines[$ihp] =~ s{^(install.http.path).*}{$1=$path};
+      }
+      if($install == -1) {
+	push @lines, &quot;install=http&quot;;
+      }
+      else {
+	$lines[$install] =~ s{^install.*}{install=http};
+      }
+    }
+    unlink $cfg;
+    open(F, &quot;&gt;&quot;, $cfg);
+    foreach(@lines) {
+      print F &quot;$_\n&quot;;
+    }
+    close(F);
+    $retval++;
+  }
+  return $retval;
+}
+
+
+
+sub find_cb
+{
+  my $this = shift;
+  return undef if not ref($this);
+
+  my $listref = shift;
+  return undef if not defined($listref);
+
+  if($File::Find::name =~ m{.*/gfxboot\.cfg$}) {
+    push @{$listref}, $File::Find::name;
+  }
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.ini
new file mode 100644
index 0000000..45e14a5
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.ini
@@ -0,0 +1,20 @@
+# INI file for KIWIPatternsPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIPatternsPlugin
+dir = $DATADIR/setup/descr
+order = 1
+defaultenable = 1
+media = 1
+
+[target]
+targetfile = patterns
+compress = yes
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.pm
new file mode 100644
index 0000000..9a1c9a4
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/KIWIPatternsPlugin.pm
@@ -0,0 +1,164 @@
+#================
+# FILE          : KIWIPatternsPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module creating the &quot;patterns&quot; file
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIPatternsPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Config::IniFiles;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIPatternsPlugin object
+  # creates patterns file
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIPatternsPlugin
+  #dir = $DATADIR/setup/descr
+  #order = 1
+  #tool = create_package_descr
+  #tooldir = /usr/bin
+  #toolpack = inst-source-utils
+  #defaultenabled = 1
+  #media = 1
+  #
+  #[target]
+  #targetfile = patterns
+  #compress = yes|no
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name    = $ini-&gt;val('base', 'name'); # scalar value
+  my $order   = $ini-&gt;val('base', 'order'); # scalar value
+  my @dirs    = $ini-&gt;val('base', 'dir');	# here may be more than one
+  my $enable  = $ini-&gt;val('base', 'defaultenable'); # scalar value
+  my @media   = $ini-&gt;val('base', 'media'); # here may be a list again
+
+  my $target  = $ini-&gt;val('target', 'targetfile');
+  my $gzip    = $ini-&gt;val('target', 'compress');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not @dirs
+     or not defined($enable)
+     or not defined($target)
+     or not defined($gzip)
+     or not @media) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  # parse dirs for productvars content:
+  for(my $i=0; $i &lt;= $#dirs; $i++) {
+    $dirs[$i] = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$dirs[$i]&quot;);
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $this-&gt;requiredDirs(@dirs);
+  $this-&gt;{m_media} = @media;
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  $this-&gt;{m_compress} = $gzip;
+  $this-&gt;{m_target} = $target;
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $dirname = $this-&gt;{m_handler}-&gt;baseurl().&quot;/&quot;.$this-&gt;{m_handler}-&gt;mediaName();
+  my $mult = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;MULTIPLE_MEDIA&quot;);
+  if( $mult ne &quot;no&quot;) {
+    $dirname .= $this-&gt;{m_media};
+  }
+  $dirname .= &quot;/&quot;.$this-&gt;{m_requireddirs}-&gt;[0];
+
+  if(!opendir(PATDIR, &quot;$dirname&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;PatternsPlugin: cannot read &lt;$dirname&gt;&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;&quot;);
+    return $retval;
+  }
+  if(!open(PAT, &quot;&gt;&quot;, &quot;$dirname/$this-&gt;{m_target}&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;PatternsPlugin: cannot create &lt;$dirname&gt;/patterns!&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;&quot;);
+    return $retval;
+  }
+  my @dirent = readdir(PATDIR);
+  foreach my $f(@dirent) {
+    next if $f !~ m{(.*\.pat|.*\.pat\.gz)};
+    if($f !~ m{.*\.gz$} and $this-&gt;{m_compress} =~ m{yes}i) {
+      if (system('gzip', &quot;$dirname/$f&quot;) == 0) {
+	$f = &quot;$f.gz&quot;;
+      }
+    }
+    print PAT &quot;$f\n&quot;;
+  }
+  close(PATDIR);	
+  close(PAT);	
+
+  $retval = 1;
+  return $retval;
+}
+
+
+
+1;
+
diff --git a/LICENSE b/distribution/kiwi-instsource-plugins-openSUSE-11-1/LICENSE
old mode 100755
new mode 100644
similarity index 100%
copy from LICENSE
copy to distribution/kiwi-instsource-plugins-openSUSE-11-1/LICENSE
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-1/Makefile b/distribution/kiwi-instsource-plugins-openSUSE-11-1/Makefile
new file mode 100644
index 0000000..a4dd03c
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-1/Makefile
@@ -0,0 +1,25 @@
+# /.../
+# Copyright (c) 2006 SUSE LINUX Products GmbH. All rights reserved.
+# Author: Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;, 2006
+#
+# Makefile for OpenSuSE - KIWI Image System InstSource Plugins
+# ---
+buildroot = /
+kiwi_prefix = ${buildroot}/usr/share/kiwi/
+
+#============================================
+# Variables... 
+#--------------------------------------------
+KIWIPLUGINVZ  = ${kiwi_prefix}/modules/plugins/suse-11.1
+
+install:
+	#============================================
+	# Install base directories
+	#--------------------------------------------
+	install -d -m 755 ${KIWIPLUGINVZ}
+
+	#============================================
+	# Install plugins
+	#--------------------------------------------
+	install -m 644 ./*.pm  ${KIWIPLUGINVZ}
+	install -m 644 ./*.ini ${KIWIPLUGINVZ}
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIBasePlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIBasePlugin.pm
new file mode 100644
index 0000000..d4de771
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIBasePlugin.pm
@@ -0,0 +1,262 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWIInstSourceBasePlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Base class for a loadable plugin which creates
+#               : a certain type of metadata
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIBasePlugin;
+
+use strict;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIInstSourceBasePlugin object which creates
+  # one specific type of metadata
+  # ---
+  my $class = shift;
+  
+  my $this  = {
+    m_handler	  =&gt; undef, # know the handler object
+    m_name	  =&gt; &quot;KIWIBasePlugin&quot;, # name of the plugin (just sound nice)
+    m_order	  =&gt; undef, # order number, selects execution time
+    m_requireddirs =&gt; [],    # list of directories required before execution
+    m_descr	  =&gt; [],    # plaintext description of what the plugin does
+    m_requires	  =&gt; [],    # list of required packages for the plugin
+    m_ready	  =&gt; 0,	    # execution ready flag. Must be true to enable execute()
+    m_collect	  =&gt; 0,	    # reference to KIWICollect object
+  };
+  bless ($this, $class);
+
+  $this-&gt;{m_handler} = shift;
+  if(not ref($this-&gt;{m_handler})) {
+    return undef;
+  }
+  $this-&gt;{m_collect} = $this-&gt;{m_handler}-&gt;collect();
+
+  return $this;
+}
+# /constructor
+
+
+
+# access method for name:
+sub name
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldname = $this-&gt;{m_name};
+  if(@_) {
+    $this-&gt;{m_name} = shift;
+  }
+  return $oldname;
+}
+
+
+
+# access method for order:
+sub order
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldorder = $this-&gt;{m_order};
+  if(@_) {
+    $this-&gt;{m_order} = shift;
+  }
+  return $oldorder;
+}
+
+
+
+# access method for readyness:
+sub ready
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $oldready = $this-&gt;{m_ready};
+  if(@_) {
+    $this-&gt;{m_ready} = shift;
+  }
+  return $oldready;
+}
+
+
+
+# access method for required directories:
+sub requiredDirs
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @oldrd = @{$this-&gt;{m_requireddirs}};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_requireddirs}}, $entry;
+  }
+  return @oldrd;
+}
+
+
+
+# access method for description
+sub description
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @olddesc = $this-&gt;{m_descr};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_descr}}, $entry;
+  }
+  return @olddesc;
+}
+
+
+
+# access method for requirements
+sub requires
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my @oldreq = $this-&gt;{m_requires};
+  foreach my $entry(@_) {
+    push @{$this-&gt;{m_requires}}, $entry;
+  }
+  return @oldreq;
+}
+
+
+
+# access method for handler
+sub handler
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  return $this-&gt;{m_handler};
+}
+
+
+
+# access method for collect
+sub collect
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  return $this-&gt;{m_collect};
+}
+
+
+
+# interface to KIWICollect::logMsg
+sub logMsg
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $type = shift;
+  my $msg = shift;
+  if(not defined($type) or not defined($msg)) {
+    return undef;
+  }
+
+  $this-&gt;{m_collect}-&gt;logMsg($type, $msg);
+}
+
+# method to distinguish debugmedia and ftp media subdirectories.
+# This is needed in several different plugins.
+sub getSubdirLists
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+
+  my @ret = ();
+  my $coll = $this-&gt;{m_collect};
+  my $dbm = $coll-&gt;productData()-&gt;getOpt(&quot;DEBUGMEDIUM&quot;);
+  my $flavor = $coll-&gt;productData()-&gt;getVar(&quot;FLAVOR&quot;);
+  my $basesubdirs = $coll-&gt;basesubdirs();
+  my @paths = values(%{$basesubdirs});
+  @paths = grep { $_ =~ /[^0]$/ } @paths; # remove Media0
+  #@paths = sort @paths; # sort it
+
+  my %path = map { $_ =&gt; 1 } @paths;
+
+  # case 1: FTP tree, all subdirs get a separate call.
+  if($flavor =~ m{ftp}i) {
+    my @d = sort(keys(%path));
+    foreach(@d) {
+      my @tmp;
+      push @tmp, $_;
+      push @ret, \@tmp;
+    }
+  }
+  # case 2: non-ftp tree, may have separate DEBUGMEDIUM specified
+  elsif($dbm &gt;= 2) {
+    my @deb;
+    my @rest;
+    foreach my $d(keys(%path)) {
+      if($d =~ m{.*$dbm$}) {
+       push @deb, $d;
+      }
+      else {
+       push @rest, $d;
+      }
+    }
+    push @ret, \@deb;
+    push @ret, \@rest;
+  }
+  else {
+    my @d = keys(%path);
+    push @ret, \@d;
+  }
+
+  return @ret;
+}
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.ini
new file mode 100644
index 0000000..3af66f4
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.ini
@@ -0,0 +1,19 @@
+# INI file for KIWIContentPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIContentPlugin
+order = 4
+defaultenable = 1
+
+[target]
+targetfile = content
+targetdir = $PRODUCT_DIR
+media = all
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.pm
new file mode 100644
index 0000000..9dde36c
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIContentPlugin.pm
@@ -0,0 +1,188 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWIContentPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module creating the content file
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIContentPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Data::Dumper;
+use Config::IniFiles;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIContentPlugin object
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = content
+  #targetdir = $PRODUCT_DIR
+  #media = (list of numbers XOR &quot;all&quot;)
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  my $target	= $ini-&gt;val('target', 'targetfile');
+  my $targetdir	= $ini-&gt;val('target', 'targetdir');
+  my @media	= $ini-&gt;val('target', 'media');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($enable)
+     or not defined($target)
+     or not defined($targetdir)
+     or not @media
+    ) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $targetdir = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$targetdir&quot;);
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  $this-&gt;requiredDirs($targetdir);
+  $this-&gt;{m_target} = $target;
+  $this-&gt;{m_targetdir} = $targetdir;
+  @{$this-&gt;{m_media}} = @media;
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my @targetmedia = $this-&gt;collect()-&gt;getMediaNumbers();
+  my %targets;
+  if($this-&gt;{m_media}-&gt;[0] =~ m{all}i) {
+    %targets = map { $_ =&gt; 1 } @targetmedia;
+  }
+  else {
+    foreach my $cd(@{$this-&gt;{m_media}}) {
+      if(grep { $cd } @targetmedia) {
+	$targets{$cd} = 1;
+      }
+    }
+  }
+  
+  my $info = $this-&gt;collect()-&gt;productData()-&gt;getSet(&quot;prodinfo&quot;);
+  if(!$info) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;data set named &lt;prodinfo&gt; seems to be broken:&quot;);
+    $this-&gt;logMsg(&quot;E&quot;, Dumper($info));
+    return $retval;
+  }
+
+  foreach my $cd(keys(%targets)) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Creating content file on medium &lt;$cd&gt;:&quot;);
+    my $dir = $this-&gt;collect()-&gt;basesubdirs()-&gt;{$cd};
+    my $contentfile = &quot;$dir/$this-&gt;{m_target}&quot;;
+    if(not open(CONT, &quot;&gt;&quot;, $contentfile)) {
+      $this-&gt;logMsg(&quot;E&quot;, &quot;Cannot create &lt;$contentfile&gt; on medium &lt;$cd&gt;&quot;);
+      next;
+    }
+
+    # compute maxlen:
+    my $len = 0;
+    foreach(keys(%{$info})) {
+      my $l = length($info-&gt;{$_}-&gt;[0]);
+      $len = ($l&gt;$len)?$l:$len;
+    }
+    $len++;
+    foreach my $i(sort { $a &lt;=&gt; $b } keys(%{$info})) {
+      print CONT sprintf('%-*s %s', $len, $info-&gt;{$i}-&gt;[0], $info-&gt;{$i}-&gt;[1]).&quot;\n&quot;;
+    }
+    close(CONT);
+
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Wrote file &lt;$contentfile&gt; for medium &lt;$cd&gt; successfully.&quot;);
+    $retval++;
+  }
+
+  return $retval;
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.ini
new file mode 100644
index 0000000..21d3379
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.ini
@@ -0,0 +1,33 @@
+# INI file for KIWIDescrPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIDescrPlugin
+order = 2
+createrepo = createrepo
+rezip = rezip_repo_rsyncable
+tool = create_package_descr
+tooldir = /usr/bin
+toolpack = inst-source-utils
+defaultenable = 1
+#media = 1
+
+[options]
+parameter = -P
+parameter = -Z
+parameter = -C
+parameter = -K
+parameter = -M 3
+parameter = -V
+parameter = -F
+parameter = -B
+
+[target]
+compress = yes
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.pm
new file mode 100644
index 0000000..9aa28e1
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIDescrPlugin.pm
@@ -0,0 +1,249 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWIDescrPlugin.pm
+#----------------
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module calling create_package_descr
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIDescrPlugin;
+
+use strict;
+
+use File::Basename;
+use base &quot;KIWIBasePlugin&quot;;
+use Config::IniFiles;
+use Data::Dumper;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIDescrPlugin object
+  # creates patterns file
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation&quot;);
+    return undef;
+  }
+
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name       = $ini-&gt;val('base', 'name'); # scalar value
+  my $order      = $ini-&gt;val('base', 'order'); # scalar value
+  my $tool       = $ini-&gt;val('base', 'tool'); # scalar value
+  my $createrepo = $ini-&gt;val('base', 'createrepo'); # scalar value
+  my $rezip      = $ini-&gt;val('base', 'rezip'); # scalar value
+  my $tdir       = $ini-&gt;val('base', 'tooldir'); # scalar value
+  my $tpack      = $ini-&gt;val('base', 'toolpack'); # scalar value
+  my $enable     = $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  my @params	 = $ini-&gt;val('options', 'parameter');
+
+  my $gzip       = $ini-&gt;val('target', 'compress');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($tool)
+     or not defined($createrepo)
+     or not defined($rezip)
+     or not defined($tdir)
+     or not defined($tpack)
+     or not defined($enable)
+     or not defined($gzip)
+     or not (@params)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!&quot;);
+    return undef;
+  }
+
+  # sanity check for tools' existence:
+  if(not( -f &quot;$tdir/$tool&quot; and -x &quot;$tdir/$tool&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin &lt;$name&gt;: tool &lt;$tdir/$tool&gt; is not executable!&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Check if package &lt;$tpack&gt; is installed.&quot;);
+    return undef;
+  }
+
+  my $params = &quot;&quot;;
+  foreach my $p(@params) {
+    $p = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$p&quot;);
+    $params .= &quot;$p &quot;;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $this-&gt;{m_tool} = $tool;
+  $this-&gt;{m_tooldir} = $tdir;
+  $this-&gt;{m_toolpack} = $tpack;
+  $this-&gt;{m_createrepo} = $createrepo;
+  $this-&gt;{m_rezip} = $rezip;
+  $this-&gt;{m_params} = $params;
+  $this-&gt;{m_compress} = $gzip;
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $coll = $this-&gt;{m_collect};
+  my $basesubdirs = $coll-&gt;basesubdirs();
+  if(not defined($basesubdirs)) {
+    ## prevent crash when dereferencing
+    $this-&gt;logMsg(&quot;E&quot;, &quot;&lt;basesubdirs&gt; is undefined! Skipping &lt;$this-&gt;name()&gt;&quot;);
+    return $retval;
+  }
+
+  foreach my $dirlist($this-&gt;getSubdirLists()) {
+    my ($s,$m) = $this-&gt;executeDir(sort @{$dirlist});
+  }
+#  if( $coll-&gt;productData()-&gt;getVar(&quot;FLAVOR&quot;) =~ m{ftp}i ) {
+#    foreach my $d(values %{$basesubdirs}) {
+#      my @a;
+#      push @a, $d;
+#      $retval += $this-&gt;executeDir( @a );
+#    }
+#  }
+#  else {
+#    my @paths = values(%{$basesubdirs});
+#    @paths = grep { $_ =~ /[^0]$/ } @paths; # remove Media0
+#    @paths = sort @paths; # sort it
+#    $retval += $this-&gt;executeDir( @paths );
+#  }
+  return $retval;
+}
+
+
+
+sub executeDir
+{
+  my $this     = shift;
+  my @paths    = @_;
+  my $retval   = 0;
+  if(!@paths) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;Empty path list!&quot;);
+    return $retval;
+  }
+
+  my $coll  = $this-&gt;{m_collect};
+  my $datadir  = $coll-&gt;productData()-&gt;getInfo(&quot;DATADIR&quot;);
+  my $descrdir = $coll-&gt;productData()-&gt;getInfo(&quot;DESCRDIR&quot;);
+
+  my $targetdir = $paths[0].&quot;/&quot;.$descrdir;
+
+  ## this ugly bit creates a parameter string from a list of directories:
+  # param = -d &lt;dir1&gt; -d &lt;dir2&gt; ...
+  # the order is important. Idea: use map to make hash &lt;dir&gt; =&gt; -d for all subdirs not ending with &quot;0&quot;
+  # (those are for metafile unpacking only). The result is evaluated in list context be reverse, so there's a list
+  # looking like &quot;&lt;dir_N&gt; -d ... &lt;dir1&gt; -d&quot; which is reversed again, making the result
+  # '-d', '&lt;dir1&gt;', ..., '-d', '&lt;dir_N&gt;'&quot;, after the join as string.
+  my $pathlist = &quot;-d &quot;.join(' -d ', map{$_.&quot;/&quot;.$datadir}(@paths));
+
+  $this-&gt;logMsg(&quot;I&quot;, &quot;Calling &quot;.$this-&gt;name().&quot; for directories &lt;@paths&gt;:&quot;);
+
+  my $cmd = &quot;$this-&gt;{m_tooldir}/$this-&gt;{m_tool} $pathlist $this-&gt;{m_params} -o &quot;.$paths[0].&quot;/&quot;.$descrdir;
+  $this-&gt;logMsg(&quot;I&quot;, &quot;Executing command &lt;$cmd&gt;&quot;);
+  my $data = qx( $cmd );
+  my $status = $? &gt;&gt; 8;
+  if($status) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Calling &lt;$cmd&gt; exited with code &lt;$status&gt; and the following output:\n$data\n&quot;);
+    return $retval;
+  }
+
+  if ( $coll-&gt;productData()-&gt;getInfo(&quot;CREATE_REPOMD&quot;) == &quot;true&quot; ) {
+    foreach my $p (@paths) {
+      my $cmd = &quot;$this-&gt;{m_createrepo} $p/$datadir &quot;;
+      $this-&gt;logMsg(&quot;I&quot;, &quot;Executing command &lt;$cmd&gt;&quot;);
+      my $data = qx( $cmd );
+      my $status = $? &gt;&gt; 8;
+      if($status) {
+        $this-&gt;logMsg(&quot;E&quot;, &quot;Calling &lt;$cmd&gt; exited with code &lt;$status&gt; and the following output:\n$data\n&quot;);
+        return $retval;
+      }
+      $cmd = &quot;$this-&gt;{m_rezip} $p/$datadir &quot;;
+      $this-&gt;logMsg(&quot;I&quot;, &quot;Executing command &lt;$cmd&gt;&quot;);
+      my $data = qx( $cmd );
+      my $status = $? &gt;&gt; 8;
+      if($status) {
+        $this-&gt;logMsg(&quot;E&quot;, &quot;Calling &lt;$cmd&gt; exited with code &lt;$status&gt; and the following output:\n$data\n&quot;);
+        return $retval;
+      }
+    }
+  }
+
+  foreach my $trans (glob('/usr/share/locale/en_US/LC_MESSAGES/package-translations-*.mo')) {
+     $trans = basename($trans, &quot;.mo&quot;);
+     $trans =~ s,.*-,,;
+     my $cmd = &quot;/usr/bin/translate_packages.pl $trans &lt; $targetdir/packages.en &gt; $targetdir/packages.$trans&quot;;
+     my $data = qx( $cmd );
+     if($? &gt;&gt; 8) {
+	 $this-&gt;logMsg(&quot;E&quot;, &quot;Calling &lt;translate_packages.pl $trans &gt; failed:\n$data\n&quot;);
+	 return 1;
+     }
+  }
+
+  if($this-&gt;{m_compress} =~ m{yes}i) {
+      foreach my $pfile(glob(&quot;$targetdir/packages*&quot;)) {
+	  if(system(&quot;gzip&quot;, &quot;$pfile&quot;) == 0) {
+	      unlink &quot;$targetdir/$pfile&quot;;
+	  }
+	  else {
+	      $this-&gt;logMsg(&quot;W&quot;, &quot;Can't compress file &lt;$targetdir/$pfile&gt;!&quot;);
+	  }
+      }
+  }
+
+  return 1;
+}
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.ini
new file mode 100644
index 0000000..b371984
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.ini
@@ -0,0 +1,14 @@
+# INI file for KIWIMiniIsoPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWILiveTreePlugin
+order = 6
+defaultenable = 1
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.pm
new file mode 100644
index 0000000..ba16dbc
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWILiveTreePlugin.pm
@@ -0,0 +1,167 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWILiveTreePlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module patching mini iso builds
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWILiveTreePlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Data::Dumper;
+use Config::IniFiles;
+use File::Find;
+use File::Basename;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWILiveTreePlugin object
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = content
+  #targetdir = $PRODUCT_DIR
+  #media = (list of numbers XOR &quot;all&quot;)
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($enable)
+    ) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  return $this;
+}
+# /constructor
+
+sub logandrename($$$$)
+{
+  my $this = shift;
+  my $dname = shift;
+  my $oname = shift;
+  my $nname = shift;
+  $this-&gt;logMsg(&quot;I&quot;, &quot;Renaming $dname/$oname to $dname/$nname&quot;);
+  rename(&quot;$dname/$oname&quot;, &quot;$dname/$nname&quot;) || die &quot;no such file!&quot;;
+}
+
+# returns: number of patched gfxboot files
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $ismini = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;FLAVOR&quot;);
+  if(not defined($ismini)) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;FLAVOR not set?&quot;);
+    return $retval;
+  }
+  if($ismini !~ m{livetree}i) {
+    return $retval;
+  }
+
+  my $x11cd = undef;
+  find( sub { if (m/kiwi-profiled-livecd-kde.i586.iso/) { $x11cd = $File::Find::name; }  }, $this-&gt;handler()-&gt;collect()-&gt;basedir());
+  if (!$x11cd) {
+	$this-&gt;logMsg(&quot;E&quot;, &quot;Initial CD not found\n&quot;);
+	exit(1);
+  }
+  print &quot;$x11cd\n&quot;;
+  my $dname = dirname($x11cd);
+  print &quot;$dname\n&quot;;
+  my $base = basename($dname);
+  $base =~ s,openSUSE-Live-Tree-i586-x86_64,,;
+
+  #logandrename($this, $dname, &quot;kiwi-profiled-livecd-x11.i586.iso&quot;, &quot;openSUSE-X11-LiveCD-i686-$base.iso&quot;);
+  #logandrename($this, $dname, &quot;kiwi-profiled-livecd-x11.x86_64.iso&quot;, &quot;openSUSE-X11-LiveCD-x86_64-$base.iso&quot;);
+  logandrename($this, $dname, &quot;kiwi-profiled-livecd-kde.i586.iso&quot;, &quot;openSUSE-KDE4-LiveCD-i686$base.iso&quot;);
+  logandrename($this, $dname, &quot;kiwi-profiled-livecd-kde.x86_64.iso&quot;, &quot;openSUSE-KDE4-LiveCD-x86_64$base.iso&quot;);
+  logandrename($this, $dname, &quot;kiwi-profiled-livecd-gnome.i586.iso&quot;, &quot;openSUSE-GNOME-LiveCD-i686$base.iso&quot;);
+  logandrename($this, $dname, &quot;kiwi-profiled-livecd-gnome.x86_64.iso&quot;, &quot;openSUSE-GNOME-LiveCD-x86_64$base.iso&quot;);
+
+  return $retval;
+}
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.ini
new file mode 100644
index 0000000..3796700
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.ini
@@ -0,0 +1,14 @@
+# INI file for KIWIMiniIsoPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIMiniIsoPlugin
+order = 5
+defaultenable = 1
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.pm
new file mode 100644
index 0000000..246e57e
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIMiniIsoPlugin.pm
@@ -0,0 +1,253 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWIMiniIsoPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module patching mini iso builds
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIMiniIsoPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Data::Dumper;
+use Config::IniFiles;
+use File::Find;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIMiniIsoPlugin object
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIEulaPlugin
+  #order = 3
+  #defaultenable = 1
+  #
+  #[target]
+  #targetfile = content
+  #targetdir = $PRODUCT_DIR
+  #media = (list of numbers XOR &quot;all&quot;)
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name	= $ini-&gt;val('base', 'name'); # scalar value
+  my $order	= $ini-&gt;val('base', 'order'); # scalar value
+  my $enable	= $ini-&gt;val('base', 'defaultenable'); # scalar value
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not defined($enable)
+    ) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  return $this;
+}
+# /constructor
+
+
+
+# returns: number of patched gfxboot files
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $repoloc = $this-&gt;collect()-&gt;productData()-&gt;getOpt(&quot;REPO_LOCATION&quot;);
+  my $ismini = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;FLAVOR&quot;);
+  if(not defined($ismini)) {
+    $this-&gt;logMsg(&quot;W&quot;, &quot;FLAVOR not set?&quot;);
+    return $retval;
+  }
+  if($ismini !~ m{mini}i) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Nothing to for for media type &lt;$ismini&gt;&quot;);
+    return $retval;
+  }
+
+  my ($srv, $path);
+  if(not defined($repoloc)) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;&lt;REPO_LOCATION&gt; is unset, boot protocol will be set to 'slp'!&quot;);
+  }
+  else {
+    $repoloc =~ m{^<A HREF="http://([^/">http://([^/</A>]+)/(.+)};
+    ($srv, $path) = ($1, $2);
+    if(not defined($srv) or not defined($path)) {
+      $this-&gt;logMsg(&quot;W&quot;, &quot;Parsing repo-location=&lt;$repoloc&gt; failed!&quot;);
+      return $retval;
+    }
+  }
+
+  my @gfxbootfiles;
+  find( sub { find_cb($this, '.*/gfxboot\.cfg$', \@gfxbootfiles) }, $this-&gt;handler()-&gt;collect()-&gt;basedir());
+  my @rootfiles;
+  find( sub { find_cb($this, '.*/root$', \@rootfiles) }, $this-&gt;handler()-&gt;collect()-&gt;basedir());
+
+  foreach(@rootfiles) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;removing file &lt;$_&gt;&quot;);
+    unlink $_;
+  }
+
+  if(!@gfxbootfiles) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;No gfxboot.cfg file found! This _MIGHT_ be ok for S/390! Please verify &lt;installation-images&gt; package(s)!&quot;);
+    return $retval;
+  }
+
+  foreach my $cfg(@gfxbootfiles) {
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Processing file &lt;$cfg&gt;: &quot;);
+    if(not open(F, &quot;&lt;&quot;, $cfg)) {
+      $this-&gt;logMsg(&quot;E&quot;, &quot;Cant open file &lt;$cfg&gt;!&quot;);
+      next;
+    }
+    my @lines = &lt;F&gt;;
+    close(F);
+    chomp(@lines);
+    my $install = -1;
+    my $ihs = -1;
+    my $ihp = -1;
+    my $i = -1;
+    foreach my $line(@lines) {
+      $i++;
+      next if $line !~ m{^install};
+      if($line =~ m{^install=.*}) {
+	$install = $i;
+      }
+      if($line =~ m{^install.http.server=+}) {
+	$ihs = $i;
+      }
+      if($line =~ m{^install.http.path=+}) {
+	$ihp = $i;
+      }
+    }
+
+    if(!$repoloc) {
+      if($install == -1) {
+	push @lines, &quot;install=slp&quot;;
+      }
+      else {
+	$lines[$install] =~ s{^install.*}{install=slp};
+      }
+    }
+    elsif($srv) {
+      if($ihs == -1) {
+	push @lines, &quot;install.http.server=$srv&quot;;
+      }
+      else {
+	$lines[$ihs] =~ s{^(install.http.server).*}{$1=$srv};
+      }
+      if($ihp == -1) {
+	push @lines, &quot;install.http.path=$path&quot;;
+      }
+      else {
+	$lines[$ihp] =~ s{^(install.http.path).*}{$1=$path};
+      }
+      if($install == -1) {
+	push @lines, &quot;install=http&quot;;
+      }
+      else {
+	$lines[$install] =~ s{^install.*}{install=http};
+      }
+    }
+    unlink $cfg;
+    open(F, &quot;&gt;&quot;, $cfg);
+    foreach(@lines) {
+      print F &quot;$_\n&quot;;
+    }
+    close(F);
+    $retval++;
+  }
+  return $retval;
+}
+
+
+
+sub find_cb
+{
+  my $this = shift;
+  return undef if not ref($this);
+
+  my $pat = shift;
+  my $listref = shift;
+  if(not defined($listref) or not defined($pat)) {
+    return undef;
+  }
+
+  #if($File::Find::name =~ m{.*/gfxboot\.cfg$}) {
+  if($File::Find::name =~ m{$pat}) {
+    push @{$listref}, $File::Find::name;
+  }
+}
+
+
+
+1;
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.ini b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.ini
new file mode 100644
index 0000000..45e14a5
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.ini
@@ -0,0 +1,20 @@
+# INI file for KIWIPatternsPlugin.pm
+# Written by Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+# Provides configuration for the plugin:
+# - required binaries
+# - required directories
+# - target file name
+# - unique order number
+# - package name providing the required binaries, if packaged
+
+[base]
+name = KIWIPatternsPlugin
+dir = $DATADIR/setup/descr
+order = 1
+defaultenable = 1
+media = 1
+
+[target]
+targetfile = patterns
+compress = yes
+
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.pm b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.pm
new file mode 100644
index 0000000..180dbc3
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/KIWIPatternsPlugin.pm
@@ -0,0 +1,183 @@
+################################################################
+# Copyright (c) 2008 Jan-Christoph Bornschlegel, Novell Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program (see the file LICENSE); if not, write to the
+# Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+#
+################################################################
+
+#================
+# FILE          : KIWIPatternsPlugin.pm
+#----------------
+# PROJECT       : OpenSUSE Build-Service
+# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
+#               :
+# AUTHOR        : Jan-Christoph Bornschlegel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">jcborn at suse.de</A>&gt;
+#               :
+# BELONGS TO    : Operating System images
+#               :
+# DESCRIPTION   : Module creating the &quot;patterns&quot; file
+#               :
+# STATUS        : Development
+#----------------
+
+package KIWIPatternsPlugin;
+
+use strict;
+
+use base &quot;KIWIBasePlugin&quot;;
+use Config::IniFiles;
+
+
+sub new
+{
+  # ...
+  # Create a new KIWIPatternsPlugin object
+  # creates patterns file
+  # ---
+  my $class   = shift;
+  my $handler = shift;
+  my $config  = shift;
+
+  my $this = new KIWIBasePlugin($handler);
+  bless ($this, $class);
+
+  $config =~ m{(.*)/([^/]+)$};
+  my $configpath = $1;
+  my $configfile = $2;
+  if(not defined($configpath) or not defined($configfile)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;wrong parameters in plugin initialisation\n&quot;);
+    return undef;
+  }
+
+  ## now gather all necessary information from the inifile:
+  #===
+  # Issue: why duplicate code here? Why not put it into the base class?
+  # Answer: Each plugin may have different options. Some only need a target filename,
+  # whilst some others may need much more. I don't want to specify a complicated framework
+  # for the plugin, it shall just be a simple straightforward way to get information
+  # into the plugin. The idea is that the people who decide on the metadata write
+  # the plugin, and therefore damn well know what it needs and what not.
+  # I'm definitely not bothering PMs with Yet Another File Specification (tm)
+  #---
+
+  ## plugin content:
+  #-----------------
+  #[base]
+  #name = KIWIPatternsPlugin
+  #dir = $DATADIR/setup/descr
+  #order = 1
+  #tool = create_package_descr
+  #tooldir = /usr/bin
+  #toolpack = inst-source-utils
+  #defaultenabled = 1
+  #media = 1
+  #
+  #[target]
+  #targetfile = patterns
+  #compress = yes|no
+  #
+  my $ini = new Config::IniFiles( -file =&gt; &quot;$configpath/$configfile&quot; );
+  my $name    = $ini-&gt;val('base', 'name'); # scalar value
+  my $order   = $ini-&gt;val('base', 'order'); # scalar value
+  my @dirs    = $ini-&gt;val('base', 'dir');	# here may be more than one
+  my $enable  = $ini-&gt;val('base', 'defaultenable'); # scalar value
+  my @media   = $ini-&gt;val('base', 'media'); # here may be a list again
+
+  my $target  = $ini-&gt;val('target', 'targetfile');
+  my $gzip    = $ini-&gt;val('target', 'compress');
+
+  # if any of those isn't set, complain!
+  if(not defined($name)
+     or not defined($order)
+     or not @dirs
+     or not defined($enable)
+     or not defined($target)
+     or not defined($gzip)
+     or not @media) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;Plugin ini file &lt;$config&gt; seems broken!\n&quot;);
+    return undef;
+  }
+
+  # parse dirs for productvars content:
+  for(my $i=0; $i &lt;= $#dirs; $i++) {
+    $dirs[$i] = $this-&gt;collect()-&gt;productData()-&gt;_substitute(&quot;$dirs[$i]&quot;);
+  }
+
+  $this-&gt;name($name);
+  $this-&gt;order($order);
+  $this-&gt;requiredDirs(@dirs);
+  $this-&gt;{m_media} = @media;
+  if($enable != 0) {
+    $this-&gt;ready(1);
+  }
+  $this-&gt;{m_compress} = $gzip;
+  $this-&gt;{m_target} = $target;
+
+  return $this;
+}
+# /constructor
+
+
+
+sub execute
+{
+  my $this = shift;
+  if(not ref($this)) {
+    return undef;
+  }
+  my $retval = 0;
+  # sanity check:
+  if($this-&gt;{m_ready} == 0) {
+    return $retval;
+  }
+
+  my $dirname = $this-&gt;{m_handler}-&gt;baseurl().&quot;/&quot;.$this-&gt;{m_handler}-&gt;mediaName();
+  my $mult = $this-&gt;collect()-&gt;productData()-&gt;getVar(&quot;MULTIPLE_MEDIA&quot;);
+  if( $mult ne &quot;no&quot;) {
+    $dirname .= $this-&gt;{m_media};
+  }
+  $dirname .= &quot;/&quot;.$this-&gt;{m_requireddirs}-&gt;[0];
+
+  if(!opendir(PATDIR, &quot;$dirname&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;PatternsPlugin: cannot read &lt;$dirname&gt;&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;&quot;);
+    return $retval;
+  }
+  if(!open(PAT, &quot;&gt;&quot;, &quot;$dirname/$this-&gt;{m_target}&quot;)) {
+    $this-&gt;logMsg(&quot;E&quot;, &quot;PatternsPlugin: cannot create &lt;$dirname&gt;/patterns!&quot;);
+    $this-&gt;logMsg(&quot;I&quot;, &quot;Skipping plugin &lt;&quot;.$this-&gt;name().&quot;&gt;&quot;);
+    return $retval;
+  }
+  my @dirent = readdir(PATDIR);
+  foreach my $f(@dirent) {
+    next if $f !~ m{(.*\.pat|.*\.pat\.gz)};
+    if($f !~ m{.*\.gz$} and $this-&gt;{m_compress} =~ m{yes}i) {
+      if (system('gzip', &quot;$dirname/$f&quot;) == 0) {
+	$f = &quot;$f.gz&quot;;
+      }
+    }
+    print PAT &quot;$f\n&quot;;
+  }
+  close(PATDIR);	
+  close(PAT);	
+
+  $retval = 1;
+  return $retval;
+}
+
+
+
+1;
+
diff --git a/LICENSE b/distribution/kiwi-instsource-plugins-openSUSE-11-2/LICENSE
old mode 100755
new mode 100644
similarity index 100%
copy from LICENSE
copy to distribution/kiwi-instsource-plugins-openSUSE-11-2/LICENSE
diff --git a/distribution/kiwi-instsource-plugins-openSUSE-11-2/Makefile b/distribution/kiwi-instsource-plugins-openSUSE-11-2/Makefile
new file mode 100644
index 0000000..48d263f
--- /dev/null
+++ b/distribution/kiwi-instsource-plugins-openSUSE-11-2/Makefile
@@ -0,0 +1,25 @@
+# /.../
+# Copyright (c) 2006 SUSE LINUX Products GmbH. All rights reserved.
+# Author: Marcus Schaefer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">ms at suse.de</A>&gt;, 2006
+#
+# Makefile for OpenSuSE - KIWI Image System InstSource Plugins
+# ---
+buildroot = /
+kiwi_prefix = ${buildroot}/usr/share/kiwi/
+
+#============================================
+# Variables... 
+#--------------------------------------------
+KIWIPLUGINVZ  = ${kiwi_prefix}/modules/plugins/suse-11.2
+
+install:
+	#============================================
+	# Install base directories
+	#--------------------------------------------
+	install -d -m 755 ${KIWIPLUGINVZ}
+
+	#============================================
+	# Install plugins
+	#--------------------------------------------
+	install -m 644 ./*.pm  ${KIWIPLUGINVZ}
+	install -m 644 ./*.ini ${KIWIPLUGINVZ}


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001646.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 7f462113c37ae034b976c4cae45c84fa4a2ff700
</A></li>
	<LI>Next message: <A HREF="001647.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. ce47e8c55dcc4934d284d0656b53dc75911241ed
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1652">[ date ]</a>
              <a href="thread.html#1652">[ thread ]</a>
              <a href="subject.html#1652">[ subject ]</a>
              <a href="author.html#1652">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
