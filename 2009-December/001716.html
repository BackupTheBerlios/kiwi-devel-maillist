<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/kiwi-devel/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf&In-Reply-To=%3C200912140815.nBE8FbQ6009041%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001715.html">
   <LINK REL="Next"  HREF="001693.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf</H1>
    <B>mbarringer at BerliOS</B> 
    <A HREF="mailto:kiwi-devel%40lists.berlios.de?Subject=Re%3A%20%5BKiwi-devel%5D%20%5BGit%5DProject%20kiwi%20at%20BerliOS%20branch%2C%20master%2C%0A%09updated.%20e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf&In-Reply-To=%3C200912140815.nBE8FbQ6009041%40sheep.berlios.de%3E"
       TITLE="[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf">mbarringer at mail.berlios.de
       </A><BR>
    <I>Mon Dec 14 09:15:37 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001715.html">[Kiwi-devel] image creation problem
</A></li>
        <LI>Next message: <A HREF="001693.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 42cbf60d78be7aed683957087405d1ca6eb48c94
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1716">[ date ]</a>
              <a href="thread.html#1716">[ thread ]</a>
              <a href="subject.html#1716">[ subject ]</a>
              <a href="author.html#1716">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Project kiwi at BerliOS&quot;.

The branch, master has been updated
       via  e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf (commit)
      from  ee42f983f98a8fcf41f3e68ce2c68987b5b6ff4c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e4321ffc45d000f42a87ecf1bb87fc33c1fd69cf
Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
Date:   Mon Dec 14 09:15:01 2009 +0100

    - Removing cross-platform support from the Qt imagewriter
    - Adding native Windows imagewriter

-----------------------------------------------------------------------

Summary of changes:
diff --git a/tools/burner/MainWindow.cpp b/tools/burner/MainWindow.cpp
index 1e028bd..fe20f9d 100644
--- a/tools/burner/MainWindow.cpp
+++ b/tools/burner/MainWindow.cpp
@@ -52,10 +52,6 @@ MainWindow::MainWindow (const char *cmddevice,
     // Setup the platform-specific bits
 #if defined (Q_OS_LINUX)
     platform = new PlatformLinux;
-#elif defined (Q_OS_WIN)
-    platform = new PlatformWindows;
-#elif defined (Q_OS_MAC)
-    platform = new PlatformMacintosh;
 #else
     QMessageBox msgBox;
     msgBox.setText(tr(&quot;Your platform is not currently supported.&quot;));
diff --git a/tools/burner/MainWindow.h b/tools/burner/MainWindow.h
index e5e1d96..4ed2589 100644
--- a/tools/burner/MainWindow.h
+++ b/tools/burner/MainWindow.h
@@ -33,14 +33,6 @@
 #include &quot;PlatformLinux.h&quot;
 #endif
 
-#if defined (Q_OS_WIN)
-#include &quot;PlatformWindows.h&quot;
-#endif
-
-#if defined (Q_OS_MAC)
-#include &quot;PlatformMac.h&quot;
-#endif
-
 #include &quot;DeviceItem.h&quot;
 #define VERSION &quot;SUSE Studio Image Writer 1.3&quot;
 
diff --git a/tools/burner/PlatformMac.cpp b/tools/burner/PlatformMac.cpp
deleted file mode 100644
index beef5ac..0000000
--- a/tools/burner/PlatformMac.cpp
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- *  Copyright (c) 2009 Novell, Inc.
- *  All Rights Reserved.
- *  
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, contact Novell, Inc.
- *  
- *  To contact Novell about this file by physical or electronic mail,
- *  you may find current contact information at www.novell.com
- *  
- *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
- *  
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;sys/param.h&gt;
-#include &lt;sys/mount.h&gt;
-
-#include &lt;fcntl.h&gt;
-#include &lt;errno.h&gt;
-
-#include &lt;QtGui&gt;
-#include &lt;CoreFoundation/CoreFoundation.h&gt;
-#include &lt;CoreServices/CoreServices.h&gt;
-
-#include &lt;IOKit/IOKitLib.h&gt;
-#include &lt;IOKit/IOCFPlugIn.h&gt; 
-#include &lt;IOKit/IOBSD.h&gt; 
-
-#include &quot;PlatformMac.h&quot;
-#include &quot;DeviceItem.h&quot;
-
-#define BLOCKSIZE 1048576
-
-void
-PlatformMacintosh::findDevices(bool unsafe)
-{
-    kern_return_t ret;
-    io_registry_entry_t entry;
-    io_iterator_t iterator;
-    io_name_t devName;
-    CFStringRef bsdname;
-    CFNumberRef data;
-    SInt64 capacity = 0;
-
-    // Search for USB devices
-    // TODO: Pay attention to the unsafe flag
-    CFMutableDictionaryRef dict = NULL;
-    dict = IOServiceMatching(&quot;IOUSBDevice&quot;);
-
-    ret = IOServiceGetMatchingServices(kIOMasterPortDefault, dict, &amp;iterator);
-
-    entry = IOIteratorNext(iterator);
-    while (entry)
-    {
-        bsdname = (CFStringRef) IORegistryEntrySearchCFProperty(entry, kIOServicePlane, CFSTR(kIOBSDNameKey), kCFAllocatorDefault, kIORegistryIterateRecursively);
-        data = (CFNumberRef) IORegistryEntrySearchCFProperty(entry, kIOServicePlane, CFSTR(&quot;Size&quot;), kCFAllocatorDefault, kIORegistryIterateRecursively);
-        if (bsdname) // If we can't look up &quot;BSD name&quot; then it isn't a removable device
-        {
-            IORegistryEntryGetName(entry, devName);
-            DeviceItem *devItem = new DeviceItem;
-            
-            if (data)
-            {
-                CFNumberGetValue(data, kCFNumberSInt64Type, &amp;capacity );
-                devItem-&gt;setSize(capacity);
-            }
-            devItem-&gt;setVendorString(devName);
-
-            QString newDevString = QString(&quot;/dev/%1&quot;).arg(CFStringGetCStringPtr(bsdname, kCFStringEncodingMacRoman));
-            devItem-&gt;setPath(newDevString);
-            devItem-&gt;setUDI(newDevString);
-
-            QString newDisplayString = QString(&quot;%1 - %2 (%3 MB)&quot;).arg(devItem-&gt;getVendorString()).arg(devItem-&gt;getPath()).arg(devItem-&gt;getSize() / 1048576);
-            devItem-&gt;setDisplayString(newDisplayString);
-            itemList &lt;&lt; devItem;
-        }
-        entry = IOIteratorNext(iterator);
-    }
-}
- 
-bool
-PlatformMacintosh::isMounted(QString path)
-{
-    unsigned int mounts = 0;
-    struct statfs *fsStats=NULL;
-
-    mounts = getmntinfo(&amp;fsStats, MNT_NOWAIT);
-    if (mounts)
-        return(true);
-    return(false);
-}
-
-bool
-PlatformMacintosh::unmountDevice(QString path)
-{
-    int mounts = 0;
-    int i;
-    int len = path.length();
-    struct statfs *fsStats=NULL;
-    FSRef volFSRef;
-    FSCatalogInfo volumeInfo;
-
-    mounts = getmntinfo(&amp;fsStats, MNT_NOWAIT);
-    if (mounts)
-    {
-        for (i = 0; i &lt; mounts; i++)
-        {
-            if ((!memcmp(path.toLocal8Bit().data(), &amp;fsStats[i].f_mntfromname[0], len)) // First check the path
-                &amp;&amp; (!isdigit(fsStats[i].f_mntfromname[len]))) // Then make sure we're not going to really mess things up
-            {
-                qDebug() &lt;&lt; &quot;Will try to unmount &quot; &lt;&lt; &amp;fsStats[i].f_mntfromname[0];
-                if (FSPathMakeRef((UInt8 *) fsStats[i].f_mntonname, &amp;volFSRef, NULL) != noErr)
-                    return(false);
-
-                if (FSGetCatalogInfo(&amp;volFSRef, kFSCatInfoVolume, &amp;volumeInfo, NULL, NULL, NULL) != noErr)
-                    return(false);
-
-                if (FSUnmountVolumeSync(volumeInfo.volume, 0, NULL) != noErr)
-                    return(false);
-            }
-        }
-    }
-    return(true);
-}
-
-void
-PlatformMacintosh::writeData(QString path, QString fileName, qint64 deviceSize)
-{
-    QFileInfo info(fileName);
-    qint64 realSize = info.size();
-
-    if (realSize &gt; deviceSize)
-    {
-        QMessageBox msgBox;
-        msgBox.setText(QObject::tr(&quot;The image you are trying to write is larger than your USB stick.&quot;));
-        msgBox.exec();
-        return;
-    }
-
-    qint64 i = 0;
-    char *buffer = (char *) malloc(BLOCKSIZE);
-    qint64 read = 0;
-    qint64 written = 0;
-
-    int ofd = -1;
-    int ifd = -1;
-
-    int percentWritten, megsWritten, megsTotal;
-    megsTotal = realSize / 1048576;
-
-    // Open the file to read from 
-    if ((ifd = ::open(fileName.toLocal8Bit().data(), O_RDONLY)) == -1)
-    {
-        qDebug() &lt;&lt; &quot;Couldn't open &quot; + fileName;
-        return;
-    }
-
-    if ((ofd = ::open(path.toLocal8Bit().data(), O_WRONLY|O_SYNC)) == -1)
-    {
-        // TODO complain
-        qDebug() &lt;&lt; &quot;Couldn't open &quot; + path + &quot;: &quot; + strerror(errno);
-        ::close(ifd);
-        return;
-    }
-
-    QProgressDialog progress(&quot; &quot;, &quot;Cancel&quot;, 0, 100);
-    progress.setMinimumDuration(0);
-    progress.setWindowModality(Qt::WindowModal);
-    progress.setValue(100);
-    progress.setWindowTitle(QObject::tr(&quot;Writing Image...&quot;));
-
-    for (i = 0; i &lt;= realSize; i++)
-    {
-        if ((read = ::read(ifd, buffer, BLOCKSIZE)) == -1)
-        {
-            qDebug() &lt;&lt; &quot;Uh oh&quot;;
-            break;
-        }
-
-        written = ::write(ofd, buffer, read);
-        if (written == -1)
-        {
-            qDebug() &lt;&lt; &quot;Hit a problem at &quot; &lt;&lt; i;
-            break;
-        }
-
-        i += written;
-        percentWritten = (i*100)/realSize;
-        megsWritten = i / 1048576;
-        progress.setValue(percentWritten);
-        progress.setLabelText(QObject::tr(&quot;Written %1MB out of %2MB&quot;).arg(megsWritten).arg(megsTotal));
-        qApp-&gt;processEvents();
-
-        if (progress.wasCanceled())
-             break;
-     }
-    ::close(ofd);
-    ::close(ifd);
-    free(buffer);
-    progress.setValue(100);
-
-    return;
-}
-
diff --git a/tools/burner/PlatformMac.h b/tools/burner/PlatformMac.h
deleted file mode 100644
index 70c2901..0000000
--- a/tools/burner/PlatformMac.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Copyright (c) 2009 Novell, Inc.
- *  All Rights Reserved.
- *  
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, contact Novell, Inc.
- *  
- *  To contact Novell about this file by physical or electronic mail,
- *  you may find current contact information at www.novell.com
- *  
- *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
- *  
- */
-
-#ifndef __PLATFORM_MACINTOSH_H__
-#define __PLATFORM_MACINTOSH_H__
-
-#include &quot;Platform.h&quot;
-
-class PlatformMacintosh : public Platform
-{
-public:
-    PlatformMacintosh() { };
-    // Override the Platform functions
-    void findDevices(bool unsafe = false);
-    bool isMounted(QString path);
-    bool unmountDevice(QString path);
-    void writeData(QString path, QString fileName, qint64 deviceSize);
-};
-
-#endif
-
diff --git a/tools/burner/PlatformWindows.cpp b/tools/burner/PlatformWindows.cpp
deleted file mode 100644
index 1129731..0000000
--- a/tools/burner/PlatformWindows.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- *  Copyright (c) 2009 Novell, Inc.
- *  All Rights Reserved.
- *  
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, contact Novell, Inc.
- *  
- *  To contact Novell about this file by physical or electronic mail,
- *  you may find current contact information at www.novell.com
- *  
- *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
- *  
- */
-
-#include &lt;QtGui&gt;
-
-#include &quot;PlatformWindows.h&quot;
-
-#define NUM_HOST_CONTROLLER_CHECKS 10
-
-void
-PlatformWindows::findDevices()
-{
-    wchar_t controllerName[16];
-    int controllerNum;
-    HANDLE controllerHandle;
-
-    // There appear to be two ways of finding USB devices on Windows: iterate through
-    // a bunch of shit like &quot;\\.\HCD1&quot; and iterate using GUIDs.
-
-    // We have to do a trial and error method of finding the USB host controllers
-    // which pretty much means &quot;try to open every possible device name and see what happens&quot;.
-    // This may be sub-optimal.
-    for (controllerNum = 0; controllerNum &lt; NUM_HOST_CONTROLLER_CHECKS; controllerNum++)
-    {
-        wsprintf(controllerName, L&quot;\\\\.\\HCD%d&quot;, controllerNum);
-        controllerHandle = CreateFile(controllerName,
-                                      GENERIC_WRITE,
-                                      FILE_SHARE_WRITE,
-                                      NULL,
-                                      OPEN_EXISTING,
-                                      0,
-                                      NULL);
-
-        // Is the handler valid?
-        if (controllerHandle != INVALID_HANDLE_VALUE)
-        {
-            // Super, we found a controller.  Lets see what devices are attached...
-            examineController(controllerHandle);
-            CloseHandle(controllerHandle);
-        }
-    }
-
-    // TODO: GUID iteration
-}
-
-void
-PlatformWindows::examineController(HANDLE controllerHandle)
-{
-    return;
-}
-  
-bool
-PlatformWindows::isMounted(QString path) { return true; }
-
-void
-PlatformWindows::writeData(QString path, QString fileName, qint64 deviceSize) { return; }
diff --git a/tools/burner/PlatformWindows.h b/tools/burner/PlatformWindows.h
deleted file mode 100644
index 046517d..0000000
--- a/tools/burner/PlatformWindows.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- *  Copyright (c) 2009 Novell, Inc.
- *  All Rights Reserved.
- *  
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, contact Novell, Inc.
- *  
- *  To contact Novell about this file by physical or electronic mail,
- *  you may find current contact information at www.novell.com
- *  
- *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
- *  
- */
-
-#ifndef __PLATFORM_WINDOWS_H__
-#define __PLATFORM_WINDOWS_H__
-
-#include &lt;windows.h&gt;
-#include &lt;basetyps.h&gt;
-#include &lt;winioctl.h&gt;
-#include &lt;setupapi.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;tchar.h&gt;
-
-#include &quot;Platform.h&quot;
-
-class PlatformWindows : public Platform
-{
-
-public:
-    PlatformWindows() { };
-    // Override the Platform functions
-    void findDevices();
-    bool isMounted(QString path);
-    void writeData(QString path, QString fileName, qint64 deviceSize);
-
-private:
-    void examineController(HANDLE controllerHandle);
-
-};
-
-
-#endif
diff --git a/tools/burner/imagewriter.pro b/tools/burner/imagewriter.pro
index aa8ecff..309963c 100644
--- a/tools/burner/imagewriter.pro
+++ b/tools/burner/imagewriter.pro
@@ -11,25 +11,9 @@ INCLUDEPATH += .
 HEADERS += DeviceItem.h \
            MainWindow.h \
            Platform.h \
-           PlatformLinux.h \
-           PlatformWindows.h \
-           PlatformMac.h
+           PlatformLinux.h
 SOURCES += main.cpp MainWindow.cpp Platform.cpp
 
-win32 {
-	SOURCES += PlatformWindows.cpp
-	SDKDIR = $$(WindowsSdkDir)
-	INCLUDEPATH += E:\WINDDK\3790.1830\inc\wxp $$quote($$SDKDIR\..\v6.0A\include)
-	LIBS += user32.lib
-	LIBPATH += $$quote($$SDKDIR\..\v6.0A\Lib)
-}
-
-macx {
-	SOURCES += PlatformMac.cpp
-	CONFIG += x86 ppc
-	LIBS += -framework IOKit
-}
-
 unix:!macx {
 	exists (&quot;/usr/include/hal/libhal.h&quot;)
 	{
diff --git a/tools/burner/windows/ImageWriter.sln b/tools/burner/windows/ImageWriter.sln
new file mode 100755
index 0000000..8e59228
--- /dev/null
+++ b/tools/burner/windows/ImageWriter.sln
@@ -0,0 +1,20 @@
+&#239;&#187;&#191;
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C# Express 2008
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;ImageWriter&quot;, &quot;ImageWriter\ImageWriter.csproj&quot;, &quot;{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}&quot;
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/tools/burner/windows/ImageWriter.suo b/tools/burner/windows/ImageWriter.suo
new file mode 100755
index 0000000..902d16c
Binary files /dev/null and b/tools/burner/windows/ImageWriter.suo differ
diff --git a/tools/burner/windows/ImageWriter/ImageWriter.csproj b/tools/burner/windows/ImageWriter/ImageWriter.csproj
new file mode 100755
index 0000000..2ae8a33
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/ImageWriter.csproj
@@ -0,0 +1,156 @@
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;Project ToolsVersion=&quot;3.5&quot; DefaultTargets=&quot;Build&quot; xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+  &lt;PropertyGroup&gt;
+    &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
+    &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;AnyCPU&lt;/Platform&gt;
+    &lt;ProductVersion&gt;9.0.30729&lt;/ProductVersion&gt;
+    &lt;SchemaVersion&gt;2.0&lt;/SchemaVersion&gt;
+    &lt;ProjectGuid&gt;{C0D5F4B2-DFB9-4A71-9A3C-8EF8805150A3}&lt;/ProjectGuid&gt;
+    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
+    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
+    &lt;RootNamespace&gt;ImageWriter&lt;/RootNamespace&gt;
+    &lt;AssemblyName&gt;ImageWriter&lt;/AssemblyName&gt;
+    &lt;TargetFrameworkVersion&gt;v2.0&lt;/TargetFrameworkVersion&gt;
+    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
+    &lt;IsWebBootstrapper&gt;false&lt;/IsWebBootstrapper&gt;
+    &lt;TargetZone&gt;LocalIntranet&lt;/TargetZone&gt;
+    &lt;GenerateManifests&gt;false&lt;/GenerateManifests&gt;
+    &lt;ApplicationManifest&gt;Properties\app.manifest&lt;/ApplicationManifest&gt;
+    &lt;ManifestCertificateThumbprint&gt;ABD1B0FBDBD6B09738154768097E91944821F0C8&lt;/ManifestCertificateThumbprint&gt;
+    &lt;ManifestKeyFile&gt;ImageWriter_TemporaryKey.pfx&lt;/ManifestKeyFile&gt;
+    &lt;SignManifests&gt;true&lt;/SignManifests&gt;
+    &lt;TargetFrameworkSubset&gt;
+    &lt;/TargetFrameworkSubset&gt;
+    &lt;PublishUrl&gt;C:\Users\matt\Desktop\ImageWriter\&lt;/PublishUrl&gt;
+    &lt;Install&gt;true&lt;/Install&gt;
+    &lt;InstallFrom&gt;Disk&lt;/InstallFrom&gt;
+    &lt;UpdateEnabled&gt;false&lt;/UpdateEnabled&gt;
+    &lt;UpdateMode&gt;Foreground&lt;/UpdateMode&gt;
+    &lt;UpdateInterval&gt;7&lt;/UpdateInterval&gt;
+    &lt;UpdateIntervalUnits&gt;Days&lt;/UpdateIntervalUnits&gt;
+    &lt;UpdatePeriodically&gt;false&lt;/UpdatePeriodically&gt;
+    &lt;UpdateRequired&gt;false&lt;/UpdateRequired&gt;
+    &lt;MapFileExtensions&gt;true&lt;/MapFileExtensions&gt;
+    &lt;ApplicationRevision&gt;1&lt;/ApplicationRevision&gt;
+    &lt;ApplicationVersion&gt;1.0.0.%2a&lt;/ApplicationVersion&gt;
+    &lt;UseApplicationTrust&gt;false&lt;/UseApplicationTrust&gt;
+    &lt;PublishWizardCompleted&gt;true&lt;/PublishWizardCompleted&gt;
+    &lt;BootstrapperEnabled&gt;true&lt;/BootstrapperEnabled&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' &quot;&gt;
+    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
+    &lt;DebugType&gt;full&lt;/DebugType&gt;
+    &lt;Optimize&gt;false&lt;/Optimize&gt;
+    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
+    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
+    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
+    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
+    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|AnyCPU' &quot;&gt;
+    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
+    &lt;Optimize&gt;true&lt;/Optimize&gt;
+    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
+    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
+    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
+    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
+    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;Reference Include=&quot;System&quot; /&gt;
+    &lt;Reference Include=&quot;System.Management&quot; /&gt;
+    &lt;Reference Include=&quot;System.Data&quot; /&gt;
+    &lt;Reference Include=&quot;System.Deployment&quot; /&gt;
+    &lt;Reference Include=&quot;System.Drawing&quot; /&gt;
+    &lt;Reference Include=&quot;System.Windows.Forms&quot; /&gt;
+    &lt;Reference Include=&quot;System.Xml&quot; /&gt;
+  &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;Compile Include=&quot;MainWindow.cs&quot;&gt;
+      &lt;SubType&gt;Form&lt;/SubType&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;MainWindow.Designer.cs&quot;&gt;
+      &lt;DependentUpon&gt;MainWindow.cs&lt;/DependentUpon&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;ProgressDialog.cs&quot;&gt;
+      &lt;SubType&gt;Form&lt;/SubType&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;ProgressDialog.Designer.cs&quot;&gt;
+      &lt;DependentUpon&gt;ProgressDialog.cs&lt;/DependentUpon&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;
+    &lt;EmbeddedResource Include=&quot;MainWindow.resx&quot;&gt;
+      &lt;DependentUpon&gt;MainWindow.cs&lt;/DependentUpon&gt;
+    &lt;/EmbeddedResource&gt;
+    &lt;EmbeddedResource Include=&quot;Properties\Resources.resx&quot;&gt;
+      &lt;Generator&gt;ResXFileCodeGenerator&lt;/Generator&gt;
+      &lt;LastGenOutput&gt;Resources.Designer.cs&lt;/LastGenOutput&gt;
+      &lt;SubType&gt;Designer&lt;/SubType&gt;
+    &lt;/EmbeddedResource&gt;
+    &lt;Compile Include=&quot;Properties\Resources.Designer.cs&quot;&gt;
+      &lt;AutoGen&gt;True&lt;/AutoGen&gt;
+      &lt;DependentUpon&gt;Resources.resx&lt;/DependentUpon&gt;
+      &lt;DesignTime&gt;True&lt;/DesignTime&gt;
+    &lt;/Compile&gt;
+    &lt;None Include=&quot;app.config&quot; /&gt;
+    &lt;None Include=&quot;ImageWriter_TemporaryKey.pfx&quot; /&gt;
+    &lt;None Include=&quot;Properties\app.manifest&quot; /&gt;
+    &lt;None Include=&quot;Properties\Settings.settings&quot;&gt;
+      &lt;Generator&gt;SettingsSingleFileGenerator&lt;/Generator&gt;
+      &lt;LastGenOutput&gt;Settings.Designer.cs&lt;/LastGenOutput&gt;
+    &lt;/None&gt;
+    &lt;Compile Include=&quot;Properties\Settings.Designer.cs&quot;&gt;
+      &lt;AutoGen&gt;True&lt;/AutoGen&gt;
+      &lt;DependentUpon&gt;Settings.settings&lt;/DependentUpon&gt;
+      &lt;DesignTimeSharedInput&gt;True&lt;/DesignTimeSharedInput&gt;
+    &lt;/Compile&gt;
+  &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;EmbeddedResource Include=&quot;ProgressDialog.resx&quot;&gt;
+      &lt;DependentUpon&gt;ProgressDialog.cs&lt;/DependentUpon&gt;
+    &lt;/EmbeddedResource&gt;
+  &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Client.3.5&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;.NET Framework Client Profile&lt;/ProductName&gt;
+      &lt;Install&gt;false&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Framework.2.0&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;.NET Framework 2.0 %28x86%29&lt;/ProductName&gt;
+      &lt;Install&gt;false&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Framework.3.0&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;.NET Framework 3.0 %28x86%29&lt;/ProductName&gt;
+      &lt;Install&gt;false&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Framework.3.5&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;.NET Framework 3.5&lt;/ProductName&gt;
+      &lt;Install&gt;false&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Framework.3.5.SP1&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;.NET Framework 3.5 SP1&lt;/ProductName&gt;
+      &lt;Install&gt;true&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+    &lt;BootstrapperPackage Include=&quot;Microsoft.Windows.Installer.3.1&quot;&gt;
+      &lt;Visible&gt;False&lt;/Visible&gt;
+      &lt;ProductName&gt;Windows Installer 3.1&lt;/ProductName&gt;
+      &lt;Install&gt;true&lt;/Install&gt;
+    &lt;/BootstrapperPackage&gt;
+  &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;EmbeddedResource Include=&quot;Resources\logo-suse.png&quot; /&gt;
+  &lt;/ItemGroup&gt;
+  &lt;Import Project=&quot;$(MSBuildToolsPath)\Microsoft.CSharp.targets&quot; /&gt;
+  &lt;!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  &lt;Target Name=&quot;BeforeBuild&quot;&gt;
+  &lt;/Target&gt;
+  &lt;Target Name=&quot;AfterBuild&quot;&gt;
+  &lt;/Target&gt;
+  --&gt;
+&lt;/Project&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/ImageWriter.csproj.user b/tools/burner/windows/ImageWriter/ImageWriter.csproj.user
new file mode 100755
index 0000000..60cd414
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/ImageWriter.csproj.user
@@ -0,0 +1,17 @@
+&#239;&#187;&#191;&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+  &lt;PropertyGroup&gt;
+    &lt;PublishUrlHistory&gt;C:\Users\matt\Desktop\ImageWriter\|c:\deploy\application\|publish\&lt;/PublishUrlHistory&gt;
+    &lt;InstallUrlHistory&gt;
+    &lt;/InstallUrlHistory&gt;
+    &lt;SupportUrlHistory&gt;
+    &lt;/SupportUrlHistory&gt;
+    &lt;UpdateUrlHistory&gt;
+    &lt;/UpdateUrlHistory&gt;
+    &lt;BootstrapperUrlHistory&gt;
+    &lt;/BootstrapperUrlHistory&gt;
+    &lt;ErrorReportUrlHistory&gt;
+    &lt;/ErrorReportUrlHistory&gt;
+    &lt;FallbackCulture&gt;en-US&lt;/FallbackCulture&gt;
+    &lt;VerifyUploadedFiles&gt;false&lt;/VerifyUploadedFiles&gt;
+  &lt;/PropertyGroup&gt;
+&lt;/Project&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/ImageWriter_TemporaryKey.pfx b/tools/burner/windows/ImageWriter/ImageWriter_TemporaryKey.pfx
new file mode 100755
index 0000000..f9e9ae6
Binary files /dev/null and b/tools/burner/windows/ImageWriter/ImageWriter_TemporaryKey.pfx differ
diff --git a/tools/burner/windows/ImageWriter/MainWindow.Designer.cs b/tools/burner/windows/ImageWriter/MainWindow.Designer.cs
new file mode 100755
index 0000000..9c815eb
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/MainWindow.Designer.cs
@@ -0,0 +1,183 @@
+&#239;&#187;&#191;/*
+ *  Copyright (c) 2009 Novell, Inc.
+ *  All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, contact Novell, Inc.
+ *
+ *  To contact Novell about this file by physical or electronic mail,
+ *  you may find current contact information at www.novell.com
+ *
+ *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
+ *
+ */
+
+namespace ImageWriter
+{
+    partial class MainWindow
+    {
+        /// &lt;summary&gt;
+        /// Required designer variable.
+        /// &lt;/summary&gt;
+        private System.ComponentModel.IContainer components = null;
+
+        /// &lt;summary&gt;
+        /// Clean up any resources being used.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;disposing&quot;&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt;
+        protected override void Dispose(bool disposing)
+        {
+            if (disposing &amp;&amp; (components != null))
+            {
+                components.Dispose();
+            }
+            base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// &lt;summary&gt;
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// &lt;/summary&gt;
+        private void InitializeComponent()
+        {
+        this.copyButton = new System.Windows.Forms.Button();
+        this.deviceCombo = new System.Windows.Forms.ComboBox();
+        this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
+        this.imageFilenameLabel = new System.Windows.Forms.Label();
+        this.filePathTextBox = new System.Windows.Forms.TextBox();
+        this.selectButton = new System.Windows.Forms.Button();
+        this.pictureBox1 = new System.Windows.Forms.PictureBox();
+        this.tableLayoutPanel1.SuspendLayout();
+        ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
+        this.SuspendLayout();
+        // 
+        // copyButton
+        // 
+        this.copyButton.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
+                    | System.Windows.Forms.AnchorStyles.Right)));
+        this.copyButton.Location = new System.Drawing.Point(572, 49);
+        this.copyButton.Name = &quot;copyButton&quot;;
+        this.copyButton.Size = new System.Drawing.Size(108, 23);
+        this.copyButton.TabIndex = 0;
+        this.copyButton.Text = &quot;Copy&quot;;
+        this.copyButton.UseVisualStyleBackColor = true;
+        // 
+        // deviceCombo
+        // 
+        this.deviceCombo.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
+                    | System.Windows.Forms.AnchorStyles.Right)));
+        this.tableLayoutPanel1.SetColumnSpan(this.deviceCombo, 2);
+        this.deviceCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
+        this.deviceCombo.FormattingEnabled = true;
+        this.deviceCombo.Location = new System.Drawing.Point(3, 51);
+        this.deviceCombo.Name = &quot;deviceCombo&quot;;
+        this.deviceCombo.Size = new System.Drawing.Size(563, 21);
+        this.deviceCombo.TabIndex = 1;
+        // 
+        // tableLayoutPanel1
+        // 
+        this.tableLayoutPanel1.ColumnCount = 3;
+        this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 18.34061F));
+        this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 81.65939F));
+        this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 113F));
+        this.tableLayoutPanel1.Controls.Add(this.copyButton, 2, 1);
+        this.tableLayoutPanel1.Controls.Add(this.deviceCombo, 0, 1);
+        this.tableLayoutPanel1.Controls.Add(this.imageFilenameLabel, 0, 0);
+        this.tableLayoutPanel1.Controls.Add(this.filePathTextBox, 1, 0);
+        this.tableLayoutPanel1.Controls.Add(this.selectButton, 2, 0);
+        this.tableLayoutPanel1.Location = new System.Drawing.Point(12, 46);
+        this.tableLayoutPanel1.Name = &quot;tableLayoutPanel1&quot;;
+        this.tableLayoutPanel1.RowCount = 2;
+        this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 41.66667F));
+        this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 58.33333F));
+        this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 20F));
+        this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 20F));
+        this.tableLayoutPanel1.Size = new System.Drawing.Size(683, 75);
+        this.tableLayoutPanel1.TabIndex = 2;
+        // 
+        // imageFilenameLabel
+        // 
+        this.imageFilenameLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
+                    | System.Windows.Forms.AnchorStyles.Left)));
+        this.imageFilenameLabel.AutoSize = true;
+        this.imageFilenameLabel.Location = new System.Drawing.Point(3, 0);
+        this.imageFilenameLabel.Name = &quot;imageFilenameLabel&quot;;
+        this.imageFilenameLabel.Size = new System.Drawing.Size(36, 31);
+        this.imageFilenameLabel.TabIndex = 2;
+        this.imageFilenameLabel.Text = &quot;Image&quot;;
+        this.imageFilenameLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
+        // 
+        // filePathTextBox
+        // 
+        this.filePathTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
+        this.filePathTextBox.Location = new System.Drawing.Point(107, 5);
+        this.filePathTextBox.Name = &quot;filePathTextBox&quot;;
+        this.filePathTextBox.ReadOnly = true;
+        this.filePathTextBox.Size = new System.Drawing.Size(459, 20);
+        this.filePathTextBox.TabIndex = 3;
+        // 
+        // selectButton
+        // 
+        this.selectButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
+        this.selectButton.Location = new System.Drawing.Point(572, 4);
+        this.selectButton.Name = &quot;selectButton&quot;;
+        this.selectButton.Size = new System.Drawing.Size(108, 22);
+        this.selectButton.TabIndex = 4;
+        this.selectButton.Text = &quot;Select&quot;;
+        this.selectButton.UseVisualStyleBackColor = true;
+        // 
+        // pictureBox1
+        // 
+        this.pictureBox1.Image = global::ImageWriter.Properties.Resources.logo_suse;
+        this.pictureBox1.Location = new System.Drawing.Point(12, 12);
+        this.pictureBox1.Name = &quot;pictureBox1&quot;;
+        this.pictureBox1.Size = new System.Drawing.Size(123, 28);
+        this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
+        this.pictureBox1.TabIndex = 3;
+        this.pictureBox1.TabStop = false;
+        // 
+        // MainWindow
+        // 
+        this.AllowDrop = true;
+        this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+        this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+        this.ClientSize = new System.Drawing.Size(707, 133);
+        this.Controls.Add(this.pictureBox1);
+        this.Controls.Add(this.tableLayoutPanel1);
+        this.MaximizeBox = false;
+        this.MaximumSize = new System.Drawing.Size(900, 900);
+        this.MinimumSize = new System.Drawing.Size(464, 100);
+        this.Name = &quot;MainWindow&quot;;
+        this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
+        this.Text = &quot;SUSE Studio Image Writer&quot;;
+        this.tableLayoutPanel1.ResumeLayout(false);
+        this.tableLayoutPanel1.PerformLayout();
+        ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
+        this.ResumeLayout(false);
+        this.PerformLayout();
+
+        }
+
+        #endregion
+
+        private System.Windows.Forms.Button copyButton;
+        private System.Windows.Forms.ComboBox deviceCombo;
+        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
+        private System.Windows.Forms.Label imageFilenameLabel;
+        private System.Windows.Forms.TextBox filePathTextBox;
+        private System.Windows.Forms.Button selectButton;
+        private System.Windows.Forms.PictureBox pictureBox1;
+    }
+}
+
diff --git a/tools/burner/windows/ImageWriter/MainWindow.cs b/tools/burner/windows/ImageWriter/MainWindow.cs
new file mode 100755
index 0000000..3fcc52b
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/MainWindow.cs
@@ -0,0 +1,368 @@
+&#239;&#187;&#191;/*
+ *  Copyright (c) 2009 Novell, Inc.
+ *  All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, contact Novell, Inc.
+ *
+ *  To contact Novell about this file by physical or electronic mail,
+ *  you may find current contact information at www.novell.com
+ *
+ *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Text;
+using System.Windows.Forms;
+using System.IO;
+using System.Reflection;
+using System.Management;
+using System.Runtime.InteropServices;
+using System.Threading;
+
+namespace ImageWriter
+{
+    public partial class MainWindow : Form
+    {
+        const int BLOCK_SIZE = 1048576;
+        private String imageFile;
+        private long imageSize;
+        private ImageDevice device;
+        BackgroundWorker copyWorker;
+        ProgressDialog progressDialog;
+
+        [STAThread]
+        static void Main()
+        {
+            Application.Run(new MainWindow());
+        }
+
+        public MainWindow()
+        {
+            imageFile = &quot;&quot;;
+            InitializeComponent();
+            IterateDevices();
+            if (deviceCombo.Items.Count &gt;= 1)
+                deviceCombo.SelectedIndex = 0;
+            selectButton.Click += new System.EventHandler(this.SelectImage);
+            copyButton.Click += new System.EventHandler(this.ButtonClicked);
+            // TODO USB load and unload notification
+        }
+
+        private void IterateDevices()
+        {
+            Console.WriteLine(&quot;Iterating&quot;);
+            string model;
+            string deviceString;
+            ManagementObjectSearcher physicalSearch = new ManagementObjectSearcher(&quot;SELECT * FROM Win32_DiskDrive WHERE InterfaceType = \&quot;USB\&quot; AND Size &lt;= 17179869184&quot;);
+            foreach (ManagementObject physicalDrive in physicalSearch.Get())
+            {
+                if (physicalDrive[&quot;MediaType&quot;].ToString().Substring(0, 9) != &quot;Removable&quot;)
+                    continue;
+
+                if (physicalDrive[&quot;Model&quot;] == null)
+                    model = &quot;Unknown Device&quot;;
+                else
+                    model = physicalDrive[&quot;Model&quot;].ToString();
+                deviceString = model + &quot; - (&quot; + Math.Round(((double)Convert.ToDouble(physicalDrive[&quot;Size&quot;]) / 1048576), 2) + &quot; MB)&quot;;
+                ImageDevice newDevice = new ImageDevice(deviceString);
+                newDevice.size = (long) Convert.ToInt64(physicalDrive[&quot;Size&quot;]);
+                newDevice.name = physicalDrive[&quot;Name&quot;].ToString();
+                newDevice.partitions = Convert.ToInt32(physicalDrive[&quot;Partitions&quot;]);
+                // Now see if there are any mounted volumes
+                foreach(ManagementObject partition in new ManagementObjectSearcher(&quot;ASSOCIATORS OF {Win32_DiskDrive.DeviceID='&quot; + physicalDrive[&quot;DeviceID&quot;] + &quot;'} WHERE AssocClass = Win32_DiskDriveToDiskPartition&quot;).Get())
+                    foreach(ManagementObject disk in new ManagementObjectSearcher(&quot;ASSOCIATORS OF {Win32_DiskPartition.DeviceID='&quot; + partition[&quot;DeviceID&quot;] + &quot;'} WHERE AssocClass = Win32_LogicalDiskToPartition&quot;).Get())
+                        newDevice.volume = &quot;\\\\.\\&quot; + disk[&quot;Name&quot;].ToString();
+                deviceCombo.Items.Add(newDevice);
+            }
+        }
+
+        private void ProgressCancelButtonClicked(object sender, EventArgs e)
+        {
+            copyWorker.CancelAsync();
+            progressDialog.Close();
+        }
+
+        private void ButtonClicked(object sender, System.EventArgs e)
+        {
+            if (imageFile == &quot;&quot;)
+            {
+                MessageBox.Show(&quot;Please choose an image to write&quot;, &quot;Error&quot;, MessageBoxButtons.OK);
+                return;
+            }
+
+            device = (ImageDevice) deviceCombo.SelectedItem;
+            if (imageSize &gt; device.size)
+            {
+                MessageBox.Show(&quot;The image is larger than your selected device&quot;, &quot;Error&quot;, MessageBoxButtons.OK);
+                return;
+            }
+
+            if (MessageBox.Show(&quot;This will overwrite everything on your disk.  Are you sure you want to proceed?&quot;, &quot;Confirm&quot;, MessageBoxButtons.YesNo) == DialogResult.No)
+                return;
+
+            copyWorker = new BackgroundWorker();
+            progressDialog = new ProgressDialog();
+            progressDialog.cancelButton.Click += new System.EventHandler(this.ProgressCancelButtonClicked);
+            progressDialog.ProgressToWrite = (int) (imageSize / 1048576);
+            copyWorker.WorkerReportsProgress = true;
+            copyWorker.DoWork += new DoWorkEventHandler(WorkerWork);
+            copyWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(WorkerDone);
+            copyWorker.ProgressChanged += new ProgressChangedEventHandler(WorkerProgressChanged);
+            copyWorker.WorkerSupportsCancellation = true;
+            copyWorker.RunWorkerAsync();
+            progressDialog.ShowDialog();
+        }
+        
+        void WorkerWork(object sender, DoWorkEventArgs e)
+        {
+            copyWorker.ReportProgress(0);
+            if (WriteToDisk())
+                MessageBox.Show(&quot;Success!&quot;,&quot;&quot;,MessageBoxButtons.OK);
+        }
+
+        void WorkerProgressChanged(object sender, ProgressChangedEventArgs e)
+        {
+            progressDialog.ProgressValue = e.ProgressPercentage;
+        }
+
+        void WorkerDone(object sender, RunWorkerCompletedEventArgs e)
+        {
+            progressDialog.Close();
+        }
+
+        private void SelectImage(object sender, System.EventArgs e)
+        {
+            OpenFileDialog imageFileDialog = new OpenFileDialog();
+            imageFileDialog.Filter = &quot;Image Files (*.raw)|*.raw&quot;;
+            imageFileDialog.RestoreDirectory = true;
+
+            if (imageFileDialog.ShowDialog() == DialogResult.OK)
+            {
+                imageFile = imageFileDialog.FileName;
+                imageSize = new FileInfo(imageFile).Length;
+                filePathTextBox.Text = imageFile + &quot; (&quot; + (imageSize / 1048576) + &quot;MB)&quot;;
+            }
+        }
+
+        private bool WriteToDisk()
+        {
+            DriveAccess d = new DriveAccess();
+            byte[] buffer;
+            bool retval = true;
+            long written = 0;
+            int writtenMB = 0;
+            try
+            {
+                d.Open(device.name);
+            }
+            catch (Win32Exception e)
+            {
+                MessageBox.Show(&quot;Could not open device.  Are you sure you're running this as an administrator?&quot;, &quot;Error&quot;, MessageBoxButtons.OK);
+                return false;
+            }
+
+            if (device.volume != &quot;&quot;) // Not necessary for devices with an unknown filesystem
+            {
+                DriveAccess c = new DriveAccess();
+                try
+                {
+                    c.Open(device.volume);
+                    c.DeviceIO(DriveAccess.FSCTL_DISMOUNT_VOLUME);
+                }
+                catch (Win32Exception e)
+                {
+                    /* This gets thrown on XP for devices that do not have a valid filesystem.
+                     * Let's just ignore it and hope nothing breaks.
+                     */
+                }
+            }
+
+            try
+            {
+                d.DeviceIO(DriveAccess.FSCTL_LOCK_VOLUME);
+            }
+            catch (Win32Exception e)
+            {
+                MessageBox.Show(&quot;Exception caught: &quot; + e, &quot;Error&quot;, MessageBoxButtons.OK);
+                d.Close();
+                return false;
+            }
+
+            FileStream fileIn = new FileStream(imageFile, FileMode.Open);
+            try
+            {
+                int count;
+                buffer = new byte[BLOCK_SIZE];
+                while ((count = fileIn.Read(buffer, 0, BLOCK_SIZE)) &gt; 0)
+                {
+                    if (copyWorker.CancellationPending)
+                    {
+                        retval = false;
+                        break;
+                    }
+
+                    written += count;
+                    writtenMB = (int) (written / 1048576);
+                    copyWorker.ReportProgress(writtenMB);
+                    d.Write(buffer, (uint)count);
+                }
+            }
+            catch (Win32Exception e)
+            {
+                MessageBox.Show(&quot;Exception caught during write: &quot; + e, &quot;Error&quot;, MessageBoxButtons.OK);
+                d.Close();
+                return false;
+            }
+            finally
+            {
+                fileIn.Close();
+            }
+
+            try { d.DeviceIO(DriveAccess.FSCTL_UNLOCK_VOLUME); }
+            catch (Win32Exception e) { MessageBox.Show(&quot;Could not unlock device: &quot; + e, &quot;Error&quot;, MessageBoxButtons.OK); }
+
+            d.Close();
+            return retval;
+        }
+    }
+
+    public class ImageDevice
+    {
+        public string displayName;
+        public string name;
+        public string volume;
+        public long size;
+        public int partitions;
+
+        public ImageDevice(string name)
+        {
+            displayName = name;
+            partitions = 0;
+            volume = &quot;&quot;;
+        }
+
+        public override string ToString()
+        {
+            return displayName;
+        }
+    }
+
+    public class DriveAccess
+    {   
+        public const uint FSCTL_LOCK_VOLUME = 0x00090018;
+        public const uint FSCTL_UNLOCK_VOLUME = 0x0009001C;
+        public const uint FSCTL_DISMOUNT_VOLUME = 0x00090020;
+        const uint GENERIC_READ = 0x80000000;
+        const uint GENERIC_WRITE = 0x40000000;
+        const uint FILE_FLAG_NO_BUFFERING = 0x20000000;
+        const uint FILE_FLAG_WRITE_THROUGH = 0x80000000;
+        const uint OPEN_EXISTING = 3;
+        System.IntPtr handle;
+
+        public void Open(string fileName)
+        {     
+            handle = CreateFile
+            (
+                fileName,
+                GENERIC_WRITE, // Need write access
+                0,  // Don't let other processes touch the device
+                0,  // Security attributes, ignore
+                OPEN_EXISTING,
+                FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH, // Flags - TODO: do we want to disable buffering?
+                0 // Template file, ignore
+            );
+
+            if (handle.ToInt32() == -1)
+                throw new Win32Exception(Marshal.GetLastWin32Error());
+        }
+
+        public bool Close()
+        {
+            return CloseHandle(handle);
+        }
+
+        public unsafe uint Write(byte[] buffer, uint len)
+        {
+            uint written = 0;
+            if (!WriteFile(handle, buffer, len, ref written, IntPtr.Zero))
+                throw new Win32Exception(Marshal.GetLastWin32Error());
+
+            return written;
+        }
+
+        public int DeviceIO(uint accessType)
+        {
+            int ret;
+            uint bytesReturned = 0;
+            ret = DeviceIoControl
+            (
+                handle,
+                accessType,
+                IntPtr.Zero,
+                0,
+                IntPtr.Zero,
+                0,
+                ref bytesReturned,
+                IntPtr.Zero
+            );
+            if (ret == 0)
+                throw new Win32Exception(Marshal.GetLastWin32Error());
+            return ret;
+        }
+
+        // Win32 wrappers
+        [DllImport(&quot;kernel32&quot;, SetLastError = true)]
+        static extern unsafe IntPtr CreateFile
+        (
+            string lpFileName,
+            uint dwDesiredAccess,
+            uint dwShareMode,
+            uint lpSecurityAttributes,
+            uint dwCreationDisposition,
+            uint dwFlagsAndAttributes, 
+            int hTemplateFile
+        );
+
+        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]
+        static extern unsafe bool WriteFile
+        (
+            IntPtr hFile,
+            Byte[] lpBuffer,
+            UInt32 nNumberOfBytesToWrite,
+            ref UInt32 lpNumberOfBytesWritten,
+            IntPtr lpOverlapped
+        );
+
+        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]
+        static extern unsafe int DeviceIoControl
+        (
+            IntPtr hDevice,
+            uint IoControlCode,
+            IntPtr lpInBuffer,
+            uint InBufferSize,
+            IntPtr lpOutBuffer,
+            uint nOutBufferSize,
+            ref uint lpBytesReturned,
+            IntPtr lpOverlapped
+        );
+
+        [DllImport(&quot;kernel32&quot;, SetLastError = true)]
+        static extern unsafe bool CloseHandle (IntPtr hObject);
+    }
+  
+}
diff --git a/tools/burner/windows/ImageWriter/MainWindow.resx b/tools/burner/windows/ImageWriter/MainWindow.resx
new file mode 100755
index 0000000..ff31a6d
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/MainWindow.resx
@@ -0,0 +1,120 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;root&gt;
+  &lt;!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers &amp; schema ...
+    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
+    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
+    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
+    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
+    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
+    &lt;/data&gt;
+    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
+        &lt;comment&gt;This is a comment&lt;/comment&gt;
+    &lt;/data&gt;
+                
+    There are any number of &quot;resheader&quot; rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    --&gt;
+  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
+    &lt;xsd:import namespace=&quot;<A HREF="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</A>&quot; /&gt;
+    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
+      &lt;xsd:complexType&gt;
+        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
+          &lt;xsd:element name=&quot;metadata&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;assembly&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;data&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;resheader&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+        &lt;/xsd:choice&gt;
+      &lt;/xsd:complexType&gt;
+    &lt;/xsd:element&gt;
+  &lt;/xsd:schema&gt;
+  &lt;resheader name=&quot;resmimetype&quot;&gt;
+    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;version&quot;&gt;
+    &lt;value&gt;2.0&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;reader&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;writer&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+&lt;/root&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/ProgressDialog.Designer.cs b/tools/burner/windows/ImageWriter/ProgressDialog.Designer.cs
new file mode 100755
index 0000000..4a03a46
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/ProgressDialog.Designer.cs
@@ -0,0 +1,128 @@
+&#239;&#187;&#191;/*
+ *  Copyright (c) 2009 Novell, Inc.
+ *  All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, contact Novell, Inc.
+ *
+ *  To contact Novell about this file by physical or electronic mail,
+ *  you may find current contact information at www.novell.com
+ *
+ *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
+ *
+ */
+
+namespace ImageWriter
+{
+    partial class ProgressDialog
+    {
+        /// &lt;summary&gt;
+        /// Required designer variable.
+        /// &lt;/summary&gt;
+        private System.ComponentModel.IContainer components = null;
+
+        /// &lt;summary&gt;
+        /// Clean up any resources being used.
+        /// &lt;/summary&gt;
+        /// &lt;param name=&quot;disposing&quot;&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt;
+        protected override void Dispose(bool disposing)
+        {
+        if (disposing &amp;&amp; (components != null))
+        {
+        components.Dispose();
+        }
+        base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// &lt;summary&gt;
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// &lt;/summary&gt;
+        private void InitializeComponent()
+        {
+        this.cancelButton = new System.Windows.Forms.Button();
+        this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();
+        this.writeProgressBar = new System.Windows.Forms.ProgressBar();
+        this.progressLabel = new System.Windows.Forms.Label();
+        this.flowLayoutPanel1.SuspendLayout();
+        this.SuspendLayout();
+        // 
+        // cancelButton
+        // 
+        this.cancelButton.Location = new System.Drawing.Point(303, 121);
+        this.cancelButton.Name = &quot;cancelButton&quot;;
+        this.cancelButton.Size = new System.Drawing.Size(75, 23);
+        this.cancelButton.TabIndex = 1;
+        this.cancelButton.Text = &quot;Cancel&quot;;
+        this.cancelButton.UseVisualStyleBackColor = true;
+        // 
+        // flowLayoutPanel1
+        // 
+        this.flowLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
+        this.flowLayoutPanel1.Controls.Add(this.writeProgressBar);
+        this.flowLayoutPanel1.Controls.Add(this.progressLabel);
+        this.flowLayoutPanel1.FlowDirection = System.Windows.Forms.FlowDirection.TopDown;
+        this.flowLayoutPanel1.Location = new System.Drawing.Point(12, 33);
+        this.flowLayoutPanel1.Name = &quot;flowLayoutPanel1&quot;;
+        this.flowLayoutPanel1.Size = new System.Drawing.Size(366, 51);
+        this.flowLayoutPanel1.TabIndex = 2;
+        // 
+        // writeProgressBar
+        // 
+        this.writeProgressBar.Location = new System.Drawing.Point(3, 3);
+        this.writeProgressBar.Name = &quot;writeProgressBar&quot;;
+        this.writeProgressBar.Size = new System.Drawing.Size(363, 23);
+        this.writeProgressBar.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
+        this.writeProgressBar.TabIndex = 0;
+        // 
+        // progressLabel
+        // 
+        this.progressLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
+        this.progressLabel.AutoSize = true;
+        this.progressLabel.Location = new System.Drawing.Point(3, 29);
+        this.progressLabel.Name = &quot;progressLabel&quot;;
+        this.progressLabel.Size = new System.Drawing.Size(363, 13);
+        this.progressLabel.TabIndex = 1;
+        this.progressLabel.Text = &quot;Written 0 MB out of X MB&quot;;
+        this.progressLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
+        // 
+        // ProgressDialog
+        // 
+        this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+        this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+        this.ClientSize = new System.Drawing.Size(390, 156);
+        this.ControlBox = false;
+        this.Controls.Add(this.flowLayoutPanel1);
+        this.Controls.Add(this.cancelButton);
+        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
+        this.MaximizeBox = false;
+        this.MinimizeBox = false;
+        this.Name = &quot;ProgressDialog&quot;;
+        this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
+        this.Text = &quot;Writing to disk...&quot;;
+        this.flowLayoutPanel1.ResumeLayout(false);
+        this.flowLayoutPanel1.PerformLayout();
+        this.ResumeLayout(false);
+
+        }
+
+        #endregion
+
+        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
+        private System.Windows.Forms.ProgressBar writeProgressBar;
+        private System.Windows.Forms.Label progressLabel;
+        public System.Windows.Forms.Button cancelButton;
+
+    }
+}
diff --git a/tools/burner/windows/ImageWriter/ProgressDialog.cs b/tools/burner/windows/ImageWriter/ProgressDialog.cs
new file mode 100755
index 0000000..76ccca5
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/ProgressDialog.cs
@@ -0,0 +1,72 @@
+&#239;&#187;&#191;/*
+ *  Copyright (c) 2009 Novell, Inc.
+ *  All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, contact Novell, Inc.
+ *
+ *  To contact Novell about this file by physical or electronic mail,
+ *  you may find current contact information at www.novell.com
+ *
+ *  Author: Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Text;
+using System.Windows.Forms;
+
+namespace ImageWriter
+{
+    public partial class ProgressDialog : Form
+    {
+        private int toWrite;
+        public ProgressDialog()
+        {
+            InitializeComponent();
+        }
+
+        public void SetWritten(int written)
+        {
+            string writtenText = &quot;Written &quot; + written + &quot;MB out of &quot; + toWrite + &quot;MB&quot;;
+            this.progressLabel.Text = writtenText;
+        }
+        private void ButtonClicked(object sender, EventArgs e)
+        {
+            this.Close();
+        }
+
+        public int ProgressValue
+        {
+            get { return writeProgressBar.Value; }
+            set
+            {
+                writeProgressBar.Value = value;
+                SetWritten(value);
+            }
+        }
+
+        public int ProgressToWrite
+        {
+            get { return toWrite; }
+            set
+            { 
+                toWrite = value;
+                writeProgressBar.Maximum = toWrite;
+            }
+        }
+    }
+}
diff --git a/tools/burner/windows/ImageWriter/ProgressDialog.resx b/tools/burner/windows/ImageWriter/ProgressDialog.resx
new file mode 100755
index 0000000..ff31a6d
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/ProgressDialog.resx
@@ -0,0 +1,120 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;root&gt;
+  &lt;!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers &amp; schema ...
+    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
+    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
+    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
+    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
+    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
+    &lt;/data&gt;
+    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
+        &lt;comment&gt;This is a comment&lt;/comment&gt;
+    &lt;/data&gt;
+                
+    There are any number of &quot;resheader&quot; rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    --&gt;
+  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
+    &lt;xsd:import namespace=&quot;<A HREF="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</A>&quot; /&gt;
+    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
+      &lt;xsd:complexType&gt;
+        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
+          &lt;xsd:element name=&quot;metadata&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;assembly&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;data&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;resheader&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+        &lt;/xsd:choice&gt;
+      &lt;/xsd:complexType&gt;
+    &lt;/xsd:element&gt;
+  &lt;/xsd:schema&gt;
+  &lt;resheader name=&quot;resmimetype&quot;&gt;
+    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;version&quot;&gt;
+    &lt;value&gt;2.0&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;reader&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;writer&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+&lt;/root&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/Properties/AssemblyInfo.cs b/tools/burner/windows/ImageWriter/Properties/AssemblyInfo.cs
new file mode 100755
index 0000000..c428f0c
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+&#239;&#187;&#191;using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle(&quot;ImageWriter&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;Novell&quot;)]
+[assembly: AssemblyProduct(&quot;SUSE Studio ImageWriter&quot;)]
+[assembly: AssemblyCopyright(&quot;Copyright &#194;&#169; Novell 2009&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid(&quot;1b6e42f4-dfca-47fb-8c5c-7c394e32c6f2&quot;)]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]
+[assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]
diff --git a/tools/burner/windows/ImageWriter/Properties/Resources.Designer.cs b/tools/burner/windows/ImageWriter/Properties/Resources.Designer.cs
new file mode 100755
index 0000000..72bdc7a
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/Resources.Designer.cs
@@ -0,0 +1,70 @@
+&#239;&#187;&#191;//------------------------------------------------------------------------------
+// &lt;auto-generated&gt;
+//     This code was generated by a tool.
+//     Runtime Version:2.0.50727.4200
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// &lt;/auto-generated&gt;
+//------------------------------------------------------------------------------
+
+namespace ImageWriter.Properties {
+    using System;
+    
+    
+    /// &lt;summary&gt;
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// &lt;/summary&gt;
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;System.Resources.Tools.StronglyTypedResourceBuilder&quot;, &quot;2.0.0.0&quot;)]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources {
+        
+        private static global::System.Resources.ResourceManager resourceMan;
+        
+        private static global::System.Globalization.CultureInfo resourceCulture;
+        
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(&quot;Microsoft.Performance&quot;, &quot;CA1811:AvoidUncalledPrivateCode&quot;)]
+        internal Resources() {
+        }
+        
+        /// &lt;summary&gt;
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// &lt;/summary&gt;
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager {
+            get {
+                if (object.ReferenceEquals(resourceMan, null)) {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(&quot;ImageWriter.Properties.Resources&quot;, typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+        
+        /// &lt;summary&gt;
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// &lt;/summary&gt;
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture {
+            get {
+                return resourceCulture;
+            }
+            set {
+                resourceCulture = value;
+            }
+        }
+        
+        internal static System.Drawing.Bitmap logo_suse {
+            get {
+                object obj = ResourceManager.GetObject(&quot;logo_suse&quot;, resourceCulture);
+                return ((System.Drawing.Bitmap)(obj));
+            }
+        }
+    }
+}
diff --git a/tools/burner/windows/ImageWriter/Properties/Resources.resx b/tools/burner/windows/ImageWriter/Properties/Resources.resx
new file mode 100755
index 0000000..78d50b6
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/Resources.resx
@@ -0,0 +1,124 @@
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;root&gt;
+  &lt;!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers &amp; schema ...
+    &lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;
+    &lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;
+    &lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;
+    &lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;
+    &lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;
+    &lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;
+    &lt;/data&gt;
+    &lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
+        &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;
+        &lt;comment&gt;This is a comment&lt;/comment&gt;
+    &lt;/data&gt;
+                
+    There are any number of &quot;resheader&quot; rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    --&gt;
+  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;
+    &lt;xsd:import namespace=&quot;<A HREF="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</A>&quot; /&gt;
+    &lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;
+      &lt;xsd:complexType&gt;
+        &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;
+          &lt;xsd:element name=&quot;metadata&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;assembly&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;data&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+                &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;
+              &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;
+              &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+          &lt;xsd:element name=&quot;resheader&quot;&gt;
+            &lt;xsd:complexType&gt;
+              &lt;xsd:sequence&gt;
+                &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;
+              &lt;/xsd:sequence&gt;
+              &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;
+            &lt;/xsd:complexType&gt;
+          &lt;/xsd:element&gt;
+        &lt;/xsd:choice&gt;
+      &lt;/xsd:complexType&gt;
+    &lt;/xsd:element&gt;
+  &lt;/xsd:schema&gt;
+  &lt;resheader name=&quot;resmimetype&quot;&gt;
+    &lt;value&gt;text/microsoft-resx&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;version&quot;&gt;
+    &lt;value&gt;2.0&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;reader&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;resheader name=&quot;writer&quot;&gt;
+    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+  &lt;/resheader&gt;
+  &lt;assembly alias=&quot;System.Windows.Forms&quot; name=&quot;System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; /&gt;
+  &lt;data name=&quot;logo_suse&quot; type=&quot;System.Resources.ResXFileRef, System.Windows.Forms&quot;&gt;
+    &lt;value&gt;..\Resources\logo-suse.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&lt;/value&gt;
+  &lt;/data&gt;
+&lt;/root&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/Properties/Settings.Designer.cs b/tools/burner/windows/ImageWriter/Properties/Settings.Designer.cs
new file mode 100755
index 0000000..79e2bc0
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/Settings.Designer.cs
@@ -0,0 +1,26 @@
+&#239;&#187;&#191;//------------------------------------------------------------------------------
+// &lt;auto-generated&gt;
+//     This code was generated by a tool.
+//     Runtime Version:2.0.50727.4200
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// &lt;/auto-generated&gt;
+//------------------------------------------------------------------------------
+
+namespace ImageWriter.Properties {
+    
+    
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator&quot;, &quot;9.0.0.0&quot;)]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
+        
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+        
+        public static Settings Default {
+            get {
+                return defaultInstance;
+            }
+        }
+    }
+}
diff --git a/tools/burner/windows/ImageWriter/Properties/Settings.settings b/tools/burner/windows/ImageWriter/Properties/Settings.settings
new file mode 100755
index 0000000..2bd17f0
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/Settings.settings
@@ -0,0 +1,5 @@
+&#239;&#187;&#191;&lt;?xml version='1.0' encoding='utf-8'?&gt;
+&lt;SettingsFile xmlns=&quot;<A HREF="http://schemas.microsoft.com/VisualStudio/2004/01/settings">http://schemas.microsoft.com/VisualStudio/2004/01/settings</A>&quot; CurrentProfile=&quot;(Default)&quot;&gt;
+  &lt;Profiles /&gt;
+  &lt;Settings /&gt;
+&lt;/SettingsFile&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/Properties/app.manifest b/tools/burner/windows/ImageWriter/Properties/app.manifest
new file mode 100755
index 0000000..7e9ed83
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/Properties/app.manifest
@@ -0,0 +1,26 @@
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;asmv1:assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; xmlns:asmv1=&quot;urn:schemas-microsoft-com:asm.v1&quot; xmlns:asmv2=&quot;urn:schemas-microsoft-com:asm.v2&quot; xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot;&gt;
+  &lt;assemblyIdentity version=&quot;1.0.0.0&quot; name=&quot;MyApplication.app&quot; /&gt;
+  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt;
+    &lt;security&gt;
+      &lt;requestedPrivileges xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
+        &lt;!-- UAC Manifest Options
+            If you want to change the Windows User Account Control level replace the 
+            requestedExecutionLevel node with one of the following.
+
+        &lt;requestedExecutionLevel  level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&gt;
+        &lt;requestedExecutionLevel  level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&gt;
+        &lt;requestedExecutionLevel  level=&quot;highestAvailable&quot; uiAccess=&quot;false&quot; /&gt;
+
+            If you want to utilize File and Registry Virtualization for backward 
+            compatibility then delete the requestedExecutionLevel node.
+        --&gt;
+        &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&gt;
+      &lt;/requestedPrivileges&gt;
+      &lt;applicationRequestMinimum&gt;
+        &lt;defaultAssemblyRequest permissionSetReference=&quot;Custom&quot; /&gt;
+        &lt;PermissionSet class=&quot;System.Security.PermissionSet&quot; version=&quot;1&quot; Unrestricted=&quot;true&quot; ID=&quot;Custom&quot; SameSite=&quot;site&quot; /&gt;
+      &lt;/applicationRequestMinimum&gt;
+    &lt;/security&gt;
+  &lt;/trustInfo&gt;
+&lt;/asmv1:assembly&gt;
\ No newline at end of file
diff --git a/tools/burner/windows/ImageWriter/Resources/Vista-suse.png b/tools/burner/windows/ImageWriter/Resources/Vista-suse.png
new file mode 100755
index 0000000..1230347
Binary files /dev/null and b/tools/burner/windows/ImageWriter/Resources/Vista-suse.png differ
diff --git a/tools/burner/windows/ImageWriter/Resources/logo-suse.png b/tools/burner/windows/ImageWriter/Resources/logo-suse.png
new file mode 100755
index 0000000..e78cd6c
Binary files /dev/null and b/tools/burner/windows/ImageWriter/Resources/logo-suse.png differ
diff --git a/tools/burner/windows/ImageWriter/app.config b/tools/burner/windows/ImageWriter/app.config
new file mode 100755
index 0000000..3d9ebe2
--- /dev/null
+++ b/tools/burner/windows/ImageWriter/app.config
@@ -0,0 +1,5 @@
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;configuration&gt;
+    &lt;configSections&gt;
+    &lt;/configSections&gt;
+&lt;startup&gt;&lt;supportedRuntime version=&quot;v2.0.50727&quot;/&gt;&lt;/startup&gt;&lt;/configuration&gt;
diff --git a/LICENSE b/tools/burner/windows/LICENSE
old mode 100755
new mode 100644
similarity index 100%
copy from LICENSE
copy to tools/burner/windows/LICENSE
diff --git a/tools/burner/windows/README b/tools/burner/windows/README
new file mode 100644
index 0000000..95bdb4a
--- /dev/null
+++ b/tools/burner/windows/README
@@ -0,0 +1,7 @@
+SUSE Studio ImageWriter for Windows
+
+This program is known to work on Vista and XP with .NET 2.0 SP2.
+It doesn't seem to work on Windows 7 - if you can figure out why, please
+let me know :-)
+
+- Matt Barringer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/kiwi-devel">mbarringer at suse.de</A>&gt;


hooks/post-receive
-- 
Project kiwi at BerliOS

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001715.html">[Kiwi-devel] image creation problem
</A></li>
	<LI>Next message: <A HREF="001693.html">[Kiwi-devel] [Git]Project kiwi at BerliOS branch, master,	updated. 42cbf60d78be7aed683957087405d1ca6eb48c94
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1716">[ date ]</a>
              <a href="thread.html#1716">[ thread ]</a>
              <a href="subject.html#1716">[ subject ]</a>
              <a href="author.html#1716">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/kiwi-devel">More information about the Kiwi-devel
mailing list</a><br>
</body></html>
